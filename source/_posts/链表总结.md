---
title: 链表总结
date: 2020-08-17 10:37:43
tags:
  - Algorithm
  - Java
  - 链表
categories: Algorithm
visible: hide
typora-copy-images-to: ..\pictures
---

本文主要总结了 LeetCode 上链表相关的题目，会持续更新~

## 1. 链表相关的题目列表

本文的题目列表如下：

<!--more-->

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
|  83  | [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) |        |
|  82  | [删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) |  Hard  |
|  86  | [分隔链表](https://leetcode-cn.com/problems/partition-list/) |        |
|  2   |                                                              |        |
|  25  |                                                              |        |
|  61  |                                                              |        |
| 206  | [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |        |
|  92  | [反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) |        |

## 2. 删除排序链表中的重复元素 [83]

题目来源：[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

### 2.1. 题目描述

![image-20200818094630464](/pictures/image-20200818094630464.png)

### 2.2. 方法一：迭代

保存前一个节点 pre, 遇到与 pre 相同的节点就往后移，找到不同的节点，接到 pre 的后面。

```java
public ListNode deleteDuplicates(ListNode head) {
    if(head == null || head.next == null){return head;}

    ListNode pre = head, curr = head.next;
    while (curr != null){
        while (curr != null && curr.val == pre.val){
            curr = curr.next;
        }
        pre.next = curr;
        pre = curr;
        if(curr != null){
            curr = curr.next;
        }
    }
    return head;
}
```

### 2.3. 方法二：迭代（去掉 pre）

参考 [这里](https://leetcode.wang/leetCode-83-Remove-Duplicates-from-Sorted-List.html) 解法二。这道题其实不用 pre 节点也可以完成，不用找到所有重复的数字进行删除，即遇到一个重复数字，删除一个。这样代码看起来更加简洁了：

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while (cur != null && cur.next != null){
        if(cur.val == cur.next.val){
            cur.next = cur.next.next;
        }else{
            cur = cur.next;
        }
    }
    return head;
}
```

## 3. 删除排序链表中的重复元素 II [82]

题目来源：[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

### 3.1. 题目描述

![image-20200818100806984](/pictures/image-20200818100806984.png)

注意：和上一题相比，本题要求只要是重复的元素需要全部删除，一个不留。

### 3.2. 迭代

这道题自己写了很久...还是没写出来..

参考 [这里](https://leetcode.wang/leetCode-82-Remove-Duplicates-from-Sorted-ListII.html) 的解法一。对于链表的操作，如果头结点可能删除，可以使用 dummy 节点，指向 head，最终返回 dummy.next 节点即可，这样可以简化边界问题，不用单独处理。

```java
public ListNode deleteDuplicates(ListNode head) {
    // 定义dummy节点
    ListNode pre = new ListNode(0);
    ListNode dummy = pre;
    pre.next = head;

    ListNode curr = head;
    while (curr != null && curr.next != null){
        boolean equal = false;
        // cur 和 cur.next 一直相等，一直后移
        while (curr.next != null && curr.val == curr.next.val){
            curr = curr.next;
            equal = true;
        }
        // 如果相等
        // pre.next 直接指向 cur.next 删除所有重复数字
        if(equal){
            pre.next = curr.next;

            // 如果不相等
            // pre 移到 cur 的地方
        }else{
            pre = curr;
        }

        // cur 后移
        curr = curr.next;
    }
    return dummy.next;
}
```

## 4. 分隔链表 [86]

题目来源：[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

### 4.1. 题目描述

![image-20200818112245505](/pictures/image-20200818112245505.png)

### 4.2. 解法一：分成两个链表

注意链表出现环的情况，参考 [这里](https://leetcode.wang/leetCode-86-Partition-List.html) 的解法二。

```java
public ListNode partition(ListNode head, int x) {
    // 小于x的链表
    ListNode lowDummy = new ListNode(0);
    ListNode lowCur = lowDummy;
    // 大于等于x的链表
    ListNode highDummy = new ListNode(0);
    ListNode highCur = highDummy;

    ListNode cur = head;
    while (cur != null){
        if(cur.val < x){
            lowCur.next = cur;
            lowCur = lowCur.next;
        }else{
            highCur.next = cur;
            highCur = highCur.next;
        }
        cur = cur.next;
    }
    // 一定要注意添加这一步，不然链表会出现环
    highCur.next = null;
    // 链表拼接
    lowCur.next = highDummy.next;
    return lowDummy.next;
}
```

### 4.3. 解法二：头插法

遍历整个链表，找到小于 x 的节点，插入到前面。前面和后面都需要一个 pre 节点保存应该插入和删除的位置。（自己想的..）

```java
public ListNode partition(ListNode head, int x) {
    if(head == null){return head;}
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // pre 表示遍历节点cur的前一个，用于删除
    ListNode cur = head, pre = dummy;
    // pre2 表示插入位置的前一个
    ListNode pre2 = dummy;
    while (cur != null){
        int s = cur.val;
        if(cur.val < x){
            // 删除原位置元素
            pre.next = cur.next;
            pre = pre.next;
            // 插入到前面位置
            cur.next = pre2.next;
            pre2.next = cur;
            pre2 = cur;

        }
        pre = cur;
        cur = cur.next;
    }
    return dummy.next;
}
```

链表的题目，一定要仔细。

## 5. 反转链表 [206]

题目来源：[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

### 5.1. 题目描述

![image-20200826094442518](/pictures/image-20200826094442518.png)

### 5.2. 方法一：迭代

迭代方法比较好想，添加一个 dummy 节点更好理解。

```java
public ListNode reverseList(ListNode head) {
    if(head == null){return null;}
    ListNode dummy = new ListNode(0);
    dummy.next = null;

    ListNode cur = head;
    while (cur != null){
        ListNode tmp = cur.next;
        cur.next = dummy.next;
        dummy.next = cur;
        cur = tmp;
    }
    return dummy.next;
}
```

### 5.3. 方法二：递归

思路参考：[这里](https://leetcode.wang/leetcode-206-Reverse-Linked-List.html)。

```java
public ListNode reverseList(ListNode head) {
    // 递归出口
    if(head == null || head.next == null){
        return head;
    }
    // 大问题变为小问题：head.next作为剩余部分的头指针
    ListNode newHead = reverseList(head.next);
    // head.next 代表新链表的尾，将他的 next 置为 head，即就是把 head 加到末尾
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

## 6. 反转链表 II [92]

题目来源：[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

### 6.1. 题目描述

![image-20200826101920949](/pictures/image-20200826101920949.png)

### 6.2. 代码

头结点需要单独处理，使用 dummy 节点。这题不难，仔细一点注意节点指向即可。

```java
public ListNode reverseBetween(ListNode head, int m, int n) {
    int count = 1;
    ListNode dummy = new ListNode(0);
    dummy.next = null;
    ListNode cur = head;
    ListNode pre = dummy;
    while (cur != null){
        if (m == count){
            ListNode pre2 = pre;
            pre = cur;
            for(; count <= n; count++){
                ListNode next = cur.next;
                cur.next = pre2.next;
                pre2.next = cur;
                cur = next;
            }
        }else{
            ListNode tmp = cur.next;
            cur.next = pre.next;
            pre.next = cur;
            pre = cur;
            cur = tmp;
            count++;
        }

    }
    return dummy.next;
}
```

## 7. 参考引用

1. https://leetcode.wang/leetCode-83-Remove-Duplicates-from-Sorted-List.html
2. https://leetcode.wang/leetCode-86-Partition-List.html
3. https://leetcode.wang/leetcode-206-Reverse-Linked-List.html