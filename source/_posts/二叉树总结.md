---
title: 二叉树总结
date: 2020-07-10 08:45:47
tags:
  - Algorithm
  - Java
  - 二叉树
categories: Algorithm
---

本文介绍了什么是二叉树，同时解决了部分LeetCode上二叉树相关的题目，这部分会持续更新。

## 1. 什么是二叉树？

[维基定义](https://zh.wikipedia.org/wiki/二叉树)：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。

二叉树的第 ``i`` 层至多拥有 2<sup>i-1</sup> 个节点；深度为 k 的二叉树至多总共有 2<sup>k</sup>-1 个节点（定义根节点所在深度 k<sub>0</sub>=0}），而总计拥有节点数符合的，称为 **满二叉树**；深度为 k 有 n 个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度 k 的满二叉树，序号为1到 n 的节点一对一对应时，称为 **完全二叉树**。对任何一棵非空的二叉树T，如果其叶片（终端节点）数为 n<sub>0</sub>，分支度为2的节点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1。

与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。

二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。

<!--more-->

## 2. 二叉树相关的题目列表

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
|  94  | [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) |        |
| 144  | [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) |        |
| 145  | [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) |        |
| 102  | [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) |        |
| 107  | [二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) |        |
| 104  | [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |        |
| 100  |   [相同的树](https://leetcode-cn.com/problems/same-tree/)    |        |
| 101  | [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) |  Hard  |
| 103  | [二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) |  Hard  |
| 105  | [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |        |
| 106  |                                                              |        |
|  98  |                                                              |        |

### 2.1. 队列操作总结（LinkedList）

参考 [这里](https://blog.csdn.net/NRlovestudy/article/details/98666030)，具体操作如下：

```java
Deque<String> queue = new LinkedList<>();
// 尾部添加元素
queue.add("A");
queue.add("B");
queue.add("C");
System.out.println(queue); // [A, B, C]

// 获取但不删除第一个元素
String peek = queue.peek();
System.out.println(peek + " ## " + queue); // A ## [A, B, C]

// 获取并删除第一个元素，没有元素时会发生异常
String pop = queue.pop();
System.out.println(pop + " ## " + queue); // A ## [B, C]

// 获取并删除第一个元素，没有元素时返回null
String poll = queue.poll();
System.out.println(poll + " ## " + poll); // B ## B
```

总结：pop 与 poll 都是取出 LinkedList 的第一个元素，并将该元素删除，等效于 removeFirst；不同点：两者的实现所用数据结构不同：

- poll 是基于队列结构实现的方法，当队列中没有元素时，调用该方法返回 null
- pop 是基于栈结构实现的方法，当栈中没有元素时，调用该方法会发生异常

### 2.2. 栈操作总结（ArrayDeque）

```java
Deque<String> stack = new ArrayDeque<>();
// 入栈，即在首部添加元素
stack.push("A");
stack.push("B");
stack.push("C");
System.out.println(stack);      // [C, B, A]

// 获取栈顶元素，即第一个元素
System.out.println(stack.peek() + " ## " + stack); // C ## [C, B, A]

// 出栈，即获取并删除第一个元素
System.out.println(stack.pop() + " ## " + stack);    // C ## [B, A]
```

## 3. 二叉树的中序遍历 [94]

题目来源：[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 3.1. 题目描述

给定一个二叉树，返回它的中序 遍历。

示例:

```bash
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 3.2. 题目分析

分析参考 [这里](https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html).

中序遍历使用两种方法：递归和迭代。

### 3.3. 方法一：递归

时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}

private void helper(TreeNode node, List<Integer> res){
    if (node == null){return;}

    helper(node.left, res);
    res.add(node.val);
    helper(node.right, res);
}
```

### 3.4. 方法二：栈

时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。

利用栈模拟递归。递归压栈过程，就是保存现场，保存当前的变量。在方法一中，当前有用的变量就是 node，所以我们用栈把每一次的 node 保存起来。

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    // 程序中尽量避免使用Stack类，太古老，性能差，使用ArrayDeque代替
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()){
        // 节点不为空就一直压栈
        while (curr != null){
            stack.push(curr);
            // 考虑左子树
            curr = curr.left;
        }
        // 节点为空，就出栈
        curr = stack.pop();
        res.add(curr.val);
        // 考虑右子树
        curr = curr.right;
    }
    return res;
}
```

## 4. 二叉树的前序遍历 [144]

题目来源：[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 4.1. 题目描述

给定一个二叉树，返回它的 前序 遍历。

示例:

```bash
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 4.2. 题目分析

中序遍历的迭代法也使用栈实现。

### 4.3. 方法一：递归

```java
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}

private void helper(TreeNode node, List<Integer> res){
    if (node == null){return;}

    res.add(node.val);
    helper(node.left, res);
    helper(node.right, res);
}
```

### 4.4. 方法二：栈

与中序遍历的迭代方法相比，前序遍历只需要将访问的位置改到根节点处即可，其他代码不变。

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()){
        while (curr != null){
            // 在此处访问节点
            res.add(curr.val);
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.poll();
        curr = curr.right;
    }
    return res;
}
```

## 5. 二叉树的后序遍历 [145]

题目来源：[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 5.1. 题目描述

给定一个二叉树，返回它的 后序 遍历。

示例:

```bash
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 5.2. 方法一：递归

```java
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}

private void helper(TreeNode node, List<Integer> res){
    if (node == null){return;}

    helper(node.left, res);
    helper(node.right, res);
    res.add(node.val);
}
```

### 5.3. 方法二：栈

相比于前序、中序的栈解法，后序遍历的栈解法会难一些。

原因在于，当遍历完某个根节点的左子树，回到根节点时，中序、先序可以把当前根节点从栈中弹出，然后转到右子树。举例如下：

```bash
     1
    / \
   2   3
  / \
 4   5
```

当遍历完 2,4,5 时，回到 1 之后就可以把 1 弹出，然后通过 1 到达右子树继续遍历。

而对于后序遍历，当我们到达 1 时，并不能立即把 1 弹出，因为遍历完右子树，还需要将根节点加入到 res 中。

因此，我们就需要判断是从左子树到的根节点，还是从右子树到的根节点。

如果是从左子树到的根节点，此时应该转到右子树。如果从右子树到的根节点，那么就可以弹出当前节点，并存储到 res 中。

当然，如果从左子树到的根节点，此时右子树为 null, 也需要把根节点弹出，并加入到 res 中。

基于上述分析，我们可以写出代码：

```java
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;
    // 记录上一个遍历的节点
    TreeNode pre = null;
    while (curr != null || !stack.isEmpty()){
        while (curr != null){
            stack.push(curr);
            curr = curr.left;
        }
        // 获取当前根节点
        TreeNode temp = stack.peek();
        // 是否变到右子树
        if(temp.right != null && temp.right != pre){
            curr = temp.right;
        }else{
            res.add(temp.val);
            // 记录上一个遍历的节点
            pre = temp;
            stack.pop();
        }
    }
    return res;
}
```

## 6. 二叉树的层序遍历 [102]

题目来源：[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

### 6.1. 题目描述

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],

```bash
	3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```bash
[
  [3],
  [9,20],
  [15,7]
]
```

### 6.2. 方法一：递归（DFS）

由于本题对于层序遍历的结果要求为 ``List<List<Integer>>``, 要把每一层的元素放在一个单独的列表中，因此在递归时需要传入当前层数，如果是新的一层，创建一个新的 ``List`` , 存储这一层的元素。

```java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null){return res;}
    helper(root, 0);
    return res;
}

private void helper(TreeNode node, Integer level){
    if(res.size() == level){
        res.add(new ArrayList<>());
    }
    res.get(level).add(node.val);
    if(node.left != null){
        helper(node.left, level + 1);
    }
    if(node.right != null){
        helper(node.right, level + 1);
    }
}
```

### 6.3. 方法二：队列（BFS）

依旧是本题对于返回结果的要求，每一层需要单独处理。

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()){
        // 当前层列表
        List<Integer> level = new ArrayList<>();

        // 当前队列中的元素个数，即就是当前层的节点数
        int levelNum = queue.size();
        // levelNum 必须在外面定义，因为 queue 的大小在不停的变化
        for(int i = 0; i < levelNum; i++){
            // 移除队列第一个元素
            TreeNode node = queue.remove();
            level.add(node.val);
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){queue.add(node.right);}
        }
        res.add(level);
    }
    return res;
}
```

## 7. 二叉树的层次遍历 II [107]

题目来源：[107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

### 7.1. 题目描述

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

```bash
	3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```bash
[
  [15,7],
  [9,20],
  [3]
]
```

### 7.2. 方法一：递归

本题的结果是上一题结果的反序，只需要在上一题添加列表时，在表头插入，以此得到反序序列即可。如下代码，改变三处：

```java
// 使用链表存储，在表头插入效率更高
LinkedList<List<Integer>> res = new LinkedList<>();

public List<List<Integer>> levelOrderBottom(TreeNode root) {
    if(root == null){return res;}
    helper(root, 0);
    return res;
}

private void helper(TreeNode node, Integer level){
    if(res.size() == level){
        // 在链表表头插入，得到反序序列
        res.addFirst(new ArrayList<>());
    }
    // 插入当前值，注意下标
    res.get(res.size() - level - 1).add(node.val);

    if(node.left != null){
        helper(node.left, level + 1);
    }
    if(node.right != null){
        helper(node.right, level + 1);
    }
}
```

### 7.3. 方法二：队列

与上一题区别：使用链表存储，插入时从表头插入，得到反序序列。

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    // 使用链表，在表头插入效率更高
    LinkedList<List<Integer>> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()){
        List<Integer> level = new ArrayList<>();
        int levelNum = queue.size();
        for(int i = 0; i < levelNum; i++){
            TreeNode node = queue.remove();
            level.add(node.val);
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){queue.add(node.right);}
        }
        // 在表头插入，得到反序结果
        res.addFirst(level);
    }
    return res;
}
```

## 8. 二叉树的最大深度 [104]

题目来源：[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

### 8.1.. 题目描述

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    	3
       / \
      9  20
        /  \
       15   7

返回它的最大深度 3 。

### 8.2. 方法一：递归（DFS）

```java
public int maxDepth(TreeNode root) {
    if(root == null){return 0;}
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

### 8.3. 方法二：层次遍历（BFS）

```java
public int maxDepth(TreeNode root) {
    if(root == null){return 0;}
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int level = 0;
    while (!queue.isEmpty()){
        level++;
        int size = queue.size();
        for(int i = 0; i < size; i++){
            TreeNode node = queue.remove();
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){ queue.add(node.right);}
        }
    }
    return level;
}
```

## 9. 相同的树 [100]

题目来源：[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

### 9.1. 题目描述

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

```bash
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例 2:

```bash
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```


示例 3:

```bash
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

### 9.2. 代码

思路：对两颗树同时进行遍历比较，这里使用的是中序遍历。

```java
public boolean isSameTree(TreeNode p, TreeNode q){
    if(p == null && q == null){
        return true;
    }
    if(p != null && q != null && p.val == q.val){
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
    return false;
}
```

## 10. 对称二叉树 [101]

题目来源：[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

### 10.1. 题目描述

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    	1
       / \
      2   2
     / \ / \
    3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    	1
       / \
      2   2
       \   \
       3    3

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

### 10.2. 方法一：递归

不是简单的比较左右就行，注意这道题是镜像对称的。这里的递归是基于先序遍历的，先看根节点，再判断左右节点，再判断左右节点的子节点是否为镜像对称。

其实就是类似于 DFS 的先序遍历。不同之处是对于 left 子树是正常的先序遍历 根节点 -> 左子树 -> 右子树 的顺序，对于 right 子树的话是 根节点 -> 右子树 -> 左子树 的顺序。

```java
public boolean isSymmetric(TreeNode root){
    if(root == null){return true;}
    return isMirror(root.left, root.right);
}

public boolean isMirror(TreeNode p, TreeNode q){
    if(p == null && q == null){return true;}
    if(p == null || q == null){return false;}
    if(p.val == q.val){
        return isMirror(p.left, q.right) && isMirror(p.right, q.left);
    }
    return false;
}
```

### 10.3. 方法二：迭代（栈）

参考：[这里](https://leetcode.wang/leetcode-101-Symmetric-Tree.html#解法二-dfs-栈).

把方法一的先序遍历，使用栈将递归改为迭代。使用两个栈分别存储左右字数的序列，出栈时比较。

```java
public boolean isSymmetric(TreeNode root){
    if(root == null){return true;}
    Deque<TreeNode> leftStack = new ArrayDeque<>();
    Deque<TreeNode> rightStack = new ArrayDeque<>();
    TreeNode leftCur = root.left;
    TreeNode rightCur = root.right;
    while (leftCur != null || rightCur != null || !leftStack.isEmpty() || !rightStack.isEmpty()){
        while (leftCur != null){
            leftStack.push(leftCur);
            // 考虑左子树
            leftCur = leftCur.left;
        }
        while (rightCur != null){
            rightStack.push(rightCur);
            // 考虑右子树
            rightCur = rightCur.right;
        }
        // 长度不同，就返回
        if(leftStack.size() != rightStack.size()){
            return false;
        }
        // 出栈
        leftCur = leftStack.poll();
        rightCur = rightStack.poll();
        if(leftCur.val != rightCur.val){
            return false;
        }
        // 考虑右子树
        leftCur = leftCur.right;
        // 考虑左子树
        rightCur = rightCur.left;
    }
    return true;
}
```

## 11. 二叉树的锯齿形层次遍历 [103]

题目来源：[103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

### 11.1. 题目描述

![image-20200819111819257](/pictures/image-20200819111819257.png)

### 11.2. 代码

在 [102] 题的基础上，改变在当前层中加入元素的顺序即可完成。

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Deque<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int depth = 0;
    while(!queue.isEmpty()){
        // 当前层列表
        List<Integer> level = new ArrayList<>();
        int levelNum = queue.size();
        for(int i = 0; i < levelNum; i++){
            TreeNode node = queue.remove();
            // 在当前层列表中加入元素（只需要改变这里）
            if(depth % 2 == 0){
                level.add(node.val);
            }else{
                level.add(0, node.val);
            }
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){queue.add(node.right);}
        }
        res.add(level);
        depth++;
    }
    return res;
}
```

通过本题加深了对层次遍历迭代解法的理解，代码中通过队列进行层次遍历，即整个遍历的顺序都是在队列的帮助下实现的，其中的 res、level 等都是为了输出结果的形式而定义的。本题依旧是层次遍历，只是在添加结果时，不同的层添加结果的顺序不同。

## 12. 从前序与中序遍历序列构造二叉树 [105]

题目来源：[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### 12.1. 题目描述

![image-20200821111825878](/pictures/image-20200821111825878.png)

### 12.2. 方法一：递归

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return helper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

private TreeNode helper(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd) {
    // pStart 表示先序的第一位索引
    // pEnd 表示先序的最后一位索引
    // 如果输入的前序序列为空，返回 null
    if(pEnd < pStart){return null;}

    int root = preorder[pStart];
    TreeNode node = new TreeNode(root);

    // 在中序遍历中找root，即分隔点
    int point = iStart;
    for(; point <= iEnd; point++){
        if(inorder[point] == root){
            break;
        }
    }
    // 左子树长度
    int leftLen = point - iStart;

    node.left = helper(preorder, pStart + 1, pStart + leftLen, inorder, iStart, point - 1);
    node.right = helper(preorder, pStart + leftLen + 1, pEnd, inorder, point + 1, iEnd);

    return node;
}
```

复杂度分析：

- 时间复杂度：O(N^2)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，在中序遍历中找到根结点在中序遍历中的位置，是与 N 相关的，这里不计算递归方法占用的时间。
- 空间复杂度：O(1)，这里不计算递归方法占用的空间。

### 12.3. 方法二：使用 HashMap 对递归进行优化

参考 [这里](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/).

上一方法中每执行一次 helper 都要在中序中寻找根节点，这里使用 HashMap 存储中序序列的索引与节点值，找根节点只需要 O(1)。

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    HashMap<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < inorder.length; i++){
        map.put(inorder[i], i);
    }
    return helper2(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, map);
}

private TreeNode helper2(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd, HashMap<Integer, Integer> map) {
    if(pEnd < pStart){return null;}

    int root = preorder[pStart];
    TreeNode node = new TreeNode(root);

    // 使用map找分隔点
    int point = map.get(root);

    int leftLen = point - iStart;

    node.left = helper2(preorder, pStart + 1, pStart + leftLen, inorder, iStart, point - 1, map);
    node.right = helper2(preorder, pStart + leftLen + 1, pEnd, inorder, point + 1, iEnd, map);

    return node;
}
```

- 时间复杂度：O(N)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，这里不计算递归方法占用的时间。
- 空间复杂度：O(N)，这里忽略递归方法占用的空间，因为是对数级别的，比 N 小。

## 13. 参考引用

1. [Wikipedia](https://zh.wikipedia.org/wiki/二叉树)
2. https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html
3. https://leetcode.wang/leetcode-102-Binary-Tree-Level-Order-Traversal.html
4. https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/