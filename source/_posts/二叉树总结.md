---
title: 二叉树总结
date: 2020-08-07 08:45:47
tags:
  - Algorithm
  - Java
  - 二叉树
categories: Algorithm
---

本文介绍了什么是二叉树，同时解决了部分LeetCode上二叉树相关的题目，这部分会持续更新。

## 1. 什么是二叉树？

[维基定义](https://zh.wikipedia.org/wiki/二叉树)：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。

二叉树的第 ``i`` 层至多拥有 2<sup>i-1</sup> 个节点；深度为 k 的二叉树至多总共有 2<sup>k</sup>-1 个节点（定义根节点所在深度 k<sub>0</sub>=0}），而总计拥有节点数符合的，称为 **满二叉树**；深度为 k 有 n 个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度 k 的满二叉树，序号为1到 n 的节点一对一对应时，称为 **完全二叉树**。对任何一棵非空的二叉树T，如果其叶片（终端节点）数为 n<sub>0</sub>，分支度为2的节点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1。

与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。

二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。

<!--more-->

## 2. 二叉树相关的题目列表

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
|  94  | [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) |        |
| 144  | [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) |        |
| 145  | [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) |        |
| 102  | [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) |        |
| 107  | [二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) |        |
| 104  | [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |        |
| 100  |   [相同的树](https://leetcode-cn.com/problems/same-tree/)    |        |
| 101  | [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) |  Hard  |
| 103  |                                                              |        |
| 105  |                                                              |        |
| 106  |                                                              |        |
|  98  |                                                              |        |

## 3. 二叉树的中序遍历 [94]

题目来源：[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 3.1. 题目描述

给定一个二叉树，返回它的中序 遍历。

示例:

```bash
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 3.2. 题目分析

分析参考 [这里](https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html).

中序遍历使用两种方法：递归和迭代。

### 3.3. 方法一：递归

时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}

private void helper(TreeNode node, List<Integer> res){
    if (node == null){return;}

    helper(node.left, res);
    res.add(node.val);
    helper(node.right, res);
}
```

### 3.4. 方法二：栈

时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。

利用栈模拟递归。递归压栈过程，就是保存现场，保存当前的变量。在方法一中，当前有用的变量就是 node，所以我们用栈把每一次的 node 保存起来。

```java
public List<Integer> inorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    // 程序中尽量避免使用Stack类，太古老，性能差，使用ArrayDeque代替
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()){
        // 节点不为空就一直压栈
        while (curr != null){
            stack.push(curr);
            // 考虑左子树
            curr = curr.left;
        }
        // 节点为空，就出栈
        curr = stack.pop();
        res.add(curr.val);
        // 考虑右子树
        curr = curr.right;
    }
    return res;
}
```

## 4. 二叉树的前序遍历 [144]

题目来源：[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 4.1. 题目描述

给定一个二叉树，返回它的 前序 遍历。

示例:

```bash
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 4.2. 题目分析

中序遍历的迭代法也使用栈实现。

### 4.3. 方法一：递归

```java
public List<Integer> preorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}

private void helper(TreeNode node, List<Integer> res){
    if (node == null){return;}

    res.add(node.val);
    helper(node.left, res);
    helper(node.right, res);
}
```

### 4.4. 方法二：栈

与中序遍历的迭代方法相比，前序遍历只需要将访问的位置改到根节点处即可，其他代码不变。

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()){
        while (curr != null){
            // 在此处访问节点
            res.add(curr.val);
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.poll();
        curr = curr.right;
    }
    return res;
}
```

## 5. 二叉树的后序遍历 [145]

题目来源：[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 5.1. 题目描述

给定一个二叉树，返回它的 后序 遍历。

示例:

```bash
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 5.2. 方法一：递归

```java
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    helper(root, res);
    return res;
}

private void helper(TreeNode node, List<Integer> res){
    if (node == null){return;}

    helper(node.left, res);
    helper(node.right, res);
    res.add(node.val);
}
```

### 5.3. 方法二：栈

相比于前序、中序的栈解法，后序遍历的栈解法会难一些。

原因在于，当遍历完某个根节点的左子树，回到根节点时，中序、先序可以把当前根节点从栈中弹出，然后转到右子树。举例如下：

```bash
     1
    / \
   2   3
  / \
 4   5
```

当遍历完 2,4,5 时，回到 1 之后就可以把 1 弹出，然后通过 1 到达右子树继续遍历。

而对于后序遍历，当我们到达 1 时，并不能立即把 1 弹出，因为遍历完右子树，还需要将根节点加入到 res 中。

因此，我们就需要判断是从左子树到的根节点，还是从右子树到的根节点。

如果是从左子树到的根节点，此时应该转到右子树。如果从右子树到的根节点，那么就可以弹出当前节点，并存储到 res 中。

当然，如果从左子树到的根节点，此时右子树为 null, 也需要把根节点弹出，并加入到 res 中。

基于上述分析，我们可以写出代码：

```java
public List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;
    // 记录上一个遍历的节点
    TreeNode pre = null;
    while (curr != null || !stack.isEmpty()){
        while (curr != null){
            stack.push(curr);
            curr = curr.left;
        }
        // 获取当前根节点
        TreeNode temp = stack.peek();
        // 是否变到右子树
        if(temp.right != null && temp.right != pre){
            curr = temp.right;
        }else{
            res.add(temp.val);
            // 记录上一个遍历的节点
            pre = temp;
            stack.pop();
        }
    }
    return res;
}
```

## 6. 二叉树的层序遍历 [102]

题目来源：[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

### 6.1. 题目描述

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],

```bash
	3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```bash
[
  [3],
  [9,20],
  [15,7]
]
```

### 6.2. 方法一：递归（DFS）

由于本题对于层序遍历的结果要求为 ``List<List<Integer>>``, 要把每一层的元素放在一个单独的列表中，因此在递归时需要传入当前层数，如果是新的一层，创建一个新的 ``List`` , 存储这一层的元素。

```java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null){return res;}
    helper(root, 0);
    return res;
}

private void helper(TreeNode node, Integer level){
    if(res.size() == level){
        res.add(new ArrayList<>());
    }
    res.get(level).add(node.val);
    if(node.left != null){
        helper(node.left, level + 1);
    }
    if(node.right != null){
        helper(node.right, level + 1);
    }
}
```

### 6.3. 方法二：队列（BFS）

依旧是本题对于返回结果的要求，每一层需要单独处理。

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()){
        // 当前层列表
        List<Integer> level = new ArrayList<>();

        // 当前队列中的元素个数，即就是当前层的节点数
        int levelNum = queue.size();
        // levelNum 必须在外面定义，因为 queue 的大小在不停的变化
        for(int i = 0; i < levelNum; i++){
            // 移除队列第一个元素
            TreeNode node = queue.remove();
            level.add(node.val);
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){queue.add(node.right);}
        }
        res.add(level);
    }
    return res;
}
```

## 7. 二叉树的层次遍历 II [107]

题目来源：[107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

### 7.1. 题目描述

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

```bash
	3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```bash
[
  [15,7],
  [9,20],
  [3]
]
```

### 7.2. 方法一：递归

本题的结果是上一题结果的反序，只需要在上一题添加列表时，在表头插入，以此得到反序序列即可。如下代码，改变三处：

```java
// 使用链表存储，在表头插入效率更高
LinkedList<List<Integer>> res = new LinkedList<>();

public List<List<Integer>> levelOrderBottom(TreeNode root) {
    if(root == null){return res;}
    helper(root, 0);
    return res;
}

private void helper(TreeNode node, Integer level){
    if(res.size() == level){
        // 在链表表头插入，得到反序序列
        res.addFirst(new ArrayList<>());
    }
    // 插入当前值，注意下标
    res.get(res.size() - level - 1).add(node.val);

    if(node.left != null){
        helper(node.left, level + 1);
    }
    if(node.right != null){
        helper(node.right, level + 1);
    }
}
```

### 7.3. 方法二：队列

与上一题区别：使用链表存储，插入时从表头插入，得到反序序列。

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    // 使用链表，在表头插入效率更高
    LinkedList<List<Integer>> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()){
        List<Integer> level = new ArrayList<>();
        int levelNum = queue.size();
        for(int i = 0; i < levelNum; i++){
            TreeNode node = queue.remove();
            level.add(node.val);
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){queue.add(node.right);}
        }
        // 在表头插入，得到反序结果
        res.addFirst(level);
    }
    return res;
}
```

## 8. 二叉树的最大深度 [104]

题目来源：[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

### 8.1.. 题目描述

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    	3
       / \
      9  20
        /  \
       15   7

返回它的最大深度 3 。

### 8.2. 方法一：递归（DFS）

```java
public int maxDepth(TreeNode root) {
    if(root == null){return 0;}
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

### 8.3. 方法二：层次遍历（BFS）

```java
public int maxDepth(TreeNode root) {
    if(root == null){return 0;}
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int level = 0;
    while (!queue.isEmpty()){
        level++;
        int size = queue.size();
        for(int i = 0; i < size; i++){
            TreeNode node = queue.remove();
            if(node.left != null){queue.add(node.left);}
            if(node.right != null){ queue.add(node.right);}
        }
    }
    return level;
}
```

## 9. 相同的树 [100]

题目来源：[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

### 9.1. 题目描述

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

```bash
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例 2:

```bash
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```


示例 3:

```bash
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

### 9.2. 代码

思路：对两颗树同时进行遍历比较，这里使用的是中序遍历。

```java
public boolean isSameTree(TreeNode p, TreeNode q){
    if(p == null && q == null){
        return true;
    }
    if(p != null && q != null && p.val == q.val){
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
    return false;
}
```

## 10. 对称二叉树 [101]

题目来源：[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

### 10.1. 题目描述

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    	1
       / \
      2   2
     / \ / \
    3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    	1
       / \
      2   2
       \   \
       3    3

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

### 10.2. 方法一：递归

不是简单的比较左右就行，注意这道题是镜像对称的。这里的递归是基于先序遍历的，先看根节点，再判断左右节点，再判断左右节点的子节点是否为镜像对称。

其实就是类似于 DFS 的先序遍历。不同之处是对于 left 子树是正常的先序遍历 根节点 -> 左子树 -> 右子树 的顺序，对于 right 子树的话是 根节点 -> 右子树 -> 左子树 的顺序。

```java
public boolean isSymmetric(TreeNode root){
    if(root == null){return true;}
    return isMirror(root.left, root.right);
}

public boolean isMirror(TreeNode p, TreeNode q){
    if(p == null && q == null){return true;}
    if(p == null || q == null){return false;}
    if(p.val == q.val){
        return isMirror(p.left, q.right) && isMirror(p.right, q.left);
    }
    return false;
}
```

### 10.3. 方法二：迭代（栈）

参考：[这里](https://leetcode.wang/leetcode-101-Symmetric-Tree.html#解法二-dfs-栈).

把方法一的先序遍历，使用栈将递归改为迭代。使用两个栈分别存储左右字数的序列，出栈时比较。

```java
public boolean isSymmetric(TreeNode root){
    if(root == null){return true;}
    Deque<TreeNode> leftStack = new ArrayDeque<>();
    Deque<TreeNode> rightStack = new ArrayDeque<>();
    TreeNode leftCur = root.left;
    TreeNode rightCur = root.right;
    while (leftCur != null || rightCur != null || !leftStack.isEmpty() || !rightStack.isEmpty()){
        while (leftCur != null){
            leftStack.push(leftCur);
            // 考虑左子树
            leftCur = leftCur.left;
        }
        while (rightCur != null){
            rightStack.push(rightCur);
            // 考虑右子树
            rightCur = rightCur.right;
        }
        // 长度不同，就返回
        if(leftStack.size() != rightStack.size()){
            return false;
        }
        // 出栈
        leftCur = leftStack.poll();
        rightCur = rightStack.poll();
        if(leftCur.val != rightCur.val){
            return false;
        }
        // 考虑右子树
        leftCur = leftCur.right;
        // 考虑左子树
        rightCur = rightCur.left;
    }
    return true;
}
```



## 11. 参考引用

1. [Wikipedia](https://zh.wikipedia.org/wiki/二叉树)
2. https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html
3. https://leetcode.wang/leetcode-102-Binary-Tree-Level-Order-Traversal.html