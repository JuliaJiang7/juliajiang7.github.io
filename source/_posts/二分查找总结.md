---
title: 二分查找总结
date: 2020-08-06 10:06:51
tags:
  - Algorithm
  - Java
  - 二分查找
categories: Algorithm
---

本文介绍了二分查找，主要总结了三种二分查找的框架，分别是：基本的二分查找、查找左侧边界、查找右侧边界。同时，解决了部分LeetCode上二分查找相关的题目，这部分会持续更新~

## 1. 什么是二分查找？

[二分查找](https://zh.wikipedia.org/wiki/二分搜尋演算法)：在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

二分查找算法在情况下的复杂度是对数时间，进行O(log n)次比较操作。二分查找算法使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。

<!--more-->

## 2. 基本的二分查找：二分查找 [704]

题目来源：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

### 2.1. 题目描述

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例 1:**

```bash
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```bash
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 2.2. 题目分析

基本二分查找。

### 2.3. 代码

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else{
            right = mid - 1;
        }
    }
    return -1;
}
```

## 3. 在排序数组中查找元素的第一个和最后一个位置 [34]

题目来源：[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 3.1. 题目描述

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

```bash
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```


示例 2:

```bash
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

### 3.2. 题目分析

本题求给出有序序列（有重复元素）的target左侧、右侧边界，这需要在基本的二分查找代码上做一些修改。

### 3.3. 代码

```java
public int[] searchRange(int[] nums, int target) {
    int[] res = new int[2];
    res[0] = leftBound(nums, target);
    res[1] = rightBound(nums, target);
    return res;
}

/**
     * 找左侧边界
     * 用 left 保存找到的左侧边界
     * @param nums
     * @param target
     * @return
     */
private int leftBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        }else if(nums[mid] < target){
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        }else if(nums[mid] == target){
            // 不返回，收缩右侧边界，限制左侧边界left的取值范围
            right = mid - 1;
        }
    }
    if(left == nums.length || nums[left] != target){
        return -1;
    }
    return left;
}

/**
     * 找右侧边界
     * 用 right 保存找到的右侧边界
     * @param nums
     * @param target
     * @return
     */
private int rightBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] == target){
            // 改变一：收缩左侧边界，限制右侧边界right的取值范围
            left = mid + 1;
        }
    }
    // 改变二：检查right的越界情况
    if(right < 0 || nums[right] != target){
        return -1;
    }
    return right;
}
```

## 4. 二分查找总结

可以发现，二分查找的思路很简单，但是对于 mid 是加一还是减一，while 中是 <= 还是 = 是比较容易混的。上面两题中，我们都把搜索区间定义为左右为闭，这样便于统一记忆。当然，也有代码定义为左闭右开，left 和 right的更新又是另一种套路了，这里不做讨论。下面，基于上面两题的做法，对二分查找三种不同用法做出总结：

### 4.1. 基本的二分查找

基本的二分查找框架，即序列元素不重复，查找 target，代码如下：

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            // 找到target，直接返回
            return mid;
        }else if(nums[mid] < target){
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        }else{
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        }
    }
    // 直接返回
    return -1;
}
```

### 4.2. 查找左侧边界

序列元素可能重复，查找 target 左边界，在基本代码的基础上，做了三处修改，代码如下：

代码理解：在查找左边界时，使用 left 存找到的左边界，如果 ``nums[mid] < target`` ，left 向后移一位，其他情况下 left 均不动，则最终 left 的取值只能有三种情况：1.第一个等于 target 的元素；2. 大于 target 的元素（因为序列中没有 target）；3. left 越界（因为序列中的所有元素均小于 target）。这也是为什么使用 left 存储左边界并最终返回的原因。right 存能取到的左边界的最大值，不断的收缩 left 的取值范围，直到 ``left > right`` 结束循环。

```java
private int leftBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] == target){
            // 修改一：不返回，收缩右侧边界，限制左侧边界left的取值范围
            right = mid - 1;
        }
    }
    // 修改二：检查left的越界情况
    if(left == nums.length || nums[left] != target){
        return -1;
    }
    // 修改三：返回left
    return left;
}
```

### 4.3. 查找右侧边界

序列元素可能重复，查找 target 右边界，在基本代码的基础上，做了三处修改，代码如下：

代码理解：在查找右边界时，用 right 存储找到的右边界。当 ``nums[mid] > target`` 时，更新 right 的值，right 前移一位，其他情况下 right 值均不变。因此，最终 while 循环结束后，right 的取值有三种：1. 最后一个等于 target 的元素，即右边界；2. 小于target 的元素（因为序列中没有 target 元素）；3. target 越界（因为序列中所有元素均大于 target）。用 left 存储右边界能取到的最小值，while 中不断更新 left 值，缩小右边界的取值范围，直到 ``left > right`` 结束。

```java
private int rightBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] == target){
            // 修改一：不返回，收缩左侧边界，限制右侧边界left的取值范围
            left = mid + 1;
        }
    }
    // 修改二：检查right的越界情况
    if(right < 0 || nums[right] != target){
        return -1;
    }
    // 修改三：返回right
    return right;
}
```

## 5. 使用二分查找的题目列表

本文中使用二分查找解决的 LeetCode 题目列表如下，持续更新中~

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
| 704  | [二分查找](https://leetcode-cn.com/problems/binary-search/)  |        |
|  34  | [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) |        |
|  35  | [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) |        |
|  33  | [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) |  Hard  |
|  81  | [搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/) |  Hard  |
| 300  |                                                              |        |
|  74  |                                                              |        |

## 6. 搜索插入的位置 [35]

题目来源：[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

### 6.1. 题目描述

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

```bash
输入: [1,3,5,6], 5
输出: 2
```

示例 2:

```bash
输入: [1,3,5,6], 2
输出: 1
```


示例 3:

```bash
输入: [1,3,5,6], 7
输出: 4
```


示例 4:

```bash
输入: [1,3,5,6], 0
输出: 0
```

### 6.2. 题目分析

基本的二分查找框架，返回 left 即题目要求的返回值。

### 6.3. 代码

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else{
            right = mid - 1;
        }
    }
    return left;
}
```

## 7. 搜索旋转排序数组 [33]

题目来源：[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 7.1. 题目描述

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```bash
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```


示例 2:

```bash
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 7.2. 题目分析

本题分析参考：[这里](https://leetcode.wang/leetCode-33-Search-in-Rotated-Sorted-Array.html#解法三).

可以发现，数组从任意位置分成两个序列后，至少有一半是有序的。

基于这个事实，当 mid 把数组分成两段后，可以先找到哪一段是有序的（比较两端端点即可），然后看 target 在不在这一段，如果在，丢弃另一段；如果不在，丢弃这一段。

为什么必须先找到有序的一端，然后找 target？因为如果想要在一段无序序列中找 target，无法实现。只能先在有序序列中找，以此来缩小搜索范围。

### 7.3. 代码

注意下面对于 ``nums[left] <= nums[mid]`` 的分析。

```java
    public int search(int[] nums, int target) {
        int len = nums.length;
        if(len == 0){return -1;}
        int left = 0, right = len - 1;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                return mid;
            }

            // 左半段有序
            // 等于的情况出现在：left = mid 时，即left和mid重合，此时只剩下两个元素
            // 这个等号不能去掉，因为mid求值时取整，两个元素时mid只会和left重合
            // 如果去掉等号，计算right = mid - 1时，right会直接越界
            if(nums[left] <= nums[mid]){
                // target在左半段
                if(nums[left] <= target && target < nums[mid]){
                    right = mid - 1;
                // target在右半段
                }else {
                    left = mid + 1;
                }
            // 右半段有序
            }else{
                // target 在右半段
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                // target 在左半段
                }else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
```

### 7.4. 参考 [81] 代码

也可以在 ``nums[left] <= nums[mid]`` 时不用考虑那么多，采用和下题一样的思路，更简单。多加一个判断，当``nums[left] == nums[mid]`` 时，直接跳过 left。

```java
public int search(int[] nums, int target) {
    int len = nums.length;
    if(len == 0){return -1;}
    int left = 0, right = len - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid;
        }

        // 左半段有序
        if(nums[left] < nums[mid]){
            // target在左半段
            if(nums[left] <= target && target < nums[mid]){
                right = mid - 1;
                // target在右半段
            }else {
                left = mid + 1;
            }
            // left 和 mid 重合，直接跳过left
        }else if(nums[left] == nums[mid]){
            left++;
            // 右半段有序
        }else{
            // target 在右半段
            if(nums[mid] < target && target <= nums[right]){
                left = mid + 1;
                // target 在左半段
            }else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```



## 8. 搜索旋转排序数组 II [81]

题目来源：[81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

### 8.1. 题目描述

![image-20200815105842768](/pictures/image-20200815105842768.png)

### 8.2. 题目分析

分析参考：[这里](https://leetcode.wang/leetCode-81-Search-in-Rotated-Sorted-ArrayII.html).

如果使用 [33] 题的解法一，如果不加修改，直接放到 leetcode 上跑，发现 nums = [ 1, 3, 1, 1, 1 ] ，target = 3，返回了 false，当然是不对的了。原因就出现在了，我们在判断哪段有序的时候，当 nums [ left ] <= nums [ mid ] 是认为左半段有序。而由于这道题出现了重复数字，此时的 nums [ left ] = 1, nums [ mid ] = 1，但此时左半段 [ 1, 3, 1 ] 并不是有序的，所以造成我们的算法错误。

所以 nums[left] == nums[mid] 需要我们单独考虑了。操作也很简单，参考[这里](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/28218/My-8ms-C%2B%2B-solution-(o(logn)-on-average-o(n)-worst-case)，当相等的时候，我们只需要让 left++ 就够了。

改后的代码也适用于 [33] 题。

### 8.3. 代码

```java
public boolean search(int[] nums, int target) {
    int len = nums.length;
    if(len == 0){return false;}
    int left = 0, right = len - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return true;
        }

        // 左半段有序
        if(nums[left] < nums[mid]){
            // target在左半段
            if(nums[left] <= target && target < nums[mid]){
                right = mid - 1;
                // target在右半段
            }else {
                left = mid + 1;
            }
            // 相等，left++
        }else if(nums[left] == nums[mid]){
            left++;

            // 右半段有序
        } else{
            // target 在右半段
            if(nums[mid] < target && target <= nums[right]){
                left = mid + 1;
                // target 在左半段
            }else {
                right = mid - 1;
            }
        }
    }
    return false;
}
```

## 9. 参考引用

1. [Wikipedia](https://zh.wikipedia.org/wiki/二分搜尋演算法)
2. https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie
3. https://leetcode.wang/leetCode-81-Search-in-Rotated-Sorted-ArrayII.html