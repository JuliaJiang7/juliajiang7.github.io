---
title: 二分查找总结
date: 2020-08-06 10:06:51
tags:
  - Algorithm
  - Java
  - 二分查找
categories: Algorithm
---

本文介绍了二分查找，主要总结了三种二分查找的框架，分别是：基本的二分查找、查找左侧边界、查找右侧边界。同时，解决了部分LeetCode上二分查找相关的题目，这部分会持续更新~

## 1. 什么是二分查找？

[二分查找](https://zh.wikipedia.org/wiki/二分搜尋演算法)：在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

二分查找算法在情况下的复杂度是对数时间，进行O(log n)次比较操作。二分查找算法使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。

<!--more-->

## 2. 基本的二分查找：二分查找 [704]

题目来源：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

### 2.1. 题目描述

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例 1:**

```bash
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```bash
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 2.2. 题目分析

基本二分查找。

### 2.3. 代码

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else{
            right = mid - 1;
        }
    }
    return -1;
}
```

## 3. 在排序数组中查找元素的第一个和最后一个位置 [34]

题目来源：[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 3.1. 题目描述

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

```bash
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```


示例 2:

```bash
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

### 3.2. 题目分析

本题求给出有序序列（有重复元素）的target左侧、右侧边界，这需要在基本的二分查找代码上做一些修改。

### 3.3. 代码

```java
public int[] searchRange(int[] nums, int target) {
    int[] res = new int[2];
    res[0] = leftBound(nums, target);
    res[1] = rightBound(nums, target);
    return res;
}

/**
     * 找左侧边界
     * 用 left 保存找到的左侧边界
     * @param nums
     * @param target
     * @return
     */
private int leftBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        }else if(nums[mid] < target){
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        }else if(nums[mid] == target){
            // 不返回，收缩右侧边界，限制左侧边界left的取值范围
            right = mid - 1;
        }
    }
    if(left == nums.length || nums[left] != target){
        return -1;
    }
    return left;
}

/**
     * 找右侧边界
     * 用 right 保存找到的右侧边界
     * @param nums
     * @param target
     * @return
     */
private int rightBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] == target){
            // 改变一：收缩左侧边界，限制右侧边界right的取值范围
            left = mid + 1;
        }
    }
    // 改变二：检查right的越界情况
    if(right < 0 || nums[right] != target){
        return -1;
    }
    return right;
}
```

## 4. 二分查找总结

可以发现，二分查找的思路很简单，但是对于 mid 是加一还是减一，while 中是 <= 还是 = 是比较容易混的。上面两题中，我们都把搜索区间定义为左右为闭，这样便于统一记忆。当然，也有代码定义为左闭右开，left 和 right的更新又是另一种套路了，这里不做讨论。下面，基于上面两题的做法，对二分查找三种不同用法做出总结：

### 4.1. 基本的二分查找

基本的二分查找框架，即序列元素不重复，查找 target，代码如下：

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] == target){
            // 找到target，直接返回
            return mid;
        }else if(nums[mid] < target){
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        }else{
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        }
    }
    // 直接返回
    return -1;
}
```

### 4.2. 查找左侧边界

序列元素可能重复，查找 target 左边界，在基本代码的基础上，做了三处修改，代码如下：

代码理解：在查找左边界时，使用 left 存找到的左边界，如果 ``nums[mid] < target`` ，left 向后移一位，其他情况下 left 均不动，则最终 left 的取值只能有三种情况：1.第一个等于 target 的元素；2. 大于 target 的元素（因为序列中没有 target）；3. left 越界（因为序列中的所有元素均小于 target）。这也是为什么使用 left 存储左边界并最终返回的原因。right 存能取到的左边界的最大值，不断的收缩 left 的取值范围，直到 ``left > right`` 结束循环。

```java
private int leftBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] == target){
            // 修改一：不返回，收缩右侧边界，限制左侧边界left的取值范围
            right = mid - 1;
        }
    }
    // 修改二：检查left的越界情况
    if(left == nums.length || nums[left] != target){
        return -1;
    }
    // 修改三：返回left
    return left;
}
```

### 4.3. 查找右侧边界

序列元素可能重复，查找 target 右边界，在基本代码的基础上，做了三处修改，代码如下：

代码理解：在查找右边界时，用 right 存储找到的右边界。当 ``nums[mid] > target`` 时，更新 right 的值，right 前移一位，其他情况下 right 值均不变。因此，最终 while 循环结束后，right 的取值有三种：1. 最后一个等于 target 的元素，即右边界；2. 小于target 的元素（因为序列中没有 target 元素）；3. target 越界（因为序列中所有元素均大于 target）。用 left 存储右边界能取到的最小值，while 中不断更新 left 值，缩小右边界的取值范围，直到 ``left > right`` 结束。

```java
private int rightBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }else if(nums[mid] == target){
            // 修改一：不返回，收缩左侧边界，限制右侧边界left的取值范围
            left = mid + 1;
        }
    }
    // 修改二：检查right的越界情况
    if(right < 0 || nums[right] != target){
        return -1;
    }
    // 修改三：返回right
    return right;
}
```

## 5. 使用二分查找的题目列表

本文中使用二分查找解决的 LeetCode 题目列表如下，持续更新中~

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
| 704  | [二分查找](https://leetcode-cn.com/problems/binary-search/)  |        |
|  34  | [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) |        |
|  35  |                                                              |        |
|  33  |                                                              |        |
| 300  |                                                              |        |
|  74  |                                                              |        |

## 6. 参考引用

1. [Wikipedia](https://zh.wikipedia.org/wiki/二分搜尋演算法)
2. https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie