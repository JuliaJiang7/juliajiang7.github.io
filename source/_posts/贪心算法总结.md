---
title: 贪心算法总结
date: 2020-09-11 10:30:29
tags:
  - Algorithm
  - Java
  - 贪心算法
categories: Algorithm
---

本文主要介绍了贪心算法以及 LeetCode 的相关题目。

## 1. 什么是贪心算法？

[维基定义](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)：（英语：greedy algorithm），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在 [旅行推销员问题](https://zh.wikipedia.org/wiki/旅行推销员问题) 中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

**贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。**

<!--more-->

参考 [这里](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti) 给出对于贪心算法的理解：

什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。

比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决。

## 2. 区间调度问题

参考 [这里](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti) .

### 2.1. 问题描述

首先解决一个很经典的贪心算法问题：区间调度问题（Interval Scheduling）。给出形如 ``[start, end]`` 的闭区间，设计一个算法，求出这些区间 **最多有几个互不相交的区间** 。

```java
int intervalSchedule(int[][] intvs) {}
```

举个例子，`intvs = [[1,3], [2,4], [3,6]]`，这些区间最多有 2 个区间互不相交，即 `[[1,3], [3,6]]`，你的算法应该返回 2。注意边界相同并不算相交。

这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 `[start, end]` 表示开始和结束的时间，请问你今天**最多能参加几个活动呢？**显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。

### 2.2. 题目分析

这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：

也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。

正确的思路其实很简单，可以分为以下三步：

1. 从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中**结束最早的**（end 最小）。
2. 把所有与 x 区间相交的区间从区间集合 intvs 中删除。
3. 重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。

把这个思路实现成算法的话，可以按每个区间的 `end` 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多。如下图所示：

<img src="/pictures/image-20200912154659563.png" alt="image-20200912154659563" style="zoom:67%;" />

前三个区间属于相交区间，count 不用 +1，第四个区间就是一个新的不相交区间，访问到第四个区间时，count 需要+1，并且更新 end。

这种思路的贪心算法体现在：在上图中，第一个区间和第二个区间属于相交区间，肯定是二选一的，如何选择呢？当然是选择第一个。因为第一个给后面区间的选择留有更大的空间，这就属于当前情况下的最优选择，之后的选择就在这个选择的基础上，进行选择。

### 2.3. 代码

参考博客的代码，做了一些修改，这样可以和后面两个题统一。

```java
public int intervalSchedule(int[][] intvs) {
    if(intvs.length == 0){return 0;}
    // 按 end 排序
    Arrays.sort(intvs, new Comparator<int[]>() {
        @Override
        public int compare(int[] a, int[] b) {
            return a[1] - b[1];
        }
    });

    // 初始时，至少有一个区间不相交
    int count = 1;
    int end = intvs[0][1];

    for(int i = 1; i < intvs.length; i++){
        if(intvs[i][0] >= end){
            count++;
            end = intvs[i][1];
        }
    }

    return count;
}
```

## 3. 无重叠区间 [435]

题目来源：[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

### 3.1. 题目描述

![image-20200912101636226](/pictures/image-20200912101636226.png)

### 3.2. 方法一：区间调度算法（推荐）

使用本文第 2 小节的区间调度问题的思路即可。上文中，区间调度问题求的是最多不相交的区间个数，这里求移除几个区间后，区间互不重叠，即就是返回 ``总的区间数 - 不重叠的区间数`` 。

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if(intervals.length == 0){return 0;}
    Arrays.sort(intervals, new Comparator<int[]>() {
        @Override
        public int compare(int[] a, int[] b) {
            return a[1] - b[1];
        }
    });
    // 互补重叠的区间数量（能留下的区间数量），初值为 1
    int count = 1;
    int end = intervals[0][1];
    for(int i = 1; i < intervals.length; i++){
        if(intervals[i][0] >= end){
            end = intervals[i][1];
            count++;
        }
    }
    return intervals.length - count;
}
```

### 3.2. 方法二：从起点的贪心算法

参考 [这里](https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode/) .

方法一是从终点的贪心算法。这里按照起点对区间进行排序。当按照起点先后顺序考虑区间的时候。我们利用一个 prev 指针追踪刚刚添加到最终列表中的区间。遍历的时候，可能遇到图中的三种情况：

![image-20200912104507992](/pictures/image-20200912104507992.png)

- 情况一：当前考虑的两个区间不重叠。在这种情况下，不移除任何区间，将 prev*p**r**e**v* 赋值为后面的区间，移除区间数量不变。
- 情况二：两个区间重叠，后一个区间的终点在前一个终点之前，即前一个区间包含后一个区间。显然，前一个区间的长度更小，会给后面留下更多空间，因此，prev 更新为当前区间，移除区间数量 +1.
- 情况三：两个区间重叠，后一个区间的终点在前一个终点之后，这种情况下，我们用贪心策略处理，直接移除后一个区间。（官方解释没看懂...）。我的理解是：这里如果移除前一个区间，会留出 A 的额外空间，但这部分空间是用不到的，不是当前的最优解；但如果移除后一个空间，会留出 B 的额外空间，给后面的区间留下了更多的空间。

最终代码如下：

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if(intervals.length == 0){return 0;}
    // 按照 start 排序
    Arrays.sort(intervals, new Comparator<int[]>() {
        @Override
        public int compare(int[] a, int[] b) {
            return a[0] - b[0];
        }
    });
    // prev 指针追踪刚刚添加到最终列表中的区间
    int prev = 0;
    // 需要移除的数量
    int count = 0;
    for(int i = 1; i < intervals.length; i++){
        if(intervals[prev][1] > intervals[i][0]){
            // case 2
            if(intervals[prev][1] > intervals[i][1]){
                prev = i;
            }
            // case 3
            count++;
        }else{
            // case 1
            prev = i;
        }
    }
    return count;
}
```

## 4. 用最少数量的箭引爆气球 [452]

题目来源：[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

### 4.1. 题目描述

![image-20200912114154510](/pictures/image-20200912114154510.png)

### 4.2. 方法一：区间调度算法

参考 [这里]。

仔细思考后，这个问题和区间调度算法一模一样。如果最多有 n 个不重叠的区间，那么就至少需要 n 个箭头穿透所有区间，如下图所示：

<img src="/pictures/image-20200912160847665.png" alt="image-20200912160847665" style="zoom: 67%;" />

只是有一点不一样，在 `intervalSchedule` 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：

<img src="/pictures/image-20200912161028162.png" alt="image-20200912161028162" style="zoom:67%;" />

所以只需要将区间调度算法稍作修改，就可以得到题目代码：

```java
public int findMinArrowShots(int[][] points) {
    if(points.length == 0){return 0;}
    // 按照 end 排序
    Arrays.sort(points, new Comparator<int[]>() {
        @Override
        public int compare(int[] a, int[] b) {
            return a[1] - b[1];
        }
    });
    // 互不重叠的区间数量（射箭数量，选中第一个区间时，肯定会射一箭）
    int count = 1;
    int end = points[0][1];

    for(int i = 1; i < points.length; i++){
        // 注意：这里把首尾相接的视为相交，去掉等号
        if(points[i][0] > end){
            end = points[i][1];
            count++;
        }
    }
    return count;
}
```

## 5. 使用贪心算法的题目列表

本文中使用贪心算法解决的 LeetCode 题目列表如下，持续更新中~

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
| 435  | [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/) |  Hard  |
| 452  | [用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/) |  Hard  |
| 122  | [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) |  Hard  |

## 6. 买卖股票的最佳时机 II [122]

题目来源：[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

### 6.1. 题目描述

![image-20200911103413418](/pictures/image-20200911103413418.png)

### 6.2. 贪心算法

参考 [这里](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/) 的方法二。

这道题使用贪心算法的流程是这样的：从第 i 天（这里 i >= 1）开始，与第 i - 1 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。下面对这个算法进行几点说明：

1. 该算法仅可以用于计算，但计算的过程并不是真正交易的过程，但可以用贪心算法计算题目要求的最大利润。下面说明这个等价性：以 [1, 2, 3, 4] 为例，这 4 天的股价依次上升，按照贪心算法，得到的最大利润是：

   ```java
   res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])
       =  prices[3] - prices[0]
   ```

   仔细观察上面的式子，按照贪心算法，在索引为 1、2、3 的这三天，我们做的操作应该是买进昨天的，卖出今天的，虽然这种操作题目并不允许，但是它等价于：“在索引为 0 的那一天买入，在索引为 3 的那一天卖出”。

2. 解释一下，它为什么叫做贪心算法？

   “贪心算法” 在每一步总是做出在当前看来最好的选择。

   因此，

   - “贪心算法” 和 “动态规划”、“回溯搜索” 算法一样，完成一件事情，是分步决策的；
   - “贪心算法” 在每一步总是做出在当前看来最好的选择，我是这样理解 “最好” 这两个字的意思：
     - “最好” 的意思往往根据题目而来，可能是 “最小”，也可能是 “最大”；

   - 贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。
   - 这道题 “贪心” 的地方在于，对于 “今天的股价 - 昨天的股价”，得到的结果有 3 种可能：（1）正数（2）0（3）负数。**贪心算法的决策是：只加正数** 。

最终代码如下：

```java
public int maxProfit(int[] prices) {
    int res = 0;
    int len = prices.length;
    for(int i = 0; i < len - 1; i++){
        int diff = prices[i + 1] - prices[i];
        if(diff > 0){
            res += diff;
        }
    }
    return res;
}
```

## 7. 参考引用

1. [Wikipedia](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)
2. https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti
3. https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/

