---
title: 生产者消费者模式+阻塞队列实现异步导出
date: 2021-02-23 20:49:20
tags:
  - Java
categories: Java
top: true
typora-copy-images-to: ..\pictures
---

这是我在实习期间实现的一个小功能，断断续续遇到了一些问题，也做了一些优化，收获很大。整体思路简单做了一个demo: [export-demo](https://github.com/JuliaJiang7/export-demo)，下文是使用具体解决方案的原因和步骤等等，于我而言是一个梳理和总结，如果也能给你提供一种解决问题的思路，那可真是太好了！

## 1. 具体需求

简单来说就是：在页面输入查询条件，点击导出，将数据导出为Excel文件。这里导出的Excel文件，我们会上传到文件服务器，并将这个导出请求信息和结果存储在请求管理表，在请求管理页面进行展示和下载。

总结下来，导出过程是：用户输入查询条件 -> 点击导出 -> 生成Excel -> 上传文件服务器 -> 存储文件url等信息到请求管理表 -> 请求管理页面可显示和下载。

<!--more-->

## 2. 初步方案

这个场景非常适合用 **生产者-消费者模型** 来解决。为什么呢？

导出一个文件是比较费时的，特别是在导出大量数据时，用户不可能一直处于等待这个导出的状态，服务器也不可能在这段时间只来处理这一个请求，因此就需要 **异步处理** 这个请求，如何实现异步呢？这里我们将项目逻辑上分为两个模块：业务模块和任务模块，两者都单独部署和启动。在业务模块抛出请求后直接返回，而在任务模块进行真正地导出操作。这种异步处理方式就是典型的生产者-消费者。

生产者-消费者模型的实现方式有很多种，可以参考：[Java实现生产者和消费者的5种方式](https://juejin.cn/post/6844903486895865864)。这里我们采用阻塞队列，并将这个阻塞队列存储在 redis 中，这样两个独立部署的模块也可以通信。

## 3. 痛点分析

那么对于导出文件，存在哪些痛点呢？

1. 当单个用户导出大量数据时，可能造成OOM。解决办法：分页导出，每次查询1000条数据填充Excel。
2. 当多个用户导出数据时，可能造成OOM。解决办法：生产者-消费者模型+阻塞队列。（啊这个OOM还是不太理解）
3. 导出文件时间长。解决办法：多线程导出，当查询数据大于1000条时每次启5个线程来查询数据，后填充到Excel中。

## 4. 时序图

<img src="/pictures/导出时序图.jpg"/>

## 5. 类图

<img src="/pictures/导出类图.jpg"/>

## 6. 为什么这么设计？

1. **[模版模式](https://www.runoob.com/design-pattern/template-pattern.html)**：很多个页面有导出，那每一个导出都单独写一个Handler方法吗？是的...我的第一版代码就是这么写的..这样的代码很明显有很多问题，比如相同的代码要写很多遍，当然这里面有几个小地方不一样，比如查询数据、返回对象等，这样就导致**可维护性**差，比如后期导出的流程有一些改变，那么就需要修改很多类；另外，如果需要再增加一个导出，同样的代码还需要再写一遍，即**可扩展性**很差。
   回过头来，再看看这个场景，其实非常适合使用模版模式优化。使用一个抽象模版类定义整个导出的流程，在其中定义公共的方法，比如更新请求管理表、发送消息这类功能，每种具体的导出的不同部分，写成抽象方法，在子类中实现，比如导出数据总数、分页查询数据等。
2. **QueueInfo接口**：定义阻塞队列的名称，有几个阻塞队列，就有几个QueueInfo的实现类，该名称对应EventModel中的key，我们可以把所有的导出放在一个队列中，如果其他事件比如导入，就可以扩展一个新的实现类来定义。
3. **EventHandler接口**：定义事件处理方法和对应类型EventType。要实现一个事件，必须实现EventHandler接口，这就规定了所有的事件处理类都有这两个方法。这样在consumer中，我们使用``applicationContext.getBeansOfType(EventHandler.class)`` ,并将其转换为EventType和EventHandler实现类的映射，根据EventType就可以调用对应的实现类。为什么这样设计？还是扩展性的问题，如果需要添加一种事件，添加EventHandler的实现类即可。



## 7. 改进优化

1. 异步处理看起来很美好，但会为代码引入更大的复杂度，比如错误处理、反馈机制等等。比如不知道什么原因的运行失败，导致请求一直处于运行中，这种情况可以使用 **定时任务**（ElasticJob） ，每5分钟查看请求管理表中是否存在运行了一个小时以上的请求，如果存在，将请求状态修改为运行失败。



## 8. 源码

[export-demo](https://github.com/JuliaJiang7/export-demo)



## 9. 一些思考

我们都知道 Java 是面向对象的，三大特性封装、继承、多态，但怎样用好这些特性是很有意思的问题。想起之前面试的一个问题：**接口和抽象类的区别是什么？** 这是一个很常见的面试题，很多博客总结了很多，比如是否有方法实现、修饰符、成员变量类型等这些方面来回答，但真正核心的区别应该在于：抽象类是一个 **模版**，而接口更多的是作为一种 **适配** 的功能，比如上面的模版模式中的模版类，以及EventHandler接口。也就是常见的那句话：

>  从设计层面来说，抽象是对类的一种抽象，是一种模板设计；接口是对行为的抽象，是一种行为的规范。



## 10. 参考引用

1. https://www.cnblogs.com/0813lichenyu/p/11599421.html
2. https://www.runoob.com/design-pattern/template-pattern.html