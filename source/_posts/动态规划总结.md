---
title: 动态规划总结
date: 2020-09-11 09:25:10
tags:
  - Algorithm
  - Java
  - DP
categories: Algorithm

typora-copy-images-to: ..\pictures
---

本文主要介绍了动态规划的概念、解题框架，并以斐波那契数列、零钱兑换为例，进一步说明动态规划如何运用和理解。另外，本文还解决了LeetCode中部分使用动态规划思想的题目，这部分会持续更新。

## 1. 什么是动态规划？

[维基定义](https://zh.wikipedia.org/wiki/动态规划)：（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

<!--more-->

### 1.1 适用情况

1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

## 2. 动态规划解题框架

这一节参考 [这里](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie) 给出一些对于动态规划的理解和解体框架。

**首先，动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如求**最长**递增子序列呀，**最小**编辑距离等。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，**写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

按上面的套路走，最后的结果就可以套这个框架：

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

下文中的斐波那契数列可以帮助理解动态规划问题，零钱兑换问题使用总结的框架进行流程化求解。

## 3. 以斐波那契数列 [509] 为例

题目来源：[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

### 3.1 题目描述

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。

示例 1：

```bash
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
```


示例 2：

```bash
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
```


提示：

0 ≤ N ≤ 30

### 3.2 方法一：暴力递归

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```java
public int fib(int N) {
    if(N == 0){
        return 0;
    }
    if(N == 1){
        return 1;
    }
    return fib(N - 1) + fib(N - 2);
}
```

这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，画出的递归树如下：

<img src="/pictures/1-1595902107828.jpg" alt="img" style="zoom:33%;" />

这个递归树怎么理解？就是说想要计算原问题 `f(20)`，我就得先计算出子问题 `f(19)` 和 `f(18)`，然后要计算 `f(19)`，我就要先算出子问题 `f(18)` 和 `f(17)`，以此类推。最后遇到 `f(1)` 或者 `f(2)` 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。**

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 `f(n - 1) + f(n - 2)` 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 `f(18)` 被计算了两次，而且你可以看到，以 `f(18)` 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。

### 3.3 方法二：带备忘录的递归解法

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

```java
public int fib(int N) {
    int[] memo = new int[N + 1];
    if(N == 0){
        return 0;
    }
    // base case
    memo[1] = 1;
    return helper(memo, N);
}

private int helper(int[] memo, int n){
    // 递归结束条件
    if(n == 0){
        return 0;
    }
    if(n == 1){
        return 1;
    }
    // 如果已经计算过
    if(memo[n] != 0){
        return memo[n];
    }
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

由于本算法不存在冗余计算，子问题就是 `f(1)`, `f(2)`, `f(3)` ... `f(20)`，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 `f(20)`，向下逐渐分解规模，直到 `f(1)` 和 `f(2)` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 `f(1)` 和 `f(2)` 开始往上推，直到推到我们想要的答案 `f(20)`，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

### 3.4 方法三：动态规划

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算。

```java
public int fib(int N) {
    int[] dp = new int[N + 1];
    if(N == 0){
        return 0;
    }
    if(N == 1){
        return 1;
    }
    // base case
    dp[1] = 1;
    for(int i = 2; i <= N; i++){
        // 状态转移方程
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[N];
}
```

实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。

这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：

<img src="/pictures/fib.png" alt="img" style="zoom: 67%;" />

为啥叫「状态转移方程」？其实就是为了听起来高端。你把 `f(n)` 想做一个状态 `n`，这个状态 `n` 是由状态 `n - 1` 和状态 `n - 2` 相加转移而来，这就叫状态转移，仅此而已。

**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```java
public int fib3(int N) {
    if(N == 0){
        return 0;
    }
    if(N == 1){
        return 1;
    }
    int pre = 0, curr = 1;
    for(int i = 2; i <= N; i++){
        int sum = pre + curr;
        pre = curr;
        curr = sum;
    }
    return curr;
}
```

这个技巧就是所谓的「**状态压缩**」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 `n` 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。

## 4. 框架求解零钱兑换 [322]

题目来源：[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

### 4.1 题目描述

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

```bash
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

示例 2：

```bash
输入: coins = [2], amount = 3
输出: -1
```


说明:
你可以认为每种硬币的数量是无限的。

### 4.2 题目分析与代码

分析参考 [这里](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie#er-cou-ling-qian-wen-ti) , 使用上文中总结的动态规划框架。

首先，这是一个动态规划问题。满足三个条件：

1. 最优子结构。即问题的最优解所包含的子问题的解也是最优的，且子问题间必须相互独立。什么叫做相互独立？我用一个直观的例子来讲解。

   比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。

   得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

   但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

   回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制约，是互相独立的。

2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。

那么，既然知道了这是个动态规划问题，就要思考**如何列出正确的状态转移方程**？

1、**确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

3、**确定「选择」，也就是导致「状态」产生变化的行为**。*目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。* 所以说 **所有硬币的面值** ，就是你的「选择」。

4、**明确** **`dp`** **函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 `dp` 函数：

`dp(n)` 的定义：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

#### 4.2.1 先使用暴力递归

搞清楚上面这几个关键点，解法的伪码就可以写出来了：

```python
# 伪码框架
def coinChange(coins: List[int], amount: int):

    # 定义：要凑出金额 n，至少要 dp(n) 个硬币
    def dp(n):
        # 做选择，选择需要硬币最少的那个结果
        for coin in coins:
            res = min(res, 1 + dp(n - coin))
        return res

    # 题目要求的最终结果是 dp(amount)
    return dp(amount)
```

根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：

```python
def coinChange(coins: List[int], amount: int):

    def dp(n):
        # base case
        if n == 0: return 0
        if n < 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        return res if res != float('INF') else -1

    return dp(amount)
```

据此，我们可以得出状态转移方程如下图，以上解法属于暴力递归解法。

<img src="/pictures/coin.png" alt="img" style="zoom:67%;" />

**递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间**。

子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。

#### 4.2.2 带备忘录的递归解法，消除重叠子问题

显然，上述解法中存在重叠子问题，比如`amount = 11, coins = {1,2,5}` 时画出递归树看看：

<img src="/pictures/5-1595987693352.jpg" alt="img" style="zoom: 33%;" />

代码如下：

```python
def coinChange(coins: List[int], amount: int):
    # 备忘录
    memo = dict()
    def dp(n):
        # 查备忘录，避免重复计算
        if n in memo: return memo[n]
        # base case
        if n == 0: return 0
        if n < 0: return -1
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        # 记入备忘录
        memo[n] = res if res != float('INF') else -1
        return memo[n]

    return dp(amount)
```

很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 `n`，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。

#### 4.2.3 动态规划，自底向上

当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，`dp` 数组的定义和刚才 `dp` 函数类似，也是把「状态」，也就是目标金额作为变量。不过 `dp` 函数体现在函数参数，而 `dp` 数组体现在数组索引：

**`dp`** **数组的定义：当目标金额为** **`i`** **时，至少需要** **`dp[i]`** **枚硬币凑出**。

根据我们文章开头给出的动态规划代码框架可以写出如下解法：

```java
public int coinChange(int[] coins, int amount){
    // dp[i] = n 表示：当目标金额为 i 时，至少需要 n 枚硬币
    int[] dp = new int[amount+1];
    // 初始化dp数组，初始值为 amount+1, 因为dp 数组最大值取到 amount
    Arrays.fill(dp, amount+1);

    //base case
    dp[0] = 0;

    for(int j = 1; j <= amount; j++){
        // 内层for求所有子问题的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (j - coin < 0) {
                continue;
            }
            dp[j] = dp[j] < dp[j - coin] + 1 ? dp[j] : dp[j - coin] + 1;
        }
    }
    return dp[amount] == amount+1 ? -1 : dp[amount];
}
```

PS：为啥 `dp` 数组初始化为 `amount + 1` 呢，因为凑成 `amount` 金额的硬币数最多只可能等于 `amount`（全用 1 元面值的硬币），所以初始化为 `amount + 1` 就相当于初始化为正无穷，便于后续取最小值。

## 5. 动态规划总结

第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。

第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。

**计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举**，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。

## 6. 使用动态规划的题目列表

本文中使用动态规划解决的 LeetCode 题目列表如下，持续更新中~

|  #   |                            Title                             |  Remark   |
| :--: | :----------------------------------------------------------: | :-------: |
| 509  | [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/) |           |
| 322  |  [零钱兑换](https://leetcode-cn.com/problems/coin-change/)   |           |
| 300  | [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) |           |
| 1143 | [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/) |           |
|  53  | [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) |           |
|  72  | [编辑距离](https://leetcode-cn.com/problems/edit-distance/)  |           |
|  10  | [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/) |   Hard    |
|  44  | [通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/) |   Hard    |
|  62  |  [不同路径](https://leetcode-cn.com/problems/unique-paths/)  |           |
|  63  | [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) |           |
|  28  | [实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/) |           |
|  42  | [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) |   Hard    |
|  32  | [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/) |   Hard    |
|  53  | [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) |           |
|  64  | [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) |           |
|  85  | [最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) |   Hard    |
|  87  | [扰乱字符串](https://leetcode-cn.com/problems/scramble-string/) |   Hard    |
|  89  |   [格雷编码](https://leetcode-cn.com/problems/gray-code/)    |   Hard    |
|  91  |  [解码方法](https://leetcode-cn.com/problems/decode-ways/)   |   Hard    |
|  97  | [交错字符串](https://leetcode-cn.com/problems/interleaving-string/) |   Hard    |
| 115  | [不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) |   Hard    |
| 120  | [三角形最小路径和](https://leetcode-cn.com/problems/triangle/) |   Hard    |
| 123  | [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/) | Very Hard |

## 7. 例题：最长上升子序列 [300]

题目来源：[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

### 7.1 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

```bash
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```


说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。

### 7.2 题目分析

本题分析参考 [这里](https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g) .

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。

### 7.3 方法一：动态规划（如何找到状态转移关系）

动态规划的难点本来就在于寻找正确的状态转移方程，本文就借助经典的「最长递增子序列问题」来讲一讲设计动态规划的通用技巧：**数学归纳思想**。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么**我们先假设这个结论在 k 时成立，然后根据这个假设，想办法推导证明出 ``k=n`` 的时候此结论也成立**。如果能够证明出来，那么就说明这个结论对于 `k` 等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 `dp[i]`？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 `dp[i]` 的值到底代表着什么？

**我们的定义是这样的：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度。**

PS：**为什么这样定义呢？** 这是解决子序列问题的一个套路，后文动态规划之子序列问题解题模板 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 `dp` 数组的定义方法也就那几种。

反过来想，如果 ``dp[i]`` 表示 ``nums[0...i]`` 这个数组中的最长递增子序列的长度，当求得 ``dp[i]`` 时，想要求出 ``dp[i+1]`` 是不行的，因为递增子序列是从数组中选出的，知道 ``dp[i]`` 并不能确定当前选择的是哪几个数字，当然也不知道选出的递增子序列最后一位，这样是没法推出 ``dp[i+1]`` 的。但如果我们定义 ``dp[i]`` 表示以``nums[i]`` 结尾的最长递增子序列的长度，就可以明确知道选出的递增子序列的最后一位，从而推出 ``dp[i]`` . 只有这样定义才能将 `dp[i+1]` 和 `dp[i]` 建立起联系，利用数学归纳法写出状态转移方程。

根据这个定义，我们就可以推出 base case：`dp[i]` 初始值为 1，因为以 `nums[i]` 结尾的最长递增子序列起码要包含它自己。

根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。

那么我们应该怎么设计算法逻辑来正确计算每个 `dp[i]` 呢？

这就是动态规划的重头戏了，要思考如何设计算法逻辑进行状态转移，才能正确运行呢？这里就可以使用数学归纳的思想：

**假设我们已经知道了 `dp[0..4]` 的所有结果，我们如何通过这些已知结果推出 `dp[5]` 呢**？

根据刚才我们对 `dp` 数组的定义，现在想求 `dp[5]` 的值，也就是想求以 `nums[5]` 为结尾的最长递增子序列。

**`nums[5] = 3`，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**。

显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 `dp[5]` 的值即可。

最终代码如下：

```java
public int lengthOfLIS(int[] nums){
    // dp[i] = n 表示：以 nums[i] 这个数字结尾的最长上升子序列的长度（想不到）
    int[] dp = new int[nums.length];
    // 初始化，最长上升子序列最少为数字本身，故初始化为1
    Arrays.fill(dp, 1);

    for(int i = 0; i < nums.length; i++){
        for(int j = 0; j < i; j++){
            if(nums[j] < nums[i]){
                dp[i] = Math.max(dp[i], dp[j]+1);
            }
        }
    }

    int res = 0;
    for(int i = 0; i < nums.length; i++){
        res = Math.max(res, dp[i]);
    }

    return res;
}
```

至此，这道题就解决了，时间复杂度 O(N^2)。总结一下如何找到动态规划的状态转移关系：

**1、**明确 `dp` 数组所存数据的含义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

**2、**根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

### 7.4 方法二：二分查找

详解请看：https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g##

这个解法的时间复杂度为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。

```java
public int lengthOfLIS(int[] nums){
    int[] top = new int[nums.length];
    // 牌初始堆数定义为0
    int piles = 0;
    for(int i = 0; i < nums.length; i++){
        // 要处理的扑克牌
        int poker = nums[i];

        //*********** 二分查找：搜索左侧边界 ***************/
        // piles 表示堆数，即就是数组的长度；如果写成 right = piles + 1, 当 nums=[0] 时返回 0， 正确结果是 1
        int left = 0, right = piles;
        while (left < right){
            int mid = left + (right - left) / 2;
            if(top[mid] == poker){
                right = mid;
            }else if(top[mid] > poker){
                right = mid;
            }else if(top[mid] < poker){
                left = mid + 1;
            }
        }

        // 牌比每一个都大，则新建一个堆
        if(left == piles){
            piles++;
        }
        // 牌比每一个都小、或者找到合适位置，放入 top 数组即可
        top[left] = poker;
    }
    return piles;
}
```

## 8. 例题：最长公共子序列 [1143]

题目来源：[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

### 8.1 题目描述

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

若这两个字符串没有公共子序列，则返回 0。 

示例 1:

```bash
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```


示例 2:

```bash
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```


提示:

1 <= text1.length <= 1000
1 <= text2.length <= 1000
输入的字符串只含有小写英文字符。

### 8.2 题目分析

最长公共子序列（Longest Common Subsequence，简称 LCS）是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。

详细分析参考：https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie

### 8.3 代码

```java
public int longestCommonSubsequence(String text1, String text2){
    int len1 = text1.length();
    int len2 = text2.length();
    // 让 text1,text2 的索引从 1 开始
    // dp[i][j] = n 表示：对于 text1[1...i] 和 text2[1...j] 的最长公共子序列为 n
    //base case 是：dp[0][..] 和 dp[..][0] 初始化为0
    int[][] dp = new int[len1+1][len2+1];

    for(int i = 1; i <= len1; i++){
        for(int j = 1; j <= len2; j++){
            //状态转移
            if(text1.charAt(i-1) == text2.charAt(j-1)){
                dp[i][j] = dp[i-1][j-1] + 1;
            }else{
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[len1][len2];
}
```

## 9. 例题：最大子序列和 [53]

题目来源：[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

### 9.1 题目描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例：

```bash
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```


进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 9.2 题目分析

参考：https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu

解决这个问题需要动态规划技巧，但是 `dp` 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 `dp` 数组：

**`nums[0..i]`** **中的「最大的子数组和」为** **`dp[i]`**。

如果这样定义的话，整个 `nums` 数组的「最大子数组和」就是 `dp[n-1]`。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 `dp[i-1]`，如何推导出 `dp[i]` 呢？利用数学归纳法，你能用 `dp[i]` 推出 `dp[i+1]` 吗？

**实际上是不行的，因为子数组一定是连续的，按照我们当前** **`dp`** **数组定义，并不能保证** **`nums[0..i]`** **中的最大子数组与** **`nums[i+1]`** **是相邻的**，也就没办法从 `dp[i]` 推导出 `dp[i+1]`。

所以说我们这样定义 `dp` 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 `dp` 数组的含义：

**以** **`nums[i]`** **为结尾的「最大子数组和」为** **`dp[i]`**。

这种定义之下，想得到整个 `nums` 数组的「最大子数组和」，不能直接返回 `dp[n-1]`，而需要遍历整个 `dp` 数组。

虽然说动态规划推状态转移方程确实比较玄学，但大部分还是有些规律可循的。

这道「最大子数组和」就和「最长递增子序列」非常类似，`dp` 数组的定义是「以 `nums[i]` 为结尾的最大子数组和/最长递增子序列为 `dp[i]`」。因为只有这样定义才能将 `dp[i+1]` 和 `dp[i]` 建立起联系，利用数学归纳法写出状态转移方程。

### 9.3 代码

```java
public int maxSubArray(int[] nums) {
    int len = nums.length;
    // dp[i] = x 表示以 nums[i] 结尾的最大子序列和为x
    int[] dp = new int[len];
    // base case
    dp[0] = nums[0];

    int max = nums[0];
    for(int i = 1; i < len; i++){
        // 状态转移
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

## 10. 例题：编辑距离 [72]

题目来源：[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

### 10.1 题目描述

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

示例 1：

```bash
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```


示例 2：

```bash
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

### 10.2 题目分析

dp 问题自底向上求解，定义 dp 数组：``dp[i][j] = n`` 表示：``word1[1..i]`` 和 ``word2[1..j]`` 的最小编辑距离为 n，注意 word1 和 word2 的下标从1开始。

base case：当 i=0 或者 j=0 时，属于base case。

状态：距离。

选择：有三种选择，即删除、替换、插入，选出距离最小的。做出每一种选择后，使用前面求出 dp 数组的值。比如如果选择删除，则 ``dp[i][j] = dp[i-1][j] + 1`` ；如果选择替换，则 ``dp[i][j] = dp[i-1][j-1] + 1``；如果选择插入，则``dp[i][j] = dp[i][j-1] + 1``入，当插入时应该注意，不能在 ``word1[i]`` 之前插入，因为在前面插入后，没法使用已经求出的 dp 数组的值，而是在 ``word1[i]`` 的后面插入。

状态转移方程：如果字符相等，跳过；否则在删除、替换、插入中选择一种。

### 10.3 代码

```java
public int minDistance(String word1, String word2){
    int len1 = word1.length();
    int len2 = word2.length();
    //word1 和 word2 的下标从 1 开始
    //dp[i][j] = n 表示：word1[1..i] 和 word2[1..j] 的最小编辑距离为 n
    int[][] dp = new int[len1+1][len2+2];

    //base case
    for(int i = 0; i <= len1; i++){
        dp[i][0] = i;
    }
    for(int j = 0; j <= len2; j++){
        dp[0][j] = j;
    }

    for(int i = 1; i <= len1; i++){
        for(int j = 1; j <= len2; j++){
            if(word1.charAt(i-1) == word2.charAt(j-1)){
                dp[i][j] = dp[i-1][j-1];
            }else{
                //三种情况：插入、删除、替换
                dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1] + 1);
            }
        }
    }
    return dp[len1][len2];
}

private int min(int a, int b, int c){
    return Math.min(Math.min(a,b),c);
}
```

## 11. 例题：正则表达式匹配 [10]

题目来源：[10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

### 11.1 题目描述

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

```bash
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```


所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
示例 1:

```bash
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```bash
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

示例 3:

```bash
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

### 11.2 题目分析

两个字符串比较的动态规划问题。``dp[i][j]`` 表示 ``s[i-1]`` 和 ``p[i-1]`` 是否可以匹配。

base case：``dp[0][0] = true``， 但这还不够，字符串 "" 和 "a*" 也是匹配的。

状态：是否可以匹配。

选择：字符串 s 和 p 各前进一位。

状态转换：见代码。

### 11.3 代码

```java
public boolean isMatch(String s, String p){
    if(s == null || p == null){return false;}
    int len1 = s.length();
    int len2 = p.length();

    //dp 数组中 字符串下标从 1 开始，索引 0 存储空字符
    //dp[i][j] = true 表示：s[0..(i-1)] p[0..(j-1)] 可以匹配
    //base case：dp[..][0] 初始化为 0, 不存在可以匹配的可能
    boolean[][] dp = new boolean[len1+1][len2+1];
    dp[0][0] = true;
    //base case: dp[0][..] 初始化，如果出现 * 则可以消去上一个字符，且 上上一个字符对应 dp 值为 true，则当前 dp 值为true
    for(int j = 1; j < len2; j++){
        //j-1
        if(p.charAt(j) == '*' && dp[0][j-1]){
            //j+1
            dp[0][j+1] = true;
        }
    }

    for(int i = 0; i < len1; i++){
        for(int j = 0; j < len2; j++){
            //如果元素匹配或者为任意元素
            if(p.charAt(j) == '.' || s.charAt(i) == p.charAt(j)){
                dp[i + 1][j + 1] = dp[i][j];
            }

            if(p.charAt(j) == '*'){
                //如果前一个元素不匹配，则消去这两个元素
                if(p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.'){
                    dp[i + 1][j + 1] = dp[i + 1][j - 1];
                }else{
                    /*
                        * 如果前一个元素匹配，存在三种情况：
                        * 重复前一个字符多次（abbbb ab*）dp[i + 1][j + 1] = dp[i][j + 1]
                        * 重复前一个字符一次（ab ab*）dp[i + 1][j + 1] = dp[i + 1][j]
                        * 重复前一个字符零次（a ab*）dp[i + 1][j + 1] = dp[i + 1][j - 1]
                         */
                    dp[i + 1][j + 1] = (dp[i][j + 1] || dp[i + 1][j] || dp[i + 1][j - 1]);
                }
            }
        }
    }
    return dp[len1][len2];
```

## 12. 例题：通配符匹配 [44]

题目来源：[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

### 12.1 题目描述

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```bash
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
```

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
示例 1:

```bash
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```


示例 2:

输入:

```bash
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

示例 3:

```bash
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

示例 4:

```bash
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

示例 5:

```bash
输入:
s = "acdcb"
p = "a*c?b"
输出: false
```

PS：? 不可以匹配空字符串。

### 12.2 题目分析

两个字符串比较的动态规划问题。

本体类似于上一题，但我在考虑问题时始终不能跳出问题本身，使用动态规划的思想，而是一再考虑可能出现的不同情况，特别是出现 * 时。例如字符串 "abc" 和 "a*" , 当 p 中出现了 * 时，有两种处理方式：

1. 把 * 当做一个空字符串，那么 ``dp[i + 1][j + 1] = dp[i + 1][j]``
2. ``*`` 匹配任意字符串，那么 ``dp[i + 1][j + 1] = dp[i][j + 1]``

要注意理解，dp 问题注重的是当前状态的转化，即只考虑当前这一位，并把这个问题转化为更小问题的答案。

### 12.3 代码

```java
public boolean isMatch(String s, String p) {
    if(s == null || p == null){return false;}
    int len1 = s.length();
    int len2 = p.length();

    //dp 数组中 字符串下标从 1 开始，索引 0 存储空字符
    //dp[i][j] = true 表示：s[0..(i-1)] p[0..(j-1)] 可以匹配
    //base case：dp[..][0] 初始化为 0, 不存在可以匹配的可能
    boolean[][] dp = new boolean[len1+1][len2+1];
    dp[0][0] = true;
    //base case: dp[0][..] 初始化，如果出现 * 则可以视为空字符串
    for(int j = 0; j < len2; j++){
        if(p.charAt(j) == '*'){
            dp[0][j + 1] = dp[0][j];
        }
    }

    for(int i = 0; i < len1; i++){
        for(int j = 0; j < len2; j++){
            if(p.charAt(j) == '?' || s.charAt(i) == p.charAt(j)){
                dp[i + 1][j + 1] = dp[i][j];
            }
            if(p.charAt(j) == '*'){
                //情况一：s = "a", p = "a*", 此时 * 被当做空字符串 dp[i + 1][j + 1] = dp[i + 1][j]
                //情况二：s = "abc", p = "a*", 此时 * 被当做任意字符串 dp[i + 1][j + 1] = dp[i][j + 1]
                dp[i + 1][j + 1] = (dp[i + 1][j] || dp[i][j + 1]);
            }
        }
    }
    return dp[len1][len2];
}
```

## 13. 例题：不同路径 [62]

题目来源：[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

### 13.1 题目描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

示例 1:

```bash
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

示例 2:

```bash
输入: m = 7, n = 3
输出: 28
```


提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 10 ^ 9

### 13.2 题目分析

简单题。

``dp[i-1][j-1] ``表示：i * j 的网格上机器人的移动步数

状态转移：``dp[i][j] = dp[i - 1][j] + dp[i][j - 1]``

###  13.3 代码

```java
public int uniquePaths(int m, int n) {
    //dp[i-1][j-1] 表示：i * j 的网格上机器人的移动步数
    int[][] dp = new int[m][n];
    for(int i = 0; i < m; i++){
        dp[i][0] = 1;
    }
    for(int i = 1; i < n; i++){
        dp[0][i] = 1;
    }
    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

## 14. 例题：不同路径II [63]

题目来源：[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

### 14.1 题目描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

说明：m 和 n 的值均不超过 100。

示例 1:

```bash
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 14.2 题目分析

注意与上一题的区别。

### 14.3 代码

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    //dp[i-1][j-1] 表示：i * j 的网格上机器人的移动步数
    int[][] dp = new int[m][n];
    // 注意
    if(obstacleGrid[0][0] == 1){return 0;}
    // base case，与上一题不同
    for(int i = 0; i < m; i++){
        if(obstacleGrid[i][0] == 1){
            break;
        }
        dp[i][0] = 1;
    }
    for(int i = 1; i < n; i++){
        if(obstacleGrid[0][i] == 1){
            break;
        }
        dp[0][i] = 1;
    }
    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            if(obstacleGrid[i][j] == 1){
                dp[i][j] = 0;
            }else{
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp[m - 1][n - 1];
}
```

## 15. 例题：实现strStr() [15]

题目来源：[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

### 15.1 题目描述

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

```bash
输入: haystack = "hello", needle = "ll"
输出: 2
```


示例 2:

```bash
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```


说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

### 15.2 题目分析

详细分析参考：[这里](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa) . 太难了....

标准的KMP方法在我的另一篇博客：[这里](https://juliajiang7.github.io/2020/07/17/KMP算法/#more) .

我们可以认为 `pat` 的匹配就是状态的转移。比如当 pat = "ABABC"：

<img src="/pictures/state.jpg" alt="img" style="zoom:33%;" />

如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（`pat.length`）是终止状态。开始匹配时 `pat` 处于起始状态，一旦转移到终止状态，就说明在 `txt` 中找到了 `pat`。比如说当前处于状态 2，就说明字符 "AB" 被匹配：

<img src="/pictures/state2.jpg" alt="img" style="zoom:33%;" />

`dp[j][c] = next` 表示，当前是状态 `j`，遇到了字符 `c`，应该转移到状态 `next`。

base case：``dp[0][pat.charAt(0)] = 1;``, 只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）.

如何构建这个 `dp` 数组，需要一个辅助状态 `X`，它永远比当前状态 `j` 落后一个状态，拥有和 `j` 最长的相同前缀，我们给它起了个名字叫「影子状态」。

在构建当前状态 `j` 的转移方向时，只有字符 `pat[j]` 才能使状态推进（`dp[j][pat[j]] = j+1`）；而对于其他字符只能进行状态回退，应该去请教影子状态 `X` 应该回退到哪里（`dp[j][other] = dp[X][other]`，其中 `other` 是除了 `pat[j]` 之外所有字符）。

对于影子状态 `X`，我们把它初始化为 0，并且随着 `j` 的前进进行更新，更新的方式和 search 过程更新 `j` 的过程非常相似（`X = dp[X][pat[j]]`）。

### 15.3 代码

```java
public int strStr(String haystack, String needle){
    String txt = haystack;
    String pat = needle;
    int M = pat.length();
    int N = txt.length();
    if(M == 0){return 0;}

    //dp[j][c] = i 表示： 当前状态为 j，且遇到的下一个字符是 c 时, 下一个状态位 i
    int[][] dp = new int[M][256];
    KMP(pat, dp);

    //pat 的初始状态为 0
    int j = 0;
    for(int i = 0; i < N; i++){
        //计算 pat 的下一个状态
        j = dp[j][txt.charAt(i)];
        //到达终止状态，匹配成功
        if(j == M){return i - M + 1;}
    }
    //没到达终止状态，匹配失败
    return -1;
}

/**
     * 计算 dp, 即就是 next
     * @param pat
     * @param dp
     */
public void KMP(String pat, int[][] dp){
    int M = pat.length();

    //base case
    dp[0][pat.charAt(0)] = 1;
    //影子状态，初始化为 0
    int X = 0;
    //构建状态转移图
    for(int j = 1; j < M; j++){
        for(int c = 0; c < 256; c++){
            if(pat.charAt(j) == c){
                dp[j][c] = j + 1;
            }else{
                dp[j][c] = dp[X][c];
            }
        }
        //更新影子状态
        X = dp[X][pat.charAt(j)];
    }
}
```

## 16. 接雨水 [42]

题目来源：[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

### 16.1. 题目描述

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![image-20200810100323970](/pictures/image-20200810100323970.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。

示例:

```bash
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

### 16.2. 题目分析

本题分析参考：[这里](https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html).

### 16.3. 方法一：暴力解法（按列求）

参考 [这里](https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html) 的解法二按列求。

```java
public int trap(int[] height){
    int sum = 0;

    //最两端的不用考虑，因为一定不会有雨水
    for(int i = 1; i < height.length - 1; i++){
        int max_left = 0;
        //找出 height[i] 左边最高（包括height[i]），要把最左端考虑在内
        for(int j = i; j >= 0; j--){
            max_left = Math.max(height[j], max_left);
        }

        int max_right = 0;
        //找出 height[i] 右边最高（包括height[i]），要把最右端考虑在内
        for(int j = i; j < height.length;j++){
            max_right = Math.max(height[j], max_right);
        }

        //如果自己就是最高的话 max_left = max_right = height[i]
        sum += Math.min(max_left, max_right) - height[i];
    }
    return sum;
}
```

时间复杂度：O（n²），遍历每一列需要 n，找出左边最高和右边最高的墙加起来刚好又是一个 n，所以是 n²。

空间复杂度：O（1）。

### 16.4. 方法二：动态规划

参考 [这里](https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html) 的解法三动态规划。dp 数组定义不同，本文采用的方法和暴力解法同步。

我们注意到，解法一中，对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。

首先用两个数组，max_left [ i ] 代表到第 i 列左边最高的墙的高度（包括第 i 列），max_right [ i ] 代表到第 i 列右边最高的墙的高度（包括第 i 列）。

这样，我们利用解法一的思路，不用在 for 循环中再重新遍历求 max_left 和 max_right 了。

```java
public int trap(int[] height) {
    int sum = 0;
    int len = height.length;
    if(len == 0){return 0;}

    // max_left[i] = x 表示：height[0..i] 中最大值为x
    int max_left[] = new int[len];
    // max_right[i] = x 表示：height[i..(len-1)] 中最大值为x
    int max_right[] = new int[len];

    // base case
    max_left[0] = height[0];
    max_right[len - 1] = height[len - 1];

    for(int i = 1; i < len; i++){
        max_left[i] = Math.max(height[i], max_left[i - 1]);
    }
    for(int j = len - 2; j > 0; j--){
        max_right[j] = Math.max(height[j], max_right[j + 1]);
    }

    for(int i = 1; i < len - 1; i++){
        sum += Math.min(max_left[i], max_right[i]) - height[i];
    }
    return sum;
}
```

时间复杂度：O（n）。

空间复杂度：O（n），用来保存每一列左边最高的墙和右边最高的墙。

## 17. 最长有效括号 [32]

题目来源：[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

### 17.1. 题目描述

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

```bash
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```


示例 2:

```bash
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

注意：题目要求找 **子串**， 即字符串中连续的一段。

### 17.2 题目分析

本题分析参考：[这里](https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html).

做题先从暴力解法入手，慢慢想如何进行优化。直接考虑高效率解法考虑会不周全，而且找不到思路啊，千万别心急。

### 17.3. 方法一：暴力解法

暴力解法就是：对每一个子串判断是否有效，返回最长的长度。

```java
public int longestValidParentheses(String s) {
    int len = s.length();
    if(len == 0){return 0;}
    int max = 0;
    for(int i = 0; i < len; i++){
        // 注意：substring 是左闭右开，所以这里j的取值小于等于len
        for(int j = i + 2; j <= len; j += 2){
            if(isValid(s.substring(i, j))){
                max = Math.max(max, j - i);
            }
        }
    }
    return max;
}
private boolean isValid(String s){
    Deque<Character> stack = new ArrayDeque<>();
    for(int i = 0; i < s.length(); i++){
        if(s.charAt(i) == '('){
            stack.push('(');
        }else{
            if(!stack.isEmpty() && stack.peek() == '('){
                stack.pop();
            }else{
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

时间复杂度: 列举字符串是 O（n²），判断是否是合法序列是 O（n），所以总共是 O（n³）。

空间复杂度：O（n），每次判断的时候，栈的大小。

这个算法，leetCode 会报时间超时。

### 17.4. 方法二：暴力解法优化

在解法一中，我们会做很多重复的判断，比如 ``()()()`` ，从下标 0 开始，我们先判断长度为 2 的是否是合法序列，再判断长度为 4 时的字符串是否合法，但依旧从下标 0 开始。判断长度为 6 时，依旧从下标 0 开始，但其实之前已经确认前 4 个是合法序列了，所以我们从 4 开始判断即可。

基于此，我们可以换一个思路，我们判断从每个位置开始的最长合法子串是多长即可。在判断是否是合法子串时，我们不使用栈，而是用一个变量记录当前的括号情况，遇到左括号加1，遇到右括号减1，如果变成0，更新最长合法子串长度。

```java
public int longestValidParentheses(String s) {
    int count = 0;
    int max = 0;
    for(int i = 0; i < s.length(); i++){
        count = 0;
        for(int j = i; j < s.length(); j++){
            if(s.charAt(j) == '('){
                count++;
            }else{
                count--;
            }

            if(count < 0){
                break;
            }

            if(count == 0){
                max = Math.max(max, j - i + 1);
            }
        }
    }
    return max;
}
```

时间复杂度：O（n²）。

空间复杂度：O（1）。

### 17.5. 方法三：动态规划

分析参考：[这里](https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html#解法三-动态规划).

```java
public int longestValidParentheses(String s) {
    int len = s.length();
    int max = 0;
    // dp[i]=x 表示：以s[i]结尾的子串最长有效长度为x
    int[] dp = new int[len];
    for(int i = 1; i < len; i++){
        // 如果遇到左括号，dp[i]=0，就是初始值
        // 遇到右括号时，才会更新dp数组
        if(s.charAt(i) == ')'){
            // 右括号的前一位是左括号
            if(s.charAt(i - 1) == '('){
                dp[i] = (i > 2 ? dp[i - 2] : 0) + 2;

                // 右括号前一位是右括号
                // 并且除去前边的合法序列的前一位是左括号
            }else if(i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '('){
                dp[i] = dp[i - 1] + ((i - dp[i - 1]) > 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
            }
            max = Math.max(max, dp[i]);
        }
    }
    return max;
}
```

时间复杂度：遍历了一次，O（n）。

空间复杂度：O（n）。

## 18. 最大矩形 [85]

题目来源：[85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

### 18.1. 题目描述

![image-20200820100311020](/pictures/image-20200820100311020.png)

### 18.2. 方法一：暴力解法

最原始地，我们可以列举每个可能的矩形。这可以通过遍历所有的(x1, y1) (x2, y2) 坐标，并以它们为对角顶点来完成。该方法过慢，不足以通过所有测试用例。

时间复杂度：O(N<sup>3</sup>M<sup>3</sup>)，空间复杂度：O(1).

### 18.3. 方法二：动态规划 - 使用柱状图的优化暴力解法

参考 [这里](https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/)，这道题的难点是根本想不到...

代码如下：

```java
public int maximalRectangle(char[][] matrix) {
    if(matrix.length == 0){return 0;}
    int row = matrix.length;
    int col = matrix[0].length;
    int maxArea = 0;
    // dp[i][j] = x 表示：以 matrix[i][j] 结尾的最大可能宽度
    int[][] dp = new int[row][col];

    for(int i = 0; i < row; i++){
        for(int j = 0; j < col; j++){
            if(matrix[i][j] == '1'){
                // 更新最大最大宽度
                dp[i][j] = (j == 0) ? 1 : dp[i][j - 1] + 1;

                int width = dp[i][j];
                // 计算以 matrix[i][j] 为右下角的矩形最大面积
                for(int k = i; k >= 0; k--){
                    width = Math.min(width, dp[k][j]);
                    maxArea = Math.max(maxArea, width * (i - k + 1));
                }
            }
        }
    }
    return maxArea;
}
```

### 18.4. 方法三：动态规划 - 每个点的最大高度

参考 [这里](https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/) 的方法四。太强了....更想不到... 而且不好理解。

```java
public int maximalRectangle(char[][] matrix) {
    if(matrix.length == 0){return 0;}
    int row = matrix.length;
    int col = matrix[0].length;

    int[] left = new int[col];
    int[] right = new int[col];
    int[] height = new int[col];
    Arrays.fill(right, col);

    int maxArea = 0;
    // 遍历每一行
    for(int i = 0; i < row; i++){
        int cur_left = 0;
        int cur_right = col - 1;

        // 高度
        // 遍历这一行的每一个元素
        for(int j = 0; j < col; j++){
            if(matrix[i][j] == '1'){
                // 在上一行的高度上加1
                height[j]++;
            }else{
                height[j] = 0;
            }
        }

        // 左边
        for(int j = 0; j < col; j++){
            if(matrix[i][j] == '1'){
                left[j] = Math.max(left[j], cur_left);
            }else{
                left[j] = 0;
                cur_left = j + 1;
            }
        }

        // 右边
        for(int j = col - 1; j >= 0; j--){
            if(matrix[i][j] == '1'){
                right[j] = Math.min(right[j], cur_right);
            }else{
                right[j] = col - 1;
                cur_right = j - 1;
            }
        }

        // 面积
        for(int j = 0; j < col; j++){
            maxArea = Math.max(maxArea, (right[j] - left[j] + 1) * height[j]);
        }
    }
    return maxArea;
}
```

## 19. 扰乱字符串 [87]

题目来源：[87. 扰乱字符串](https://leetcode-cn.com/problems/scramble-string/)

### 19.1. 题目描述

![image-20200821104157163](/pictures/image-20200821104157163.png)

![image-20200821104215491](/pictures/image-20200821104215491.png)

### 19.2. 代码

本题的难点在于没有思路... 也很难构造出 dp 的定义和状态。

具体分析参考：[这里](https://leetcode-cn.com/problems/scramble-string/solution/miao-dong-de-qu-jian-xing-dpsi-lu-by-sha-yu-la-jia/).

```java
public boolean isScramble(String s1, String s2) {
    char[] chs1 = s1.toCharArray();
    char[] chs2 = s2.toCharArray();
    int n = s1.length();

    // dp[i][j][len]dp[i][j][len] 表示从字符串 S 中 i 开始（包括 i）长度为 len 的字符串是否能变换为
    // 从字符串 T 中 j （包括 j）开始长度为 len 的字符串
    boolean[][][] dp = new boolean[n][n][n + 1];

    // base case
    // 初始化单个字符的情况
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            dp[i][j][1] = (chs1[i] == chs2[j]);
        }
    }

    // 枚举长度区间 len
    for(int len = 2; len <= n; len++){
        // 枚举 S 的起点
        for(int i = 0; i <= n - len; i++){
            // 枚举 T 的起点
            for(int j = 0; j <= n - len; j++){
                // 枚举划分位置
                for(int k = 1; k <= len - 1; k++){
                    // 第一种情况：不交换
                    if(dp[i][j][k] && dp[i + k][j + k][len - k]){
                        dp[i][j][len] = true;
                        break;
                    }
                    // 第二种情况：交换
                    if(dp[i][j + len - k][k] && dp[i + k][j][len - k]){
                        dp[i][j][len] = true;
                        break;
                    }
                }

            }
        }
    }

    return dp[0][0][n];
}
```

## 20. 格雷编码 [89]

题目来源：[89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

### 20.1. 题目描述

![image-20200822094721670](/pictures/image-20200822094721670.png)

### 20.2. 代码

感觉应该用 dp，但是没找到怎么 dp，所以 dp 问题首先应该找到小问题，然后考虑怎么根据小问题解决大问题。

详细参考：[这里](https://leetcode.wang/leetCode-89-Gray-Code.html)

```java
public List<Integer> grayCode(int n) {
    // dp 列表存储最终结果
    List<Integer> dp = new ArrayList<>();
    // base case，n = 0 时
    dp.add(0);

    // 遍历要加的数的次数，从 0 开始，到 n-1 结束
    for(int i = 0; i < n; i++){
        // 要加的数，即 2^i
        int add = 1 << i;
        // 倒序遍历，加上 add 添加到结果集中
        for(int j = dp.size() - 1; j >= 0; j--){
            dp.add(dp.get(j) + add);
        }
    }
    return dp;
}
```

## 21. 解码方法 [91]

题目来源：[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

### 21.1. 题目描述

![image-20200825143910613](/pictures/image-20200825143910613.png)

### 21.2. 代码

分析参考：[这里](https://leetcode-cn.com/problems/decode-ways/solution/dong-tai-gui-hua-java-python-by-liweiwei1419/) ，再结合自己的思路，写了一个更好理解的代码。

```java
public int numDecodings(String s) {
    int len = s.length();
    // dp[i] = x 表示：s[0...i] 有 x 中解码方法
    int[] dp = new int[len];

    char[] charArray = s.toCharArray();
    if (charArray[0] == '0') {
        return 0;
    }
    // base case
    dp[0] = 1;

    for (int i = 1; i < len; i++) {
        int num = 10 * (charArray[i - 1] - '0') + (charArray[i] - '0');
        // 如果是 0
        if(charArray[i] == '0'){
            // 只有和前一位组成的数字在 10 到 26 之内，dp 才会有值，否则是初始值 0
            if(10 <= num && num <= 26){
                if(i == 1){
                    dp[i] = 1;
                }else{
                    dp[i] = dp[i - 2];
                }
            }
        // 如果不是 0
        }else{
            // 和前一位组成的数字在 10 到 26 之内，dp 值增大
            if(10 <= num && num <= 26){
                if(i == 1){
                    dp[i] = dp[i - 1] + 1;
                }else{
                    dp[i] = dp[i - 1] + dp[i - 2];
                }
                // 不在 10 到 26 之内，dp 和 前一位相同
            }else{
                dp[i] = dp[i - 1];
            }
        }
    }
    return dp[len - 1];
}
```

本题的难点在于：出现 0 的处理，边界条件太多了...可能的情况太多了...是真的费时间。

## 22. 最大子序和 [53]

题目描述：[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

### 22.1. 题目描述

![image-20200826102906095](/pictures/image-20200826102906095.png)

### 22.2. 代码

典型的动态规划问题。

```java
public int maxSubArray(int[] nums) {
    int len = nums.length;
    // dp[i] = x 表示以 nums[i] 结尾的最大子序列和为x
    int[] dp = new int[len];
    // base case
    dp[0] = nums[0];

    int max = nums[0];
    for(int i = 1; i < len; i++){
        // 状态转移
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

## 23. 交错字符串 [97]

题目来源：[97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/)

### 23.1. 题目描述

![image-20200828110613718](/pictures/image-20200828110613718.png)

### 23.2. 方法一：动态规划

参考：[这里](https://leetcode.wang/leetCode-97-Interleaving-String.html)

dp 数组定义：定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。

注意，``dp[0][0]`` 表示 s1 和 s2 都取空串，组成一个空串，则值为 true。

```java
public boolean isInterleave(String s1, String s2, String s3) {
    if (s1.length() + s2.length() != s3.length()) {
        return false;
    }
    if (s1.length() == 0 && s2.length() == 0 && s3.length() == 0) {
        return true;
    }
    int len1 = s1.length();
    int len2 = s2.length();
    // dp[i][j] = true 表示：s1[0..i) 和 s2[0..j) 组合后能构成 s3[0..i+j)
    boolean[][] dp = new boolean[len1 + 1][len2 + 1];
    // base case
    dp[0][0] = true;
    for (int i = 1; i <= len1; i++) {
        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
    }
    for (int j = 1; j <= len2; j++) {
        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
    }

    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1))
                || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
        }
    }
    return dp[len1][len2];
}
```

### 23.3. 方法二：回溯

可前往我的博客 [回溯算法总结](http://juliajiang.top/2020/07/25/回溯算法总结/) 的 15. 交错字符串 [97] 查看。

## 24. 最小路径和 [64]

题目来源：[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

### 24.1. 题目描述

![image-20200901100037412](/pictures/image-20200901100037412.png)

### 24.2. 代码

典型的动态规划问题：

```java
public int minPathSum(int[][] grid) {
    int row = grid.length;
    int col = grid[0].length;
    
	// dp[i][j] = x 表示：到grid[i][j]的最小路径和为 x
    int[][] dp = new int[row][col];
    dp[0][0] = grid[0][0];
    for(int j = 1; j < col; j++){
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    for(int i = 1; i < row; i++){
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }

    for(int i = 1; i < row; i++){
        for(int j = 1; j < col; j++){
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }

    return dp[row - 1][col - 1];
}
```

## 25. 不同的子序列 [115]

题目来源：[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

### 25.1. 题目描述

![image-20200904105932893](/pictures/image-20200904105932893.png)

### 25.2. 代码

参考：[这里](https://leetcode.wang/leetcode-115-Distinct-Subsequences.html) 的解法三，将 dp 从逆序改为正序。

这道题一开始用的回溯，发现超时，需要用 map 存之前的递归结果，不太好存，也不好理解，参考 [这里](https://leetcode.wang/leetcode-115-Distinct-Subsequences.html) 的解法二。

还是用 dp 吧...

两个字符串的 dp 问题，依旧是用 ``dp[0][0]`` 表示两个字符串均为空串的情况。

```java
public int numDistinct(String s, String t) {
    int sLen = s.length();
    int tLen = t.length();
    // dp[i + 1][j + 1] = x 表示：s[0..i] 中的子序列 t[0..j] 的个数为 x
    int[][] dp = new int[sLen + 1][tLen + 1];
    // base case
    for(int i = 0; i <= sLen; i++){
        dp[i][0] = 1;
    }

    for(int j = 1; j <= tLen; j++){
        for(int i = 1; i <= sLen; i++){
            // 如果相等
            if(t.charAt(j - 1) == s.charAt(i - 1)){
                // 有两种选择：不选择当前字母 dp[i - 1][j] 和选择当前字母 dp[i - 1][j - 1]
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
                // 如果不相等
            }else {
                // 只有一种选择：不选当前字母
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[sLen][tLen];
}
```

## 26. 三角形最小路径和 [120]

题目来源：[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

### 26.1 题目描述

![image-20200910185227369](/pictures/image-20200910185227369.png)

### 26.2 方法一：动态规划

参考 [这里](https://leetcode.wang/leetcode-120-Triangle.html) 做了一些改动。但是这种 dp 空复为 O(n^2)。

为什么..最近做题老是想不到动态规划.. 老想回溯...

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int size = triangle.size();
    int[][] dp = new int[size][size];
    // dp[i][j] = x 表示：triangle[i][j] 的最小路径和为 x
    dp[0][0] = triangle.get(0).get(0);

    // 遍历每一行
    for(int i = 1; i < size; i++){
        // 遍历这一行的每一个数
        for(int j = 0; j <= i; j++){
            // 这一行的最后一个数
            if(j == i){
                dp[i][j] = dp[i - 1][j - 1] + triangle.get(i).get(j);
            }else if(j == 0){
                dp[i][j] = dp[i - 1][j] + triangle.get(i).get(j);
            }else{
                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j);
            }
        }

    }

    int min = Integer.MAX_VALUE;
    for(int i = 0; i < size; i++){
        min = Math.min(min, dp[size-1][i]);
    }
    return min;
}
```

### 26.3. 方法一的优化

上面的动态规划 dp 数组是二维数组，但是每一次只用到上一层的数据。所以使用一维的 dp 数组即可。此时，空复是 O(n)。

如果正着更新的话，会把后面要用的值覆盖掉。因此，倒着更新。

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int size = triangle.size();
    int[] dp = new int[size];
    dp[0]=triangle.get(0).get(0);

    for(int i = 1; i < size; i++){
        for(int j = i; j >= 0; j--){
            if(j == i){
                dp[j] = dp[j - 1] + triangle.get(i).get(j);
            }else if(j == 0){
                dp[j] = dp[j] + triangle.get(i).get(j);
            }else{
                dp[j] = Math.min(dp[j - 1], dp[j]) + triangle.get(i).get(j);
            }
        }
    }

    int min = Integer.MAX_VALUE;
    for(int i = 0; i < size; i++){
        min = Math.min(min, dp[i]);
    }

    return min;
}
```

## 27. 买卖股票的最佳时机 III [123]

题目来源：[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

### 27.1. 题目描述

![image-20200914160900975](/pictures/image-20200914160900975.png)

### 27.2. 方法一：DP

参考 [这里](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-zui-jia-shi-ji-iiidong-tai-gui-hua/) 的方法二。

使用二维数组，第二位存储 5 种状态，想不到...

```java
public int maxProfit(int[] prices) {
    if (prices.length < 2) {
        return 0;
    }
    int len = prices.length;
    // 5 种状态：0 未交易；1 买入一次；2 卖出一次；3 买入2次；卖出2次
    // dp[i][j] = x 表示：用户处于 j 状态下的钱为 x
    int[][] dp = new int[len][5];
    // base case
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[0][2] = 0;
    dp[0][3] = -prices[0];
    dp[0][4] = 0;

    for (int i = 1; i < len; ++i) {
        dp[i][0] = 0;
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
    }

    return Math.max(dp[len - 1][2], dp[len - 1][4]);
}
```

### 27.3. 方法二：方法一的优化

上面解法中，每一次 dp 数组的更新只会依赖于上一层 dp 数组，因此没必要使用二维数组，使用一维数组，存储上一层数据即可。

```java
public int maxProfit(int[] prices) {
    if (prices.length < 2) {
        return 0;
    }
    int len = prices.length;
    int[] dp = new int[5];
    dp[0] = 0;
    dp[1] = -prices[0];
    dp[2] = Integer.MIN_VALUE;
    dp[3] = Integer.MIN_VALUE;
    dp[4] = Integer.MIN_VALUE;

    for (int i = 1; i < len; ++i) {
        dp[0] = 0;
        dp[1] = Math.max(dp[1], dp[0] - prices[i]);
        dp[2] = Math.max(dp[2], dp[1] + prices[i]);
        dp[3] = Math.max(dp[3], dp[2] - prices[i]);
        dp[4] = Math.max(dp[4], dp[3] + prices[i]);
    }
    return Math.max(dp[2], dp[4]);
}
```

## 28. 参考引用

1. [Wikipedia]([https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92](https://zh.wikipedia.org/wiki/动态规划))
2. https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie
3. https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g
4. https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie
5. https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu
6. https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa
7. https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html
8. https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html
9. https://leetcode.wang/leetCode-89-Gray-Code.html

