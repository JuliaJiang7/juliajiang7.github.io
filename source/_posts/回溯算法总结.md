---
title: 回溯算法总结
date: 2020-07-25 08:55:05
tags:
  - Algorithm
  - Java
  - 回溯
categories: Algorithm
typora-copy-images-to: ..\pictures
---

本文主要介绍了回溯法的定义、回溯法的代码框架，以及回溯法的典型问题全排列问题、N皇后问题等。另外，还介绍了LeetCode中使用回溯法的部分题目，这部分内容会持续更新。

## 1. 什么是回溯法？

**[维基定义](https://zh.wikipedia.org/wiki/回溯法)** : （英语：backtracking）是[暴力搜索法](https://zh.wikipedia.org/wiki/暴力搜尋法)中的一种。

对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，**[八皇后问题](https://zh.wikipedia.org/wiki/八皇后问题)**展示了回溯法的用例。

<!--more-->

回溯法采用[试错](https://zh.wikipedia.org/wiki/试错)的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案
- 在尝试了所有可能的分步方法后宣告该问题没有答案

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。而回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。

## 2. 回溯法框架

上文主要是 Wikipedia 对于回溯法的介绍，这一节，将参考 [这里](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban) 给出一个回溯算法的框架。

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1. 路径：也就是已经做出的选择
2. 选择列表：也就是你当前可以做的选择
3. 结束条件：也就是到达决策树底层，无法再做选择的条件

如果现在不理解这三个词语没关系，下一节我们将以全排列问题为例，进行详细介绍。下面给出回溯法的框架：

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。**

## 3. 以全排列问题（无重复数字）为例 [46]

### 3.1 题目描述

题目来源：[46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

示例：

```bash
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### 3.2 问题分析

我们知道，对于 n 个不重复的数，全排列共有 n! 个。如果使用穷举法，我们一般会：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，可以转化为下面的回溯树：

<img src="/pictures/1.jpg" alt="img" style="zoom: 33%;" />

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。**我们不妨把这棵树称为回溯算法的「决策树」**。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策**。比如说你站在下图的红色节点上：

<img src="/pictures/2.jpg" alt="img" style="zoom:33%;" />

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

**现在可以解答开头的几个名词：**`[2]` **就是「路径」，记录你已经做过的选择；`[1,3]`就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候**。

如果明白了这几个名词，**可以把「路径」和「选择」列表作为决策树上每个节点的属性**，比如下图列出了几个节点的属性：

<img src="/pictures/3.jpg" alt="img" style="zoom:33%;" />

**框架中定义的 ``backtrace``  函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列**。

在回溯法中，**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。因此，框架中的核心代码详细化如下：

```python
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

### 3.3 代码

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> permute(int[] nums) {
    // 记录路径（已做出的选择）
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}

/**
     *
     * @param nums
     * @param track
     */
private void backtrack(int[] nums, LinkedList<Integer> track){
    // 满足结束条件（到达决策树底层，无法再做选择的条件）
    if(nums.length == track.size()){
        res.add(new LinkedList<>(track));
        return;
    }
    for (int num : nums) {
        // 排除不合法的选择
        if(track.contains(num)){
            continue;
        }
        // 做选择
        track.add(num);
        // 进入下一层决策树
        backtrack(nums, track);
        // 撤销选择
        track.removeLast();
    }
}
```

这里我们并没有显示记录「选择列表」，而是通过 `nums` 和 `track` 推导出当前的选择列表。

至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 `contains` 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。

但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高**。

明白了全排列问题，就可以直接套回溯算法框架了。

### 3.4 另一种方法

上文中没有显示记录「选择列表」，通过用路径的 `contains` 方法来判断是否选择。这里我们 **“以空间换时间”** 的思想，使用一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)  的时间复杂度判断这个数是否被选择过。（参考 [这里](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)）

```java
List<List<Integer>> res2 = new LinkedList<>();
public List<List<Integer>> permute2(int[] nums){
    int len = nums.length;
    if(len == 0){
        return res;
    }

    LinkedList<Integer> track = new LinkedList<>();
    // 标记数组
    boolean[] used = new boolean[len];
    backtrace2(nums, track, used);
    return res2;
}

/**
     * 
     * @param nums
     * @param track
     * @param used 标记数组，used[i]=true时，表示已被选择
     */
private void backtrace2(int[] nums, LinkedList<Integer> track, boolean[] used){
    int len = nums.length;
    if(track.size() == len){
        res2.add(new LinkedList<>(track));
        return;
    }

    for(int i = 0; i < len; i++){
        if(used[i]){
            continue;
        }

        track.add(nums[i]);
        used[i] = true;

        backtrace2(nums, track, used);

        track.removeLast();
        used[i] = false;
    }
}
```

## 4. N皇后问题 [51]

### 4.1 题目描述

题目来源：[51. N皇后](https://leetcode-cn.com/problems/n-queens/)

*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

![img](/pictures/8-queens.png)

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例：**

```bash
输入: 4
输出: [
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。
```

### 4.2 问题分析

这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。

### 4.3 代码

```java
List<List<String>> res = new LinkedList<>();
public List<List<String>> solveNQueens(int n) {
    if (n <= 0){
        return null;
    }

    // 初始化棋盘 board 为二维字符数组
    char[][] board = new char[n][n];
    for (char[] chars : board){
        // 初始化
        Arrays.fill(chars, '.');
    }

    backtrack(board, 0);
    return res;
}

/**
     * 路径：board中小于row的那些行都已经成功放置了皇后
     * 可选择列表: 第row行的所有列都是放置 Q 的选择
     * 结束条件: row超过board的最后一行
     *
     * @param board 记录路径
     * @param row 当前放置第几行
     */
private void backtrack(char[][] board, int row) {
    //触发结束条件
    if (row == board.length) {
        res.add(charToString(board));
        return;
    }

    int n = board[row].length;
    for (int col = 0; col < n; col++) {
        //排除不合法选择
        if (!isValid(board, row, col)){
            continue;
        }
        //做选择
        board[row][col] = 'Q';
        //进入下一层决策树
        backtrack(board, row + 1);
        //撤销选择
        board[row][col] = '.';
    }
}

/**
     * 是否可以在 board[row][col] 放置皇后
     * 不需要检查 这一行，因为每一行只放一个皇后就到下一行
     * 不需要检查 左下、右下斜线，因为下面还没放元素
     * @param board
     * @param row
     * @param col
     * @return
     */
private boolean isValid(char[][] board, int row, int col) {
    int rows = board.length;
    //检查这一列是否有皇后
    for (char[] chars : board){
        if (chars[col] == 'Q'){
            return false;
        }
    }
    // 检查左上斜线上是否有皇后
    for (int i = row - 1, j = col + 1; i >= 0 && j < rows; i--, j++) {
        if (board[i][j] == 'Q'){
            return false;
        }
    }
    // 检查右上斜线上是否有皇后
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q'){
            return false;
        }
    }
    return true;
}

private static List<String> charToString(char[][] array) {
    List<String> result = new LinkedList<>();
    for (char[] chars : array) {
        result.add(String.valueOf(chars));
    }
    return result;
}
```

函数 `backtrack` 依然像个在决策树上游走的指针，通过 `row` 和 `col` 就可以表示函数遍历到的位置，通过 `isValid` 函数可以将不符合条件的情况剪枝。

## 5. 回溯法总结

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：

```python
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

**写** **`backtrack`** **函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。

下面几节记录了一些平时遇到的，可以使用回溯解决的经典例题，会持续更新~

## 6. 使用回溯法的题目列表

本文中使用回溯法解决的 LeetCode 题目列表如下，持续更新中~

|  #   |                            Title                             | Remark |
| :--: | :----------------------------------------------------------: | :----: |
|  46  |   [全排列](https://leetcode-cn.com/problems/permutations/)   |        |
|  51  |     [N皇后](https://leetcode-cn.com/problems/n-queens/)      |  Hard  |
|  47  | [全排列 II](https://leetcode-cn.com/problems/permutations-ii/) |        |
|  39  | [组合总和](https://leetcode-cn.com/problems/combination-sum/) |        |
|  40  | [组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/) |        |
|  70  |    [组合](https://leetcode-cn.com/problems/combinations/)    |        |
|  79  |  [单词搜索](https://leetcode-cn.com/problems/word-search/)   |  Hard  |
|  78  |      [子集](https://leetcode-cn.com/problems/subsets/)       | Medium |
|  90  |   [子集 II](https://leetcode-cn.com/problems/subsets-ii/)    |        |
|  93  | [复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/) |  Hard  |
|  97  | [交错字符串](https://leetcode-cn.com/problems/interleaving-string/) |  Hard  |
| 113  | [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) |        |

## 7. 例题：全排列问题（有重复数字）[47]

### 7.1 题目描述

题目来源：[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列，返回所有不重复的全排列。

示例：

```bash
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

### 7.2 题目分析

这道题与上面 46 题不同，给出的序列是包含重复数字的，所以，46题的第一种方法使用track的contain来判断是否选择在这里不使用。而第二种方法，标记数组是可行的，但直接使用 used 数组判断，最终得到的全排列结果可能会有重复，如下图所示：（图片来自：[这里](https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/)）

<img src="/pictures/全排列2.png" alt="全排列2" style="zoom: 33%;" />

如上所示，绿色框中的序列都是重复的，不属于结果集。为什么会出现这种情况呢？

观察发现，在决策树中，同一父节点下的子节点中，选中两个相同的数字时，必然出现重复的全排列结果。那么如何避免这种情况呢？

对给出的序列进行排序，这样相同的数字都会放在一起。

```bash
for 选择 in 选择列表:
	做选择
	backtrack(路径, 选择列表)
	撤销选择
```

在框架的核心代码中，撤销选择处撤销的数字，就是下一个遍历节点的左侧兄弟节点，保存这个数组为 pre，如下图所示，当遍历到nums[i] 处时，如果 pre == nums[i]，则说明需要剪枝。

<img src="/pictures/image-20200725154024914.png" alt="image-20200725154024914" style="zoom:67%;" />

### 7.3 代码

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> permuteUnique(int[] nums){
    int len = nums.length;
    if(len == 0){
        return res;
    }

    // 排序；相同的数字放在一起，重复的剪枝方便
    Arrays.sort(nums);
    LinkedList<Integer> track = new LinkedList<>();
    boolean[] used = new boolean[len];
    backtrack(nums, track, used);
    return res;
}

private void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used){
    int len = nums.length;
    // 满足结束条件
    if(track.size() == len){
        res.add(new LinkedList<>(track));
        return;
    }

    // 初始化为数组中没有的数
    int pre = nums[0] - 1;
    for(int i = 0; i < len; i++){
        // 排除不合法选择
        if(used[i] || pre == nums[i]){
            continue;
        }
        // 做选择
        track.add(nums[i]);
        used[i] = true;
        // 进入下一层决策树
        backtrack(nums, track, used);
        // 撤销选择
        track.removeLast();
        used[i] = false;
        // 记录刚被撤销的数字
        pre = nums[i];
    }
}
```

### 7.4 小结

还是按照回溯法的框架来解决，但是剪枝的部分一开始想不到。

## 8. 例题：组合总和 [39]

### 8.1 题目描述

题目来源：[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

```bash
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

示例 2：

```bash
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

提示：

```bash
1 <= candidates.length <= 30
1 <= candidates[i] <= 200
candidate 中的每个元素都是独一无二的。
1 <= target <= 500
```

### 8.2 题目分析

这道题依旧可以使用回溯法进行暴力穷举。有几点需要注意：

1. 选择列表candidates可以重复选择，即选择列表自始至终都不变，是candidates
2. candidate 中的每个元素都是独一无二的
3. 解集不能包含重复的组合，即最终的结果不能重复

鉴于最终结果不可以重复，我们可以剪掉会重复的枝，即将选择列表排序，路径的下一个节点选择从当前节点开始遍历（由于candidate 中的每个元素不重复，所以start从 i 开始就可以解决结果重复的问题）。另外，这道题改用减法更好理解。

### 8.3 代码

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> combinationSum(int[] candidates, int target){
    if(candidates.length == 0){
        return res;
    }

    // 优化添加的代码1：先对数组排序，可以提前终止判断
    Arrays.sort(candidates);
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(candidates, track, target, 0);
    return res;
}

/**
     *
     * @param candidates
     * @param track 记录路径
     * @param residue 剩余
     * @param start 下一次从 start 开始判断是否添加到路径
     */
private void backtrack(int[] candidates, LinkedList<Integer> track, int residue, int start){
    //触发结束条件
    if(residue == 0){
        res.add(new LinkedList<>(track));
        return;
    }

    // i 从 start 开始，剪掉小于 candidates[i] 的枝
    for(int i = start; i < candidates.length; i++){
        // 排除不合法的选择
        if(residue - candidates[i] < 0){
            break;
        }

        // 做选择
        track.add(candidates[i]);
        // 进入下一层决策树
        // residue-candidates[i] 为下一轮剩余
        // i 为下一轮的 start值，原因：为了避免重复，选择的数字只能大于等于candidates[i]
        backtrack(candidates, track, residue-candidates[i], i);
        // 撤销选择
        track.removeLast();
    }
}
```

## 9. 例题：组合总和 2 [40]

题目来源：[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

### 9.1 题目描述

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

```bash
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```


示例 2:

```bash
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```

### 9.2 题目分析

本题与上一题的区别有两个：

1. candidates 中的每个数字在每个组合中只能使用一次
2. candidates 中有重复数字

思路如下：

1. 要保证每个数字用一次，先对序列排序， 且 start 从 i+1 开始
2. 要保证结果不重复，第一步是不够的，因为 candidates 中有重复数字。这个问题和上文的 **全排列问题（有重复数字）** 类似，使用 pre 标记刚撤销的数字，与当前值比较后进行剪枝。

### 9.3 代码

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> combinationSum2(int[] candidates, int target){
    if(candidates.length == 0){
        return res;
    }

    // 排序
    Arrays.sort(candidates);
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(candidates, track, target, 0);
    return res;
}

/**
     *
     * @param candidates
     * @param track 记录路径
     * @param residue 剩余
     * @param start 下一次从 start 开始判断是否添加到路径
     */
private void backtrack(int[] candidates, LinkedList<Integer> track, int residue, int start){
    //触发结束条件
    if(residue == 0){
        res.add(new LinkedList<>(track));
        return;
    }

    int pre = candidates[0] - 1;
    for(int i = start; i < candidates.length; i++){
        // 排除不合法的选择
        // candidates排序之后，如果第一个不满足，后面的肯定不满足，直接break
        if(residue - candidates[i] < 0){
            break;
        }
        // 当前值和上一个撤销的值相同，会重复，continue
        if(candidates[i] == pre){
            continue;
        }

        //做选择
        track.add(candidates[i]);
        // 进入下一层决策树
        // start 从 i+1 开始
        backtrack(candidates, track, residue-candidates[i], i+1);
        //撤销选择
        track.removeLast();
        pre = candidates[i];
    }
}
```

## 10. 例题：组合 [70]

题目来源：[77. 组合](https://leetcode-cn.com/problems/combinations/)

### 10.1 题目描述

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例：

```bash
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 10.2 题目分析

这种数字组合的题目是典型的回溯法问题，先选一个数字，进入递归继续选，如果满足条件则加入结果中，然后回溯到上一步，继续递归。

### 10.3 代码

```java
List<List<Integer>> res = new LinkedList<>();

/**
     * 解法一：回溯法
     * 回溯的常规解法
     * @param n
     * @param k
     * @return
     */
public List<List<Integer>> combine(int n, int k) {
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(track, n, k, 1);
    return res;
}

private void backtrack(LinkedList<Integer> track, int n, int k, int start){
    // 如果满足条件
    if(track.size() == k){
        res.add(new LinkedList<>(track));
        return;
    }

    // 为避免重复，i 从 start 开始
    for(int i = start; i <= n; i++){
        // 做选择
        track.add(i);
        backtrack(track, n, k, i+1);
        // 撤销选择
        track.removeLast();
    }
}
```

### 10.4 优化

参考 [这里](https://leetcode.wang/leetCode-77-Combinations.html) 对上面代码进行优化。将 for 循环改为 ``for(int i = start; i <= (n-k)+1 + track.size(); i++)``, 其中，``(n-k)+1``  表示要在 n 中找到 k 个数字组合，start 必须从 (n-k)+1 处开始；``(n-k)+1 + track.size()``  表示当前 i 取到的最大数字。原因如下：

我们发现，如果 n = 5, k = 3,  那么 start 最大取到3，因为如果 start = 4，最终结果只能得到到 (4,5), 结果的个数必定小于k，不满足条件。

如果 n = 5, k = 3, start = 1, 当 i = 2, track.size() = 1时，i 最大取到 (5-3)+1 + 1 = 4，否则，如果 i 取到 5，结果只能为 (1,5), 数字个数肯定不满足条件。

代码如下：

```java
private void backtrack2(LinkedList<Integer> track, int n, int k, int start){
    if(track.size() == k){
        res.add(new LinkedList<>(track));
        return;
    }

    // (n-k)+1 表示要在n中找到k个数字组合，start必须从(n-k)+1处开始
    // 即如果n=5,k=3, 那么start最大取到3，因为如果当start=4时，组合中数字的个数不足
    // (n-k)+1 + track.size() 表示当前i取到的最大数字
    for(int i = start; i <= (n-k)+1 + track.size(); i++){
        track.add(i);
        backtrack(track, n, k, i+1);
        track.removeLast();
    }
}
```

虽然只改了一句代码，但速度快了很多。

## 11. 单词搜索 [79]

题目来源：[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

### 11.1. 题目描述

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例:

```bash
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```


提示：

- board 和 word 中只包含大写和小写英文字母。
- 1 <= board.length <= 200
- 1 <= board[i].length <= 200
- 1 <= word.length <= 10^3

### 11.2. 题目分析

基本思路：找第一个匹配的字符，然后在其上下左右的四个字符中找与第二个字符匹配的字符，找到后，以次类推。上下左右字符需要首先判断是否越界、是否已经访问过。

但是，在做题的过程中，完全忽略了这是标准的回溯思想，参考之前的博客：[回溯算法](https://juliajiang7.github.io/2020/07/25/回溯算法总结/#more).

回溯法采用试错的思想，尝试分步解决一个问题。在本题中，匹配下一个字符时就有上下左右四种选择。当它发现现有的分布答辩不能得到有效的正确答案时，将取消上一步或者上几步的计算，再通过其他分步尝试得到问题答案。

在做题中有一个很大问题：忽略了回溯，即选择一条路走完发现不能匹配时，就返回了false，没有取消这一步操作。这一点要注意。

另外，这一题使用框架不太好写，还是基于回溯思想（DFS），按照正常的思路来写。

### 11.3. 代码

```java
public boolean exist(char[][] board, String word) {
    if(board.length == 0){return false;}
    int row = board.length;
    int col = board[0].length;
    for(int i = 0; i < row; i++){
        for(int j = 0; j < col; j++){
            // 找到第一个字母
            if(board[i][j] == word.charAt(0)){
                boolean[][] visited = new boolean[row][col];
                visited[i][j] = true;
                // 判断从 board[i][j] 出发，后面能否全部匹配
                if(isValid(i, j, word, 0, board, visited)){
                    return true;
                }
            }
        }
    }
    return false;
}

/**
     * 当 board[i][j] 匹配 word[k] 时，后面是否可以全部匹配
     * @param i
     * @param j
     * @param word
     * @param k
     * @param board
     * @param visited 当前已访问的字符
     * @return
     */
private boolean isValid(int i, int j, String word, int k, char[][] board, boolean[][] visited){
    int row = board.length;
    int col = board[0].length;
    if(k == word.length() - 1){return true;}
    // 上面
    boolean left = false;
    if(i - 1 >= 0 && !visited[i - 1][j] && board[i - 1][j] == word.charAt(k + 1)){
        visited[i - 1][j] = true;
        left = isValid(i - 1, j, word, k + 1, board, visited);
    }
    if(left){return left;}
    // 下面
    boolean right = false;
    if(i + 1 < row && !visited[i + 1][j] && board[i + 1][j] == word.charAt(k + 1)){
        visited[i + 1][j] = true;
        right = isValid(i + 1, j, word, k + 1, board, visited);
    }
    if(right){return right;}
    // 左边
    boolean up = false;
    if(j - 1 >= 0 && !visited[i][j - 1] && board[i][j - 1] == word.charAt(k + 1)){
        visited[i][j - 1] = true;
        up = isValid(i, j - 1, word, k + 1, board, visited);
    }
    if(up){return up;}
    // 右边
    boolean down = false;
    if(j + 1 < col && !visited[i][j + 1] && board[i][j + 1] == word.charAt(k + 1)){
        visited[i][j + 1] = true;
        down = isValid(i, j + 1, word, k + 1, board, visited);
    }
    if(down){return true;}
    // 如果上下左右都没有匹配，则取消这一步，回溯
    visited[i][j] = false;
    return false;
}
```

## 12. 子集 [78]

题目来源：[78. 子集](https://leetcode-cn.com/problems/subsets/)

### 12.1. 题目描述

![image-20200824094845802](/pictures/image-20200824094845802.png)

### 12.1. 方法一：迭代

利用数学归纳的思想：假设现在知道了规模更小的子问题，如何推导出当前问题的结果呢？即知道了 [1,2] 的子集，如何求 [1,2,3] 的子集。

可以发现，[1,2,3] 的子集包括两部分：第一部分是已知的 [1,2] 的子集；另一部分是给每一个 [1,2] 子集加上 3。发现这个规律后，即可写出下面的迭代代码：

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> res = new LinkedList<>();
    res.add(new LinkedList<>());

    for (int num : nums) {
        int size = res.size();
        for(int i = 0; i < size; i++){
            // 注意：这里需要 new 一个对象，不可以直接赋值
            List<Integer> cur = new LinkedList<>(res.get(i));
            cur.add(num);
            res.add(cur);
        }
    }

    return res;
}
```

时间复杂度：迭代次数是 N，每次迭代都遍历 res，res 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。所以，总的时间复杂度是 O(N * 2 ^ N)。

空间复杂度：如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 `res` 所需的空间，应该是 O(N*2^N)。

### 12.2. 方法二：回溯算法

参考 [这里](https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA).

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> subsetsWithDup(int[] nums) {
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track, 0);
    return res;
}

private void backtrack(int[] nums, LinkedList<Integer> track, int start) {
    res.add(new LinkedList<>(track));

    for(int i = start; i < nums.length; i++){
        track.add(nums[i]);
        backtrack(nums, track, start + 1);
        track.removeLast();
    }
}
```

## 13. 子集 II [90]

题目来源：[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

### 13.1. 题目描述

![image-20200824101740024](/pictures/image-20200824101740024.png)

### 13.2. 代码

有了上一题的基础，回溯法稍作修改即可。

为了方便的剪枝，要对序列进行排序，排序之后所有相同的数字都会放在一起。为了避免结果中出现相同的子集，兄弟节点中不能出现相同的数字，即在 ``track.add`` 之前，需要先判断，是否和已经加入的兄弟节点值相同（如果是第一个加入的子节点，不需要判断）。 代码如下：

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> subsetsWithDup(int[] nums) {
    LinkedList<Integer> track = new LinkedList<>();
    Arrays.sort(nums);
    backtrack(nums, track, 0);
    return res;
}


private void backtrack(int[] nums, LinkedList<Integer> track, int start) {
    res.add(new LinkedList<>(track));

    for(int i = start; i < nums.length; i++){
        if(i == start || nums[i] != nums[i - 1]){
            track.add(nums[i]);
            backtrack(nums, track, i + 1);
            track.removeLast();
        }
    }
}
```

## 14. 复原IP地址 [93]

题目来源：[93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

### 14.1. 题目描述

![image-20200827104857215](/pictures/image-20200827104857215.png)

### 14.2. 解法一：暴力破解（迭代）

参考 [这里](https://leetcode.wang/leetCode-93-Restore-IP-Addresses.html).

要求划分为四部分，我们直接利用三个指针将字符串强行分为4部分，遍历所有的划分，然后选取合法的解。这种解法没有超时。

```java
public List<String> restoreIpAddresses(String s) {
    List<String> res = new ArrayList<>();
    int len = s.length();
    // i < 4 保证第一部分不超过3位数
    // i < len - 2 保证剩余的字符串还能分成3部分
    for (int i = 1; i < 4 && i < len - 2; i++) {
        for (int j = i + 1; j < i + 4 && j < len - 1; j++) {
            for (int k = j + 1; k < j + 4 && k < len; k++) {
                // 保存四部分字符串
                String s1 = s.substring(0, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);
                // 判断是否合法
                if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {
                    res.add(s1 + "." + s2 + "." + s3 + "." + s4);
                }
            }
        }
    }
    return res;
}

private boolean isValid(String s) {
    if (s.length() > 3 || s.length() == 0 || (s.charAt(0) == '0' && s.length() > 1) || Integer.parseInt(s) > 255) {
        return false;
    }
    return true;
}
```

时间复杂度：如果不考虑我们调用的内部函数，Integer.parseInt，s.substring，那么就是 O（1）。因为每一层循环最多遍历 4 次。考虑的话每次调用的时间复杂度是 O（n），常数次调用，所以是 O（n）。

空间复杂度：O（1）。

### 14.3. 解法二：回溯

字符串划分问题，需要划分为4部分。直接使用回溯的思想，第一部分可能是 1 位数，然后进入递归；也可能是2位数，然后进入递归；也可能是三位数，然后进入递归。即每一次循环有三种选择。

本题虽然使用了回溯的思想，但前面总结的框架不能直接使用，下面代码是它的变形，而且本题的难点在于需要考虑的情况比较多，剪枝条件也比较多。具体剪枝的分析参考 [这里](https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/) .

```java
public List<String> restoreIpAddresses(String s) {
    List<String> res = new ArrayList<>();
    backtrack(s, 0, new StringBuilder(), res, 0);
    return res;
}

/**
     * @param s
     * @param start 字符串开始部分
     * @param track 已经划分部分
     * @param res   保存所有的解
     * @param count 当前已经加入了几部分
     */
private void backtrack(String s, int start, StringBuilder track, List<String> res, int count) {
    // 如果剩余长度大于剩下部分都取3位数的长度，剪枝
    if (s.length() - start > 3 * (4 - count)) {
        return;
    }
    // 当前刚好到达末尾
    if (start == s.length()) {
        // 当前刚好是4部分，将结果加入，否则剪枝
        if (count == 4) {
            res.add(track.substring(0, track.length() - 1));
        }
        // 当前到达末尾，但不是4部分，剪枝
        return;
    }
    // 当前超过末尾，剪枝
    // 当前未到达末尾，但有4部分，剪枝
    if (start > s.length() || count == 4) {
        return;
    }
    // 保存当前的解
    StringBuilder before = new StringBuilder(track);

    // 选择：加入一位数
    track.append(s.charAt(start) + "" + '.');
    backtrack(s, start + 1, track, res, count + 1);

    // 如果开头是0，直接结束，即选择2或3位数之前可进行剪枝
    if (s.charAt(start) == '0') {
        return;
    }

    // 做出选择：加入2位数
    if (start + 1 < s.length()) {
        // 撤销选择：恢复为之前的解
        track = new StringBuilder(before);
        track.append(s.substring(start, start + 2) + "" + '.');
        backtrack(s, start + 2, track, res, count + 1);
    }

    // 做出选择：加入3位数
    if (start + 2 < s.length()) {
        // 撤销选择：恢复为之前的解
        track = new StringBuilder(before);
        // 当选择3位数时，要判断数字大小
        int num = Integer.parseInt(s.substring(start, start + 3));
        if (0 <= num && num <= 255) {
            track.append(s.substring(start, start + 3) + "" + '.');
            backtrack(s, start + 3, track, res, count + 1);
        }
    }
}
```

## 15. 交错字符串 [97]

题目来源：[97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/)

### 15.1. 题目描述

![image-20200828102111964](/pictures/image-20200828102111964.png)

### 15.2. 方法一：回溯法

参考：[这里](https://leetcode.wang/leetCode-97-Interleaving-String.html)

感觉要用回溯解决，但是不知道怎么回溯，如何递归。

```java
public boolean isInterleave(String s1, String s2, String s3) {
    if (s1.length() + s2.length() != s3.length()) {
        return false;
    }
    return backtrack(s1, s2, s3, 0, 0, 0);
}

private boolean backtrack(String s1, String s2, String s3, int i, int j, int k) {
    // i，j,k 全部到达末尾就返回true
    if (i == s1.length() && j == s2.length() && k == s3.length()) {
        return true;
    }
    // i 到达末尾，直接移动 j 和 k 不停比较
    if (i == s1.length()) {
        while (j < s2.length()) {
            if (s2.charAt(j) != s3.charAt(k)) {
                return false;
            }
            j++;
            k++;
        }
        return true;
    }
    // j 到达末尾，直接移动 i 和 k 不停比较
    if (j == s2.length()) {
        while (i < s1.length()) {
            if (s1.charAt(i) != s3.charAt(k)) {
                return false;
            }
            i++;
            k++;
        }
        return true;
    }
    // 判断 i 和 k 指向的字符是否相等
    if (s1.charAt(i) == s3.charAt(k)) {
        // 后移 i 和 k 继续判断，如果成功直接返回true
        if (backtrack(s1, s2, s3, i + 1, j, k + 1)) {
            return true;
        }
    }
    // 移动 i 和 k 失败，尝试移动 j 和 k
    if (s2.charAt(j) == s3.charAt(k)) {
        if (backtrack(s1, s2, s3, i, j + 1, k + 1)){
            return true;
        }
    }
    // 移动 i 和 j 都失败，返回 false
    return false;
}
```

### 15.3. 方法二：回溯法的优化（备忘录）

参考：[这里](https://leetcode.wang/leetCode-97-Interleaving-String.html)

由于递归的分支，所以会造成很多重复情况的判断，所以我们用 memoization 技术，把求出的结果用 hashmap 保存起来，第二次过来的时候直接返回结果以免再次进入递归。

hashmap key 的话用字符串 i + "@" + j ，之所以中间加 "@"，是为了防止 i = 1 和 j = 22。以及 i = 12，j = 2。这样的两种情况产生的就都是 122。加上 "@" 可以区分开来。

原文中：map 的 value 取值有三个，用 1 表示 true，0 表示 false，-1 代表还未赋值。

但其实这里并不会用到三个值，因为一旦遇到的 i 和 j 满足要求，直接返回 true 即可，不需要再存入 map 中。因此，这里定义的 memo 就是一个不满足要求的 i 和 j 组合，只要 memo中含有 i 和 j 的组合，则直接返回 false。

```java
public boolean isInterleave(String s1, String s2, String s3) {
    if (s1.length() + s2.length() != s3.length()) {
        return false;
    }
    // memo 的 key 是：i + "@" + j，用@隔开是为了防止i=1,j=22时，可能出现两种组合情况：(1,22),(12,2)
    // memo 的 value 取值：-1 表示为赋值；0 表示false；1 表示true
    // value 其实用不到三个值，因为一旦当前的 i 和 j 符合要求，直接返回 true 即可。因此 memo 中只需要存不满足情况的 i 和 j 即可
    Map<String, Integer> memo = new HashMap<>();
    return backtrack2(s1, s2, s3, 0, 0, 0, memo);
}

private boolean backtrack2(String s1, String s2, String s3, int i, int j, int k, Map<String, Integer> memo) {
    String key = i + "@" + j;
    if (memo.containsKey(key)){
        return false;
    }
    if (i == s1.length() && j == s2.length() && k == s3.length()) {
        return true;
    }

    if (i == s1.length()) {
        while (j < s2.length()) {
            if (s2.charAt(j) != s3.charAt(k)) {
                memo.put(key, 0);
                return false;
            }
            j++;
            k++;
        }
        return true;
    }
    if (j == s2.length()) {
        while (i < s1.length()) {
            if (s1.charAt(i) != s3.charAt(k)) {
                memo.put(key, 0);
                return false;
            }
            i++;
            k++;
        }
        return true;
    }
    if (s1.charAt(i) == s3.charAt(k)) {
        if (backtrack2(s1, s2, s3, i + 1, j, k + 1, memo)) {
            return true;
        }
    }
    if (s2.charAt(j) == s3.charAt(k)) {
        if (backtrack2(s1, s2, s3, i, j + 1, k + 1, memo)){
            return true;
        }
    }
    memo.put(key, 0);
    return false;
}
```

### 15.4. 方法三：动态规划

参考：[这里](https://leetcode.wang/leetCode-97-Interleaving-String.html)

dp 数组定义：定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。

注意，``dp[0][0]`` 表示 s1 和 s2 都取空串，组成一个空串，则值为 true。

```java
public boolean isInterleave(String s1, String s2, String s3) {
    if (s1.length() + s2.length() != s3.length()) {
        return false;
    }
    if (s1.length() == 0 && s2.length() == 0 && s3.length() == 0) {
        return true;
    }
    int len1 = s1.length();
    int len2 = s2.length();
    // dp[i][j] = true 表示：s1[0..i) 和 s2[0..j) 组合后能构成 s3[0..i+j)
    boolean[][] dp = new boolean[len1 + 1][len2 + 1];
    // base case
    dp[0][0] = true;
    for (int i = 1; i <= len1; i++) {
        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
    }
    for (int j = 1; j <= len2; j++) {
        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
    }

    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1))
                || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
        }
    }
    return dp[len1][len2];
}
```

## 16. 路径总和 II [113]

题目来源：[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

### 16.1. 题目描述

![image-20200903093332125](/pictures/image-20200903093332125.png)

### 16.2. 代码

典型的回溯思路：采用试错的思想，尝试分步去解决问题，在分步解决问题的过程中，当通过尝试发现现有的分布答案不能得到有效的正确答案时，取消上一步甚至是上几步的计算，再通过其他的分布尝试寻找问题的答案。

```java
List<List<Integer>> res = new LinkedList<>();

public List<List<Integer>> pathSum(TreeNode root, int sum) {
    LinkedList<Integer> track = new LinkedList<>();
    if (root == null) {
        return res;
    }
    track.add(root.val);
    backtrack(root, sum, track, root.val);
    return res;
}

private void backtrack(TreeNode root, int sum, LinkedList<Integer> track, int tmp) {
    if (tmp == sum && root.left == null && root.right == null) {
        res.add(new LinkedList<>(track));
    }

    if (root.left != null) {
        // 做出选择：左子树
        track.add(root.left.val);
        backtrack(root.left, sum, track, tmp + root.left.val);
        // 撤销选择
        track.removeLast();
    }

    if (root.right != null) {
        track.add(root.right.val);
        backtrack(root.right, sum, track, tmp + root.right.val);
        track.removeLast();
    }
}
```

## 17. 参考引用

1. [Wikipedia](https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95)
2. https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban
3. https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
4. https://leetcode.wang/leetCode-77-Combinations.html
5. https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA
6. https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/
7. https://leetcode.wang/leetCode-97-Interleaving-String.html