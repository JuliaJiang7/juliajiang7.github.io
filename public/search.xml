<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树总结</title>
    <url>/2020/08/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文介绍了什么是二叉树，同时解决了部分LeetCode上二叉树相关的题目，这部分会持续更新。</p>
<h2 id="1-什么是二叉树？"><a href="#1-什么是二叉树？" class="headerlink" title="1. 什么是二叉树？"></a>1. 什么是二叉树？</h2><p><a href="https://zh.wikipedia.org/wiki/二叉树" target="_blank" rel="noopener">维基定义</a>：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p>
<p>二叉树的第 <code>i</code> 层至多拥有 2<sup>i-1</sup> 个节点；深度为 k 的二叉树至多总共有 2<sup>k</sup>-1 个节点（定义根节点所在深度 k<sub>0</sub>=0}），而总计拥有节点数符合的，称为 <strong>满二叉树</strong>；深度为 k 有 n 个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度 k 的满二叉树，序号为1到 n 的节点一对一对应时，称为 <strong>完全二叉树</strong>。对任何一棵非空的二叉树T，如果其叶片（终端节点）数为 n<sub>0</sub>，分支度为2的节点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1。</p>
<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p>
<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。</p>
<a id="more"></a>

<h2 id="2-二叉树相关的题目列表"><a href="#2-二叉树相关的题目列表" class="headerlink" title="2. 二叉树相关的题目列表"></a>2. 二叉树相关的题目列表</h2><table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">94</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">144</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">145</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">102</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">107</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层次遍历 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">104</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">100</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">101</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">103</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">105</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">106</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">98</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="3-二叉树的中序遍历-94"><a href="#3-二叉树的中序遍历-94" class="headerlink" title="3. 二叉树的中序遍历 [94]"></a>3. 二叉树的中序遍历 [94]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>


<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="3-2-题目分析"><a href="#3-2-题目分析" class="headerlink" title="3.2 题目分析"></a>3.2 题目分析</h3><p>分析参考 <a href="https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html" target="_blank" rel="noopener">这里</a>.</p>
<p>中序遍历使用两种方法：递归和迭代。</p>
<h3 id="3-3-方法一：递归"><a href="#3-3-方法一：递归" class="headerlink" title="3.3 方法一：递归"></a>3.3 方法一：递归</h3><p>时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-方法二：栈"><a href="#3-4-方法二：栈" class="headerlink" title="3.4 方法二：栈"></a>3.4 方法二：栈</h3><p>时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。</p>
<p>利用栈模拟递归。递归压栈过程，就是保存现场，保存当前的变量。在方法一中，当前有用的变量就是 node，所以我们用栈把每一次的 node 保存起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 程序中尽量避免使用Stack类，太古老，性能差，使用ArrayDeque代替</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 节点不为空就一直压栈</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="comment">// 考虑左子树</span></span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点为空，就出栈</span></span><br><span class="line">        curr = stack.pop();</span><br><span class="line">        res.add(curr.val);</span><br><span class="line">        <span class="comment">// 考虑右子树</span></span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二叉树的前序遍历-144"><a href="#4-二叉树的前序遍历-144" class="headerlink" title="4. 二叉树的前序遍历 [144]"></a>4. 二叉树的前序遍历 [144]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p>
<h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h3><p>给定一个二叉树，返回它的 前序 遍历。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>


<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="4-2-题目分析"><a href="#4-2-题目分析" class="headerlink" title="4.2 题目分析"></a>4.2 题目分析</h3><p>中序遍历的迭代法也使用栈实现。</p>
<h3 id="4-3-方法一：递归"><a href="#4-3-方法一：递归" class="headerlink" title="4.3 方法一：递归"></a>4.3 方法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    res.add(node.val);</span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-方法二：栈"><a href="#4-4-方法二：栈" class="headerlink" title="4.4 方法二：栈"></a>4.4 方法二：栈</h3><p>与中序遍历的迭代方法相比，前序遍历只需要将访问的位置改到根节点处即可，其他代码不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 在此处访问节点</span></span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.poll();</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-二叉树的后序遍历-145"><a href="#5-二叉树的后序遍历-145" class="headerlink" title="5. 二叉树的后序遍历 [145]"></a>5. 二叉树的后序遍历 [145]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p>
<h3 id="5-1-题目描述"><a href="#5-1-题目描述" class="headerlink" title="5.1 题目描述"></a>5.1 题目描述</h3><p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>


<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="5-2-方法一：递归"><a href="#5-2-方法一：递归" class="headerlink" title="5.2 方法一：递归"></a>5.2 方法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-方法二：栈"><a href="#5-3-方法二：栈" class="headerlink" title="5.3 方法二：栈"></a>5.3 方法二：栈</h3><p>相比于前序、中序的栈解法，后序遍历的栈解法会难一些。</p>
<p>原因在于，当遍历完某个根节点的左子树，回到根节点时，中序、先序可以把当前根节点从栈中弹出，然后转到右子树。举例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>当遍历完 2,4,5 时，回到 1 之后就可以把 1 弹出，然后通过 1 到达右子树继续遍历。</p>
<p>而对于后序遍历，当我们到达 1 时，并不能立即把 1 弹出，因为遍历完右子树，还需要将根节点加入到 res 中。</p>
<p>因此，我们就需要判断是从左子树到的根节点，还是从右子树到的根节点。</p>
<p>如果是从左子树到的根节点，此时应该转到右子树。如果从右子树到的根节点，那么就可以弹出当前节点，并存储到 res 中。</p>
<p>当然，如果从左子树到的根节点，此时右子树为 null, 也需要把根节点弹出，并加入到 res 中。</p>
<p>基于上述分析，我们可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="comment">// 记录上一个遍历的节点</span></span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前根节点</span></span><br><span class="line">        TreeNode temp = stack.peek();</span><br><span class="line">        <span class="comment">// 是否变到右子树</span></span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span> &amp;&amp; temp.right != pre)&#123;</span><br><span class="line">            curr = temp.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="comment">// 记录上一个遍历的节点</span></span><br><span class="line">            pre = temp;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-二叉树的层序遍历-102"><a href="#6-二叉树的层序遍历-102" class="headerlink" title="6. 二叉树的层序遍历 [102]"></a>6. 二叉树的层序遍历 [102]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></p>
<h3 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1 题目描述"></a>6.1 题目描述</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">  / \</span><br><span class="line"> 9  20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="6-2-方法一：递归（DFS）"><a href="#6-2-方法一：递归（DFS）" class="headerlink" title="6.2 方法一：递归（DFS）"></a>6.2 方法一：递归（DFS）</h3><p>由于本题对于层序遍历的结果要求为 <code>List&lt;List&lt;Integer&gt;&gt;</code>, 要把每一层的元素放在一个单独的列表中，因此在递归时需要传入当前层数，如果是新的一层，创建一个新的 <code>List</code> , 存储这一层的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> res;&#125;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.size() == level)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    res.get(level).add(node.val);</span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-方法二：队列（BFS）"><a href="#6-3-方法二：队列（BFS）" class="headerlink" title="6.3 方法二：队列（BFS）"></a>6.3 方法二：队列（BFS）</h3><p>依旧是本题对于返回结果的要求，每一层需要单独处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 当前层列表</span></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前队列中的元素个数，即就是当前层的节点数</span></span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">        <span class="comment">// levelNum 必须在外面定义，因为 queue 的大小在不停的变化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">            <span class="comment">// 移除队列第一个元素</span></span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;queue.add(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;queue.add(node.right);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-二叉树的层次遍历-II-107"><a href="#7-二叉树的层次遍历-II-107" class="headerlink" title="7. 二叉树的层次遍历 II [107]"></a>7. 二叉树的层次遍历 II [107]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></p>
<h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">  / \</span><br><span class="line"> 9  20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>

<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="7-2-方法一：递归"><a href="#7-2-方法一：递归" class="headerlink" title="7.2 方法一：递归"></a>7.2 方法一：递归</h3><p>本题的结果是上一题结果的反序，只需要在上一题添加列表时，在表头插入，以此得到反序序列即可。如下代码，改变三处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用链表存储，在表头插入效率更高</span></span><br><span class="line">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> res;&#125;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.size() == level)&#123;</span><br><span class="line">        <span class="comment">// 在链表表头插入，得到反序序列</span></span><br><span class="line">        res.addFirst(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入当前值，注意下标</span></span><br><span class="line">    res.get(res.size() - level - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-方法二：队列"><a href="#7-3-方法二：队列" class="headerlink" title="7.3 方法二：队列"></a>7.3 方法二：队列</h3><p>与上一题区别：使用链表存储，插入时从表头插入，得到反序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// 使用链表，在表头插入效率更高</span></span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;queue.add(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;queue.add(node.right);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在表头插入，得到反序结果</span></span><br><span class="line">        res.addFirst(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-参考引用"><a href="#8-参考引用" class="headerlink" title="8. 参考引用"></a>8. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/二叉树" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html</a></li>
<li><a href="https://leetcode.wang/leetcode-102-Binary-Tree-Level-Order-Traversal.html" target="_blank" rel="noopener">https://leetcode.wang/leetcode-102-Binary-Tree-Level-Order-Traversal.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找总结</title>
    <url>/2020/08/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文介绍了二分查找，主要总结了三种二分查找的框架，分别是：基本的二分查找、查找左侧边界、查找右侧边界。同时，解决了部分LeetCode上二分查找相关的题目，这部分会持续更新~</p>
<h2 id="1-什么是二分查找？"><a href="#1-什么是二分查找？" class="headerlink" title="1. 什么是二分查找？"></a>1. 什么是二分查找？</h2><p><a href="https://zh.wikipedia.org/wiki/二分搜尋演算法" target="_blank" rel="noopener">二分查找</a>：在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p>二分查找算法在情况下的复杂度是对数时间，进行O(log n)次比较操作。二分查找算法使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。</p>
<a id="more"></a>

<h2 id="2-基本的二分查找：二分查找-704"><a href="#2-基本的二分查找：二分查找-704" class="headerlink" title="2. 基本的二分查找：二分查找 [704]"></a>2. 基本的二分查找：二分查找 [704]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p>
<h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1. 题目描述"></a>2.1. 题目描述</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h3 id="2-2-题目分析"><a href="#2-2-题目分析" class="headerlink" title="2.2. 题目分析"></a>2.2. 题目分析</h3><p>基本二分查找。</p>
<h3 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3. 代码"></a>2.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-在排序数组中查找元素的第一个和最后一个位置-34"><a href="#3-在排序数组中查找元素的第一个和最后一个位置-34" class="headerlink" title="3. 在排序数组中查找元素的第一个和最后一个位置 [34]"></a>3. 在排序数组中查找元素的第一个和最后一个位置 [34]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1. 题目描述"></a>3.1. 题目描述</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-题目分析"><a href="#3-2-题目分析" class="headerlink" title="3.2. 题目分析"></a>3.2. 题目分析</h3><p>本题求给出有序序列（有重复元素）的target左侧、右侧边界，这需要在基本的二分查找代码上做一些修改。</p>
<h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3. 代码"></a>3.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    res[<span class="number">0</span>] = leftBound(nums, target);</span><br><span class="line">    res[<span class="number">1</span>] = rightBound(nums, target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找左侧边界</span></span><br><span class="line"><span class="comment">     * 用 left 保存找到的左侧边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 不返回，收缩右侧边界，限制左侧边界left的取值范围</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找右侧边界</span></span><br><span class="line"><span class="comment">     * 用 right 保存找到的右侧边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 改变一：收缩左侧边界，限制右侧边界right的取值范围</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变二：检查right的越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二分查找总结"><a href="#4-二分查找总结" class="headerlink" title="4. 二分查找总结"></a>4. 二分查找总结</h2><p>可以发现，二分查找的思路很简单，但是对于 mid 是加一还是减一，while 中是 &lt;= 还是 = 是比较容易混的。上面两题中，我们都把搜索区间定义为左右为闭，这样便于统一记忆。当然，也有代码定义为左闭右开，left 和 right的更新又是另一种套路了，这里不做讨论。下面，基于上面两题的做法，对二分查找三种不同用法做出总结：</p>
<h3 id="4-1-基本的二分查找"><a href="#4-1-基本的二分查找" class="headerlink" title="4.1. 基本的二分查找"></a>4.1. 基本的二分查找</h3><p>基本的二分查找框架，即序列元素不重复，查找 target，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 找到target，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-查找左侧边界"><a href="#4-2-查找左侧边界" class="headerlink" title="4.2. 查找左侧边界"></a>4.2. 查找左侧边界</h3><p>序列元素可能重复，查找 target 左边界，在基本代码的基础上，做了三处修改，代码如下：</p>
<p>代码理解：在查找左边界时，使用 left 存找到的左边界，如果 <code>nums[mid] &lt; target</code> ，left 向后移一位，其他情况下 left 均不动，则最终 left 的取值只能有三种情况：1.第一个等于 target 的元素；2. 大于 target 的元素（因为序列中没有 target）；3. left 越界（因为序列中的所有元素均小于 target）。这也是为什么使用 left 存储左边界并最终返回的原因。right 存能取到的左边界的最大值，不断的收缩 left 的取值范围，直到 <code>left &gt; right</code> 结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 修改一：不返回，收缩右侧边界，限制左侧边界left的取值范围</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改二：检查left的越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left == nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改三：返回left</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-查找右侧边界"><a href="#4-3-查找右侧边界" class="headerlink" title="4.3. 查找右侧边界"></a>4.3. 查找右侧边界</h3><p>序列元素可能重复，查找 target 右边界，在基本代码的基础上，做了三处修改，代码如下：</p>
<p>代码理解：在查找右边界时，用 right 存储找到的右边界。当 <code>nums[mid] &gt; target</code> 时，更新 right 的值，right 前移一位，其他情况下 right 值均不变。因此，最终 while 循环结束后，right 的取值有三种：1. 最后一个等于 target 的元素，即右边界；2. 小于target 的元素（因为序列中没有 target 元素）；3. target 越界（因为序列中所有元素均大于 target）。用 left 存储右边界能取到的最小值，while 中不断更新 left 值，缩小右边界的取值范围，直到 <code>left &gt; right</code> 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 修改一：不返回，收缩左侧边界，限制右侧边界left的取值范围</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改二：检查right的越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改三：返回right</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用二分查找的题目列表"><a href="#5-使用二分查找的题目列表" class="headerlink" title="5. 使用二分查找的题目列表"></a>5. 使用二分查找的题目列表</h2><p>本文中使用二分查找解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">704</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">二分查找</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">300</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">74</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="6-参考引用"><a href="#6-参考引用" class="headerlink" title="6. 参考引用"></a>6. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/二分搜尋演算法" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划总结</title>
    <url>/2020/07/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要介绍了动态规划的概念、解题框架，并以斐波那契数列、零钱兑换为例，进一步说明动态规划如何运用和理解。另外，本文还解决了LeetCode中部分使用动态规划思想的题目，这部分会持续更新。</p>
<h2 id="1-什么是动态规划？"><a href="#1-什么是动态规划？" class="headerlink" title="1. 什么是动态规划？"></a>1. 什么是动态规划？</h2><p><a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a>（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p>
<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<a id="more"></a>

<h3 id="1-1-适用情况"><a href="#1-1-适用情况" class="headerlink" title="1.1 适用情况"></a>1.1 适用情况</h3><ol>
<li>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
<li>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</li>
</ol>
<h2 id="2-动态规划解题框架"><a href="#2-动态规划解题框架" class="headerlink" title="2. 动态规划解题框架"></a>2. 动态规划解题框架</h2><p>这一节参考 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">这里</a> 给出一些对于动态规划的理解和解体框架。</p>
<p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等。</p>
<p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。</p>
<p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p>
<p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>下文中的斐波那契数列可以帮助理解动态规划问题，零钱兑换问题使用总结的框架进行流程化求解。</p>
<h2 id="3-以斐波那契数列-509-为例"><a href="#3-以斐波那契数列-509-为例" class="headerlink" title="3. 以斐波那契数列 [509] 为例"></a>3. 以斐波那契数列 [509] 为例</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 N，计算 F(N)。</p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p>0 ≤ N ≤ 30</p>
<h3 id="3-2-方法一：暴力递归"><a href="#3-2-方法一：暴力递归" class="headerlink" title="3.2 方法一：暴力递归"></a>3.2 方法一：暴力递归</h3><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，画出的递归树如下：</p>
<img src="/pictures/1-1595902107828.jpg" alt="img" style="zoom:33%;" />

<p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p>
<p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<h3 id="3-3-方法二：带备忘录的递归解法"><a href="#3-3-方法二：带备忘录的递归解法" class="headerlink" title="3.3 方法二：带备忘录的递归解法"></a>3.3 方法二：带备忘录的递归解法</h3><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经计算过</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p>
<p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p>
<p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<h3 id="3-4-方法三：动态规划"><a href="#3-4-方法三：动态规划" class="headerlink" title="3.4 方法三：动态规划"></a>3.4 方法三：动态规划</h3><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<img src="/pictures/fib.png" alt="img" style="zoom: 67%;" />

<p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib3</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = pre + curr;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<h2 id="4-框架求解零钱兑换-322"><a href="#4-框架求解零钱兑换-322" class="headerlink" title="4. 框架求解零钱兑换 [322]"></a>4. 框架求解零钱兑换 [322]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p>
<h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>


<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<h3 id="4-2-题目分析与代码"><a href="#4-2-题目分析与代码" class="headerlink" title="4.2 题目分析与代码"></a>4.2 题目分析与代码</h3><p>分析参考 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie#er-cou-ling-qian-wen-ti" target="_blank" rel="noopener">这里</a> , 使用上文中总结的动态规划框架。</p>
<p>首先，这是一个动态规划问题。满足三个条件：</p>
<ol>
<li><p>最优子结构。即问题的最优解所包含的子问题的解也是最优的，且子问题间必须相互独立。什么叫做相互独立？我用一个直观的例子来讲解。</p>
<p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制约，是互相独立的。</p>
</li>
<li><p>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p>
</li>
<li><p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。</p>
</li>
</ol>
<p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p>
<p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p>
<p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p>
<p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。<em>目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。</em> 所以说 <strong>所有硬币的面值</strong> ，就是你的「选择」。</p>
<p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p>
<p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p>
<h4 id="4-2-1-先使用暴力递归"><a href="#4-2-1-先使用暴力递归" class="headerlink" title="4.2.1 先使用暴力递归"></a>4.2.1 先使用暴力递归</h4><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>据此，我们可以得出状态转移方程如下图，以上解法属于暴力递归解法。</p>
<img src="/pictures/coin.png" alt="img" style="zoom:67%;" />

<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<h4 id="4-2-2-带备忘录的递归解法，消除重叠子问题"><a href="#4-2-2-带备忘录的递归解法，消除重叠子问题" class="headerlink" title="4.2.2 带备忘录的递归解法，消除重叠子问题"></a>4.2.2 带备忘录的递归解法，消除重叠子问题</h4><p>显然，上述解法中存在重叠子问题，比如<code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p>
<img src="/pictures/5-1595987693352.jpg" alt="img" style="zoom: 33%;" />

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<h4 id="4-2-3-动态规划，自底向上"><a href="#4-2-3-动态规划，自底向上" class="headerlink" title="4.2.3 动态规划，自底向上"></a>4.2.3 动态规划，自底向上</h4><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p>
<p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i] = n 表示：当目标金额为 i 时，至少需要 n 枚硬币</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化dp数组，初始值为 amount+1, 因为dp 数组最大值取到 amount</span></span><br><span class="line">    Arrays.fill(dp, amount+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">        <span class="comment">// 内层for求所有子问题的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (j - coin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = dp[j] &lt; dp[j - coin] + <span class="number">1</span> ? dp[j] : dp[j - coin] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount+<span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<h2 id="5-动态规划总结"><a href="#5-动态规划总结" class="headerlink" title="5. 动态规划总结"></a>5. 动态规划总结</h2><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p>
<p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p>
<p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p>
<p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p>
<p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>
<p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p>
<h2 id="6-使用动态规划的题目列表"><a href="#6-使用动态规划的题目列表" class="headerlink" title="6. 使用动态规划的题目列表"></a>6. 使用动态规划的题目列表</h2><p>本文中使用动态规划解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">509</td>
<td align="center"><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">322</td>
<td align="center"><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">300</td>
<td align="center"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1143</td>
<td align="center"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">72</td>
<td align="center"><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">正则表达式匹配</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">62</td>
<td align="center"><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">63</td>
<td align="center"><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现 strStr()</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">64</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="7-例题：最长上升子序列-300"><a href="#7-例题：最长上升子序列-300" class="headerlink" title="7. 例题：最长上升子序列 [300]"></a>7. 例题：最长上升子序列 [300]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></p>
<h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。</p>
<h3 id="7-2-题目分析"><a href="#7-2-题目分析" class="headerlink" title="7.2 题目分析"></a>7.2 题目分析</h3><p>本题分析参考 <a href="https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g" target="_blank" rel="noopener">这里</a> .</p>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p>
<h3 id="7-3-方法一：动态规划（如何找到状态转移关系）"><a href="#7-3-方法一：动态规划（如何找到状态转移关系）" class="headerlink" title="7.3 方法一：动态规划（如何找到状态转移关系）"></a>7.3 方法一：动态规划（如何找到状态转移关系）</h3><p>动态规划的难点本来就在于寻找正确的状态转移方程，本文就借助经典的「最长递增子序列问题」来讲一讲设计动态规划的通用技巧：<strong>数学归纳思想</strong>。</p>
<p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么<strong>我们先假设这个结论在 k 时成立，然后根据这个假设，想办法推导证明出 <code>k=n</code> 的时候此结论也成立</strong>。如果能够证明出来，那么就说明这个结论对于 <code>k</code> 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <code>dp[0...i-1]</code> 都已经被算出来了，然后问自己：怎么通过这些结果算出 <code>dp[i]</code>？</p>
<p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 <code>dp[i]</code> 的值到底代表着什么？</p>
<p><strong>我们的定义是这样的：<code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。</strong></p>
<p>PS：<strong>为什么这样定义呢？</strong> 这是解决子序列问题的一个套路，后文动态规划之子序列问题解题模板 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 <code>dp</code> 数组的定义方法也就那几种。</p>
<p>反过来想，如果 <code>dp[i]</code> 表示 <code>nums[0...i]</code> 这个数组中的最长递增子序列的长度，当求得 <code>dp[i]</code> 时，想要求出 <code>dp[i+1]</code> 是不行的，因为递增子序列是从数组中选出的，知道 <code>dp[i]</code> 并不能确定当前选择的是哪几个数字，当然也不知道选出的递增子序列最后一位，这样是没法推出 <code>dp[i+1]</code> 的。但如果我们定义 <code>dp[i]</code> 表示以<code>nums[i]</code> 结尾的最长递增子序列的长度，就可以明确知道选出的递增子序列的最后一位，从而推出 <code>dp[i]</code> . 只有这样定义才能将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程。</p>
<p>根据这个定义，我们就可以推出 base case：<code>dp[i]</code> 初始值为 1，因为以 <code>nums[i]</code> 结尾的最长递增子序列起码要包含它自己。</p>
<p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p>
<p>那么我们应该怎么设计算法逻辑来正确计算每个 <code>dp[i]</code> 呢？</p>
<p>这就是动态规划的重头戏了，要思考如何设计算法逻辑进行状态转移，才能正确运行呢？这里就可以使用数学归纳的思想：</p>
<p><strong>假设我们已经知道了 <code>dp[0..4]</code> 的所有结果，我们如何通过这些已知结果推出 <code>dp[5]</code> 呢</strong>？</p>
<p>根据刚才我们对 <code>dp</code> 数组的定义，现在想求 <code>dp[5]</code> 的值，也就是想求以 <code>nums[5]</code> 为结尾的最长递增子序列。</p>
<p><strong><code>nums[5] = 3</code>，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一</strong>。</p>
<p>显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 <code>dp[5]</code> 的值即可。</p>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//dp[i] = n 表示：以 nums[i] 这个数字结尾的最长上升子序列的长度（想不到）</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//初始化，最长上升子序列最少为数字本身，故初始化为1</span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下如何找到动态规划的状态转移关系：</p>
<p><strong>1、</strong>明确 <code>dp</code> 数组所存数据的含义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p><strong>2、</strong>根据 <code>dp</code> 数组的定义，运用数学归纳法的思想，假设 <code>dp[0...i-1]</code> 都已知，想办法求出 <code>dp[i]</code>，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 <code>dp</code> 数组的定义不够恰当，需要重新定义 <code>dp</code> 数组的含义；或者可能是 <code>dp</code> 数组存储的信息还不够，不足以推出下一步的答案，需要把 <code>dp</code> 数组扩大成二维数组甚至三维数组。</p>
<h3 id="7-4-方法二：二分查找"><a href="#7-4-方法二：二分查找" class="headerlink" title="7.4 方法二：二分查找"></a>7.4 方法二：二分查找</h3><p>详解请看：<a href="https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g##" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g##</a></p>
<p>这个解法的时间复杂度为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 牌初始堆数定义为0</span></span><br><span class="line">    <span class="keyword">int</span> piles = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 要处理的扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> poker = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//*********** 二分查找：搜索左侧边界 ***************/</span></span><br><span class="line">        <span class="comment">// piles 表示堆数，即就是数组的长度；如果写成 right = piles + 1, 当 nums=[0] 时返回 0， 正确结果是 1</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = piles;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(top[mid] == poker)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(top[mid] &gt; poker)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(top[mid] &lt; poker)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 牌比每一个都大，则新建一个堆</span></span><br><span class="line">        <span class="keyword">if</span>(left == piles)&#123;</span><br><span class="line">            piles++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 牌比每一个都小、或者找到合适位置，放入 top 数组即可</span></span><br><span class="line">        top[left] = poker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> piles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-例题：最长公共子序列-1143"><a href="#8-例题：最长公共子序列-1143" class="headerlink" title="8. 例题：最长公共子序列 [1143]"></a>8. 例题：最长公共子序列 [1143]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p>
<h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>若这两个字符串没有公共子序列，则返回 0。 </p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abcde"</span>, text2 = <span class="string">"ace"</span> </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 <span class="string">"ace"</span>，它的长度为 3。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abc"</span>, text2 = <span class="string">"def"</span></span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>


<p>提示:</p>
<p>1 &lt;= text1.length &lt;= 1000<br>1 &lt;= text2.length &lt;= 1000<br>输入的字符串只含有小写英文字符。</p>
<h3 id="8-2-题目分析"><a href="#8-2-题目分析" class="headerlink" title="8.2 题目分析"></a>8.2 题目分析</h3><p>最长公共子序列（Longest Common Subsequence，简称 LCS）是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。</p>
<p>详细分析参考：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie</a></p>
<h3 id="8-3-代码"><a href="#8-3-代码" class="headerlink" title="8.3 代码"></a>8.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="comment">// 让 text1,text2 的索引从 1 开始</span></span><br><span class="line">    <span class="comment">// dp[i][j] = n 表示：对于 text1[1...i] 和 text2[1...j] 的最长公共子序列为 n</span></span><br><span class="line">    <span class="comment">//base case 是：dp[0][..] 和 dp[..][0] 初始化为0</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-例题：最大子序列和-53"><a href="#9-例题：最大子序列和-53" class="headerlink" title="9. 例题：最大子序列和 [53]"></a>9. 例题：最大子序列和 [53]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>


<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="9-2-题目分析"><a href="#9-2-题目分析" class="headerlink" title="9.2 题目分析"></a>9.2 题目分析</h3><p>参考：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu</a></p>
<p>解决这个问题需要动态规划技巧，但是 <code>dp</code> 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 <code>dp</code> 数组：</p>
<p><strong><code>nums[0..i]</code></strong> <strong>中的「最大的子数组和」为</strong> <strong><code>dp[i]</code></strong>。</p>
<p>如果这样定义的话，整个 <code>nums</code> 数组的「最大子数组和」就是 <code>dp[n-1]</code>。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 <code>dp[i-1]</code>，如何推导出 <code>dp[i]</code> 呢？利用数学归纳法，你能用 <code>dp[i]</code> 推出 <code>dp[i+1]</code> 吗？</p>
<p><strong>实际上是不行的，因为子数组一定是连续的，按照我们当前</strong> <strong><code>dp</code></strong> <strong>数组定义，并不能保证</strong> <strong><code>nums[0..i]</code></strong> <strong>中的最大子数组与</strong> <strong><code>nums[i+1]</code></strong> <strong>是相邻的</strong>，也就没办法从 <code>dp[i]</code> 推导出 <code>dp[i+1]</code>。</p>
<p>所以说我们这样定义 <code>dp</code> 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 <code>dp</code> 数组的含义：</p>
<p><strong>以</strong> <strong><code>nums[i]</code></strong> <strong>为结尾的「最大子数组和」为</strong> <strong><code>dp[i]</code></strong>。</p>
<p>这种定义之下，想得到整个 <code>nums</code> 数组的「最大子数组和」，不能直接返回 <code>dp[n-1]</code>，而需要遍历整个 <code>dp</code> 数组。</p>
<p>虽然说动态规划推状态转移方程确实比较玄学，但大部分还是有些规律可循的。</p>
<p>这道「最大子数组和」就和「最长递增子序列」非常类似，<code>dp</code> 数组的定义是「以 <code>nums[i]</code> 为结尾的最大子数组和/最长递增子序列为 <code>dp[i]</code>」。因为只有这样定义才能将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程。</p>
<h3 id="9-3-代码"><a href="#9-3-代码" class="headerlink" title="9.3 代码"></a>9.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// dp[i] = x 表示以 nums[i] 结尾的最大子序列和为x</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-例题：编辑距离-72"><a href="#10-例题：编辑距离-72" class="headerlink" title="10. 例题：编辑距离 [72]"></a>10. 例题：编辑距离 [72]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p>
<h3 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 <span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="10-2-题目分析"><a href="#10-2-题目分析" class="headerlink" title="10.2 题目分析"></a>10.2 题目分析</h3><p>dp 问题自底向上求解，定义 dp 数组：<code>dp[i][j] = n</code> 表示：<code>word1[1..i]</code> 和 <code>word2[1..j]</code> 的最小编辑距离为 n，注意 word1 和 word2 的下标从1开始。</p>
<p>base case：当 i=0 或者 j=0 时，属于base case。</p>
<p>状态：距离。</p>
<p>选择：有三种选择，即删除、替换、插入，选出距离最小的。做出每一种选择后，使用前面求出 dp 数组的值。比如如果选择删除，则 <code>dp[i][j] = dp[i-1][j] + 1</code> ；如果选择替换，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>；如果选择插入，则<code>dp[i][j] = dp[i][j-1] + 1</code>入，当插入时应该注意，不能在 <code>word1[i]</code> 之前插入，因为在前面插入后，没法使用已经求出的 dp 数组的值，而是在 <code>word1[i]</code> 的后面插入。</p>
<p>状态转移方程：如果字符相等，跳过；否则在删除、替换、插入中选择一种。</p>
<h3 id="10-3-代码"><a href="#10-3-代码" class="headerlink" title="10.3 代码"></a>10.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">    <span class="comment">//word1 和 word2 的下标从 1 开始</span></span><br><span class="line">    <span class="comment">//dp[i][j] = n 表示：word1[1..i] 和 word2[1..j] 的最小编辑距离为 n</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//三种情况：插入、删除、替换</span></span><br><span class="line">                dp[i][j] = min(dp[i][j-<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.min(a,b),c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-例题：正则表达式匹配-10"><a href="#11-例题：正则表达式匹配-10" class="headerlink" title="11. 例题：正则表达式匹配 [10]"></a>11. 例题：正则表达式匹配 [10]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p>
<h3 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1 题目描述"></a>11.1 题目描述</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">'.'</span> 匹配任意单个字符</span><br><span class="line"><span class="string">'*'</span> 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>


<p>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="string">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">".*"</span> 表示可匹配零个或多个（<span class="string">'*'</span>）任意字符（<span class="string">'.'</span>）。</span><br></pre></td></tr></table></figure>

<h3 id="11-2-题目分析"><a href="#11-2-题目分析" class="headerlink" title="11.2 题目分析"></a>11.2 题目分析</h3><p>两个字符串比较的动态规划问题。<code>dp[i][j]</code> 表示 <code>s[i-1]</code> 和 <code>p[i-1]</code> 是否可以匹配。</p>
<p>base case：<code>dp[0][0] = true</code>， 但这还不够，字符串 “” 和 “a*” 也是匹配的。</p>
<p>状态：是否可以匹配。</p>
<p>选择：字符串 s 和 p 各前进一位。</p>
<p>状态转换：见代码。</p>
<h3 id="11-3-代码"><a href="#11-3-代码" class="headerlink" title="11.3 代码"></a>11.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = p.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp 数组中 字符串下标从 1 开始，索引 0 存储空字符</span></span><br><span class="line">    <span class="comment">//dp[i][j] = true 表示：s[0..(i-1)] p[0..(j-1)] 可以匹配</span></span><br><span class="line">    <span class="comment">//base case：dp[..][0] 初始化为 0, 不存在可以匹配的可能</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//base case: dp[0][..] 初始化，如果出现 * 则可以消去上一个字符，且 上上一个字符对应 dp 值为 true，则当前 dp 值为true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++)&#123;</span><br><span class="line">        <span class="comment">//j-1</span></span><br><span class="line">        <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//j+1</span></span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">            <span class="comment">//如果元素匹配或者为任意元素</span></span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'.'</span> || s.charAt(i) == p.charAt(j))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="comment">//如果前一个元素不匹配，则消去这两个元素</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * 如果前一个元素匹配，存在三种情况：</span></span><br><span class="line"><span class="comment">                        * 重复前一个字符多次（abbbb ab*）dp[i + 1][j + 1] = dp[i][j + 1]</span></span><br><span class="line"><span class="comment">                        * 重复前一个字符一次（ab ab*）dp[i + 1][j + 1] = dp[i + 1][j]</span></span><br><span class="line"><span class="comment">                        * 重复前一个字符零次（a ab*）dp[i + 1][j + 1] = dp[i + 1][j - 1]</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br></pre></td></tr></table></figure>

<h2 id="12-例题：通配符匹配-44"><a href="#12-例题：通配符匹配-44" class="headerlink" title="12. 例题：通配符匹配 [44]"></a>12. 例题：通配符匹配 [44]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></p>
<h3 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1 题目描述"></a>12.1 题目描述</h3><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">'?'</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">'*'</span> 可以匹配任意字符串（包括空字符串）。</span><br><span class="line">两个字符串完全匹配才算匹配成功。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<p>输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">'*'</span> 可以匹配任意字符串。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"cb"</span></span><br><span class="line">p = <span class="string">"?a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">'?'</span> 可以匹配 <span class="string">'c'</span>, 但第二个 <span class="string">'a'</span> 无法匹配 <span class="string">'b'</span>。</span><br></pre></td></tr></table></figure>

<p>示例 4:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"adceb"</span></span><br><span class="line">p = <span class="string">"*a*b"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 第一个 <span class="string">'*'</span> 可以匹配空字符串, 第二个 <span class="string">'*'</span> 可以匹配字符串 <span class="string">"dce"</span>.</span><br></pre></td></tr></table></figure>

<p>示例 5:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"acdcb"</span></span><br><span class="line">p = <span class="string">"a*c?b"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>PS：? 不可以匹配空字符串。</p>
<h3 id="12-2-题目分析"><a href="#12-2-题目分析" class="headerlink" title="12.2 题目分析"></a>12.2 题目分析</h3><p>两个字符串比较的动态规划问题。</p>
<p>本体类似于上一题，但我在考虑问题时始终不能跳出问题本身，使用动态规划的思想，而是一再考虑可能出现的不同情况，特别是出现 * 时。例如字符串 “abc” 和 “a*” , 当 p 中出现了 * 时，有两种处理方式：</p>
<ol>
<li>把 * 当做一个空字符串，那么 <code>dp[i + 1][j + 1] = dp[i + 1][j]</code></li>
<li><code>*</code> 匹配任意字符串，那么 <code>dp[i + 1][j + 1] = dp[i][j + 1]</code></li>
</ol>
<p>要注意理解，dp 问题注重的是当前状态的转化，即只考虑当前这一位，并把这个问题转化为更小问题的答案。</p>
<h3 id="12-3-代码"><a href="#12-3-代码" class="headerlink" title="12.3 代码"></a>12.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = p.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp 数组中 字符串下标从 1 开始，索引 0 存储空字符</span></span><br><span class="line">    <span class="comment">//dp[i][j] = true 表示：s[0..(i-1)] p[0..(j-1)] 可以匹配</span></span><br><span class="line">    <span class="comment">//base case：dp[..][0] 初始化为 0, 不存在可以匹配的可能</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//base case: dp[0][..] 初始化，如果出现 * 则可以视为空字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'?'</span> || s.charAt(i) == p.charAt(j))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="comment">//情况一：s = "a", p = "a*", 此时 * 被当做空字符串 dp[i + 1][j + 1] = dp[i + 1][j]</span></span><br><span class="line">                <span class="comment">//情况二：s = "abc", p = "a*", 此时 * 被当做任意字符串 dp[i + 1][j + 1] = dp[i][j + 1]</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-例题：不同路径-62"><a href="#13-例题：不同路径-62" class="headerlink" title="13. 例题：不同路径 [62]"></a>13. 例题：不同路径 [62]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p>
<h3 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1 题目描述"></a>13.1 题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<h3 id="13-2-题目分析"><a href="#13-2-题目分析" class="headerlink" title="13.2 题目分析"></a>13.2 题目分析</h3><p>简单题。</p>
<p><code>dp[i-1][j-1]</code>表示：i * j 的网格上机器人的移动步数</p>
<p>状态转移：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<h3 id="13-3-代码"><a href="#13-3-代码" class="headerlink" title="13.3 代码"></a>13.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i-1][j-1] 表示：i * j 的网格上机器人的移动步数</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-例题：不同路径II-63"><a href="#14-例题：不同路径II-63" class="headerlink" title="14. 例题：不同路径II [63]"></a>14. 例题：不同路径II [63]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></p>
<h3 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1 题目描述"></a>14.1 题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<h3 id="14-2-题目分析"><a href="#14-2-题目分析" class="headerlink" title="14.2 题目分析"></a>14.2 题目分析</h3><p>注意与上一题的区别。</p>
<h3 id="14-3-代码"><a href="#14-3-代码" class="headerlink" title="14.3 代码"></a>14.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//dp[i-1][j-1] 表示：i * j 的网格上机器人的移动步数</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// base case，与上一题不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-例题：实现strStr"><a href="#15-例题：实现strStr" class="headerlink" title="15. 例题：实现strStr()"></a>15. 例题：实现strStr()</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></p>
<h3 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1 题目描述"></a>15.1 题目描述</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"aaaaa"</span>, needle = <span class="string">"bba"</span></span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h3 id="15-2-题目分析"><a href="#15-2-题目分析" class="headerlink" title="15.2 题目分析"></a>15.2 题目分析</h3><p>详细分析参考：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa" target="_blank" rel="noopener">这里</a> . 太难了….</p>
<p>标准的KMP方法在我的另一篇博客：<a href="https://juliajiang7.github.io/2020/07/17/KMP算法/#more" target="_blank" rel="noopener">这里</a> .</p>
<p>我们可以认为 <code>pat</code> 的匹配就是状态的转移。比如当 pat = “ABABC”：</p>
<img src="/pictures/state.jpg" alt="img" style="zoom:33%;" />

<p>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时 <code>pat</code> 处于起始状态，一旦转移到终止状态，就说明在 <code>txt</code> 中找到了 <code>pat</code>。比如说当前处于状态 2，就说明字符 “AB” 被匹配：</p>
<img src="/pictures/state2.jpg" alt="img" style="zoom:33%;" />

<p><code>dp[j][c] = next</code> 表示，当前是状态 <code>j</code>，遇到了字符 <code>c</code>，应该转移到状态 <code>next</code>。</p>
<p>base case：<code>dp[0][pat.charAt(0)] = 1;</code>, 只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）.</p>
<p>如何构建这个 <code>dp</code> 数组，需要一个辅助状态 <code>X</code>，它永远比当前状态 <code>j</code> 落后一个状态，拥有和 <code>j</code> 最长的相同前缀，我们给它起了个名字叫「影子状态」。</p>
<p>在构建当前状态 <code>j</code> 的转移方向时，只有字符 <code>pat[j]</code> 才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态 <code>X</code> 应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中 <code>other</code> 是除了 <code>pat[j]</code> 之外所有字符）。</p>
<p>对于影子状态 <code>X</code>，我们把它初始化为 0，并且随着 <code>j</code> 的前进进行更新，更新的方式和 search 过程更新 <code>j</code> 的过程非常相似（<code>X = dp[X][pat[j]]</code>）。</p>
<h3 id="15-3-代码"><a href="#15-3-代码" class="headerlink" title="15.3 代码"></a>15.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span></span>&#123;</span><br><span class="line">    String txt = haystack;</span><br><span class="line">    String pat = needle;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line">    <span class="keyword">int</span> N = txt.length();</span><br><span class="line">    <span class="keyword">if</span>(M == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j][c] = i 表示： 当前状态为 j，且遇到的下一个字符是 c 时, 下一个状态位 i</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line">    KMP(pat, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pat 的初始状态为 0</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">//计算 pat 的下一个状态</span></span><br><span class="line">        j = dp[j][txt.charAt(i)];</span><br><span class="line">        <span class="comment">//到达终止状态，匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == M)&#123;<span class="keyword">return</span> i - M + <span class="number">1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没到达终止状态，匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 dp, 即就是 next</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(String pat, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//影子状态，初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构建状态转移图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span>; c++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pat.charAt(j) == c)&#123;</span><br><span class="line">                dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新影子状态</span></span><br><span class="line">        X = dp[X][pat.charAt(j)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-参考引用"><a href="#16-参考引用" class="headerlink" title="16. 参考引用"></a>16. 参考引用</h2><ol>
<li><a href="[https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92](https://zh.wikipedia.org/wiki/动态规划)">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie</a></li>
<li><a href="https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法总结</title>
    <url>/2020/07/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要介绍了回溯法的定义、回溯法的代码框架，以及回溯法的典型问题全排列问题、N皇后问题等。另外，还介绍了LeetCode中使用回溯法的部分题目，这部分内容会持续更新。</p>
<h2 id="1-什么是回溯法？"><a href="#1-什么是回溯法？" class="headerlink" title="1. 什么是回溯法？"></a>1. 什么是回溯法？</h2><p><strong><a href="https://zh.wikipedia.org/wiki/回溯法" target="_blank" rel="noopener">回溯法（from Wikipedia）</a></strong> : （英语：backtracking）是<a href="https://zh.wikipedia.org/wiki/暴力搜尋法" target="_blank" rel="noopener">暴力搜索法</a>中的一种。</p>
<p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，<strong><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">八皇后问题</a></strong>展示了回溯法的用例。</p>
<a id="more"></a>

<p>回溯法采用<a href="https://zh.wikipedia.org/wiki/试错" target="_blank" rel="noopener">试错</a>的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<p>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。而回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。</p>
<h2 id="2-回溯法框架"><a href="#2-回溯法框架" class="headerlink" title="2. 回溯法框架"></a>2. 回溯法框架</h2><p>上文主要是 Wikipedia 对于回溯法的介绍，这一节，将参考 <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">这里</a> 给出一个回溯算法的框架。</p>
<p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p>
<ol>
<li>路径：也就是已经做出的选择</li>
<li>选择列表：也就是你当前可以做的选择</li>
<li>结束条件：也就是到达决策树底层，无法再做选择的条件</li>
</ol>
<p>如果现在不理解这三个词语没关系，下一节我们将以全排列问题为例，进行详细介绍。下面给出回溯法的框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</strong></p>
<h2 id="3-以全排列问题（无重复数字）为例-46"><a href="#3-以全排列问题（无重复数字）为例-46" class="headerlink" title="3. 以全排列问题（无重复数字）为例 [46]"></a>3. 以全排列问题（无重复数字）为例 [46]</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-问题分析"><a href="#3-2-问题分析" class="headerlink" title="3.2 问题分析"></a>3.2 问题分析</h3><p>我们知道，对于 n 个不重复的数，全排列共有 n! 个。如果使用穷举法，我们一般会：</p>
<p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p>
<p>其实这就是回溯算法，可以转化为下面的回溯树：</p>
<img src="/pictures/1.jpg" alt="img" style="zoom: 33%;" />

<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p>
<p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p>
<img src="/pictures/2.jpg" alt="img" style="zoom:33%;" />

<p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p>
<p><strong>现在可以解答开头的几个名词：</strong><code>[2]</code> <strong>就是「路径」，记录你已经做过的选择；<code>[1,3]</code>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p>
<p>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p>
<img src="/pictures/3.jpg" alt="img" style="zoom:33%;" />

<p><strong>框架中定义的 <code>backtrace</code>  函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p>
<p>在回溯法中，<strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。因此，框架中的核心代码详细化如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录路径（已做出的选择）</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 满足结束条件（到达决策树底层，无法再做选择的条件）</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length == track.size())&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span>(track.contains(num))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(num);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们并没有显示记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表。</p>
<p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p>
<p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p>
<p>明白了全排列问题，就可以直接套回溯算法框架了。</p>
<h3 id="3-4-另一种方法"><a href="#3-4-另一种方法" class="headerlink" title="3.4 另一种方法"></a>3.4 另一种方法</h3><p>上文中没有显示记录「选择列表」，通过用路径的 <code>contains</code> 方法来判断是否选择。这里我们 <strong>“以空间换时间”</strong> 的思想，使用一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)  的时间复杂度判断这个数是否被选择过。（参考 <a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">这里</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute2(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    backtrace2(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> used 标记数组，used[i]=true时，表示已被选择</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrace2</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == len)&#123;</span><br><span class="line">        res2.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        backtrace2(nums, track, used);</span><br><span class="line"></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-N皇后问题-51"><a href="#4-N皇后问题-51" class="headerlink" title="4. N皇后问题 [51]"></a>4. N皇后问题 [51]</h2><h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p>
<p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p>
<p><img src="/pictures/8-queens.png" alt="img"></p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  // 解法 1</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // 解法 2</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<h3 id="4-2-问题分析"><a href="#4-2-问题分析" class="headerlink" title="4.2 问题分析"></a>4.2 问题分析</h3><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p>
<h3 id="4-3-代码"><a href="#4-3-代码" class="headerlink" title="4.3 代码"></a>4.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化棋盘 board 为二维字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : board)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Arrays.fill(chars, <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径：board中小于row的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">     * 可选择列表: 第row行的所有列都是放置 Q 的选择</span></span><br><span class="line"><span class="comment">     * 结束条件: row超过board的最后一行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前放置第几行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.length) &#123;</span><br><span class="line">        res.add(charToString(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">//排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">//进入下一层决策树</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以在 board[row][col] 放置皇后</span></span><br><span class="line"><span class="comment">     * 不需要检查 这一行，因为每一行只放一个皇后就到下一行</span></span><br><span class="line"><span class="comment">     * 不需要检查 左下、右下斜线，因为下面还没放元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.length;</span><br><span class="line">    <span class="comment">//检查这一列是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : board)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上斜线上是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; rows; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上斜线上是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">charToString</span><span class="params">(<span class="keyword">char</span>[][] array)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : array) &#123;</span><br><span class="line">        result.add(String.valueOf(chars));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝。</p>
<h2 id="5-回溯法总结"><a href="#5-回溯法总结" class="headerlink" title="5. 回溯法总结"></a>5. 回溯法总结</h2><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>写</strong> <strong><code>backtrack</code></strong> <strong>函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p>
<p>下面几节记录了一些平时遇到的，可以使用回溯解决的经典例题，会持续更新~</p>
<h2 id="6-使用回溯法的题目列表"><a href="#6-使用回溯法的题目列表" class="headerlink" title="6. 使用回溯法的题目列表"></a>6. 使用回溯法的题目列表</h2><p>本文中使用回溯法解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">46</td>
<td align="center"><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center"><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">70</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="7-例题：全排列问题（有重复数字）-47"><a href="#7-例题：全排列问题（有重复数字）-47" class="headerlink" title="7. 例题：全排列问题（有重复数字）[47]"></a>7. 例题：全排列问题（有重复数字）[47]</h2><h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="7-2-题目分析"><a href="#7-2-题目分析" class="headerlink" title="7.2 题目分析"></a>7.2 题目分析</h3><p>这道题与上面 46 题不同，给出的序列是包含重复数字的，所以，46题的第一种方法使用track的contain来判断是否选择在这里不使用。而第二种方法，标记数组是可行的，但直接使用 used 数组判断，最终得到的全排列结果可能会有重复，如下图所示：（图片来自：<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">这里</a>）</p>
<img src="/pictures/全排列2.png" alt="全排列2" style="zoom: 33%;" />

<p>如上所示，绿色框中的序列都是重复的，不属于结果集。为什么会出现这种情况呢？</p>
<p>观察发现，在决策树中，同一父节点下的子节点中，选中两个相同的数字时，必然出现重复的全排列结果。那么如何避免这种情况呢？</p>
<p>对给出的序列进行排序，这样相同的数字都会放在一起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">	做选择</span><br><span class="line">	backtrack(路径, 选择列表)</span><br><span class="line">	撤销选择</span><br></pre></td></tr></table></figure>

<p>在框架的核心代码中，撤销选择处撤销的数字，就是下一个遍历节点的左侧兄弟节点，保存这个数组为 pre，如下图所示，当遍历到nums[i] 处时，如果 pre == nums[i]，则说明需要剪枝。</p>
<img src="/pictures/image-20200725154024914.png" alt="image-20200725154024914" style="zoom:67%;" />

<h3 id="7-3-代码"><a href="#7-3-代码" class="headerlink" title="7.3 代码"></a>7.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序；相同的数字放在一起，重复的剪枝方便</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    backtrack(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// 满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(track.size() == len)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为数组中没有的数</span></span><br><span class="line">    <span class="keyword">int</span> pre = nums[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] || pre == nums[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 记录刚被撤销的数字</span></span><br><span class="line">        pre = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h3><p>还是按照回溯法的框架来解决，但是剪枝的部分一开始想不到。</p>
<h2 id="8-例题：组合总和-39"><a href="#8-例题：组合总和-39" class="headerlink" title="8. 例题：组合总和 [39]"></a>8. 例题：组合总和 [39]</h2><h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= candidates.length &lt;= 30</span><br><span class="line">1 &lt;= candidates[i] &lt;= 200</span><br><span class="line">candidate 中的每个元素都是独一无二的。</span><br><span class="line">1 &lt;= target &lt;= 500</span><br></pre></td></tr></table></figure>

<h3 id="8-2-题目分析"><a href="#8-2-题目分析" class="headerlink" title="8.2 题目分析"></a>8.2 题目分析</h3><p>这道题依旧可以使用回溯法进行暴力穷举。有几点需要注意：</p>
<ol>
<li>选择列表candidates可以重复选择，即选择列表自始至终都不变，是candidates</li>
<li>candidate 中的每个元素都是独一无二的</li>
<li>解集不能包含重复的组合，即最终的结果不能重复</li>
</ol>
<p>鉴于最终结果不可以重复，我们可以剪掉会重复的枝，即将选择列表排序，路径的下一个节点选择从当前节点开始遍历（由于candidate 中的每个元素不重复，所以start从 i 开始就可以解决结果重复的问题）。另外，这道题改用减法更好理解。</p>
<h3 id="8-3-代码"><a href="#8-3-代码" class="headerlink" title="8.3 代码"></a>8.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化添加的代码1：先对数组排序，可以提前终止判断</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, track, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> residue 剩余</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 下一次从 start 开始判断是否添加到路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> residue, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(residue == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 从 start 开始，剪掉小于 candidates[i] 的枝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span>(residue - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(candidates[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        <span class="comment">// residue-candidates[i] 为下一轮剩余</span></span><br><span class="line">        <span class="comment">// i 为下一轮的 start值，原因：为了避免重复，选择的数字只能大于等于candidates[i]</span></span><br><span class="line">        backtrack(candidates, track, residue-candidates[i], i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-例题：组合总和-2-40"><a href="#9-例题：组合总和-2-40" class="headerlink" title="9. 例题：组合总和 2 [40]"></a>9. 例题：组合总和 2 [40]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="9-2-题目分析"><a href="#9-2-题目分析" class="headerlink" title="9.2 题目分析"></a>9.2 题目分析</h3><p>本题与上一题的区别有两个：</p>
<ol>
<li>candidates 中的每个数字在每个组合中只能使用一次</li>
<li>candidates 中有重复数字</li>
</ol>
<p>思路如下：</p>
<ol>
<li>要保证每个数字用一次，先对序列排序， 且 start 从 i+1 开始</li>
<li>要保证结果不重复，第一步是不够的，因为 candidates 中有重复数字。这个问题和上文的 <strong>全排列问题（有重复数字）</strong> 类似，使用 pre 标记刚撤销的数字，与当前值比较后进行剪枝。</li>
</ol>
<h3 id="9-3-代码"><a href="#9-3-代码" class="headerlink" title="9.3 代码"></a>9.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, track, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> residue 剩余</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 下一次从 start 开始判断是否添加到路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> residue, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(residue == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pre = candidates[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="comment">// candidates排序之后，如果第一个不满足，后面的肯定不满足，直接break</span></span><br><span class="line">        <span class="keyword">if</span>(residue - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前值和上一个撤销的值相同，会重复，continue</span></span><br><span class="line">        <span class="keyword">if</span>(candidates[i] == pre)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        track.add(candidates[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        <span class="comment">// start 从 i+1 开始</span></span><br><span class="line">        backtrack(candidates, track, residue-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        pre = candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-例题：组合-70"><a href="#10-例题：组合-70" class="headerlink" title="10. 例题：组合 [70]"></a>10. 例题：组合 [70]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></p>
<h3 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h3><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="10-2-题目分析"><a href="#10-2-题目分析" class="headerlink" title="10.2 题目分析"></a>10.2 题目分析</h3><p>这种数字组合的题目是典型的回溯法问题，先选一个数字，进入递归继续选，如果满足条件则加入结果中，然后回溯到上一步，继续递归。</p>
<h3 id="10-3-代码"><a href="#10-3-代码" class="headerlink" title="10.3 代码"></a>10.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解法一：回溯法</span></span><br><span class="line"><span class="comment">     * 回溯的常规解法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(track, n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果满足条件</span></span><br><span class="line">    <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为避免重复，i 从 start 开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(i);</span><br><span class="line">        backtrack(track, n, k, i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-优化"><a href="#10-4-优化" class="headerlink" title="10.4 优化"></a>10.4 优化</h3><p>参考 <a href="https://leetcode.wang/leetCode-77-Combinations.html" target="_blank" rel="noopener">这里</a> 对上面代码进行优化。将 for 循环改为 <code>for(int i = start; i &lt;= (n-k)+1 + track.size(); i++)</code>, 其中，<code>(n-k)+1</code>  表示要在 n 中找到 k 个数字组合，start 必须从 (n-k)+1 处开始；<code>(n-k)+1 + track.size()</code>  表示当前 i 取到的最大数字。原因如下：</p>
<p>我们发现，如果 n = 5, k = 3,  那么 start 最大取到3，因为如果 start = 4，最终结果只能得到到 (4,5), 结果的个数必定小于k，不满足条件。</p>
<p>如果 n = 5, k = 3, start = 1, 当 i = 2, track.size() = 1时，i 最大取到 (5-3)+1 + 1 = 4，否则，如果 i 取到 5，结果只能为 (1,5), 数字个数肯定不满足条件。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack2</span><span class="params">(LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (n-k)+1 表示要在n中找到k个数字组合，start必须从(n-k)+1处开始</span></span><br><span class="line">    <span class="comment">// 即如果n=5,k=3, 那么start最大取到3，因为如果当start=4时，组合中数字的个数不足</span></span><br><span class="line">    <span class="comment">// (n-k)+1 + track.size() 表示当前i取到的最大数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= (n-k)+<span class="number">1</span> + track.size(); i++)&#123;</span><br><span class="line">        track.add(i);</span><br><span class="line">        backtrack(track, n, k, i+<span class="number">1</span>);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然只改了一句代码，但速度快了很多。</p>
<h2 id="11-参考文献"><a href="#11-参考文献" class="headerlink" title="11. 参考文献"></a>11. 参考文献</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></li>
<li><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></li>
<li><a href="https://leetcode.wang/leetCode-77-Combinations.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-77-Combinations.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON与Java对象的转换</title>
    <url>/2020/07/23/JSON%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>本文简要介绍了 JSON 的定义、语法规则，同时总结了两个把 JSON 字符串转为 JavaBean 的库分别是 json-lib、fastjson，另外还有 json 数据的传输与接收的简单使用。</p>
<h2 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h2><h3 id="1-1-什么是-JSON？"><a href="#1-1-什么是-JSON？" class="headerlink" title="1.1 什么是 JSON？"></a>1.1 什么是 JSON？</h3><p><strong>JSON（JavaScript Object Notation，JavaScript对象表示法）：</strong>（from Wikipedia）是一种由道格拉斯·克罗克福特构想和设计、<em>轻量级的数据交换语言</em>，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是<em>独立于语言的文本格式</em>，并且采用了类似于C语言家族的一些习惯。</p>
<p>JSON 数据格式与语言无关。即便它源自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。</p>
<a id="more"></a>

<h3 id="1-2-JSON-语法规则"><a href="#1-2-JSON-语法规则" class="headerlink" title="1.2 JSON 语法规则"></a>1.2 JSON 语法规则</h3><ul>
<li>数据格式为 键/值 对（一个名称对应一个值）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"name":"julia"</span><br></pre></td></tr></table></figure>

<ul>
<li>数据由逗号分隔</li>
<li>大括号保存对象（对象可以保存多个键值对）</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"julia"</span>, <span class="attr">"url"</span>:<span class="string">"juliajiang7.github.io/"</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方括号保存数组，数组可以包含对象</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"sites":[</span><br><span class="line">    &#123;"name":"julia", "url":"juliajiang7.github.io"&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"Google"</span>, <span class="attr">"url"</span>:<span class="string">"www.google.com"</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>详细请参考 <a href="https://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">JSON教程</a></p>
<h2 id="2-使用-json-lib"><a href="#2-使用-json-lib" class="headerlink" title="2. 使用 json-lib"></a>2. 使用 json-lib</h2><p><a href="http://json-lib.sourceforge.net/" target="_blank" rel="noopener">http://json-lib.sourceforge.net/</a></p>
<p>JSON-lib is a java library for transforming beans, maps, collections, java arrays and XML to JSON and back again to beans and DynaBeans.<br>It is based on the work by Douglas Crockford in <a href="http://www.json.org/java" target="_blank" rel="noopener">http://www.json.org/java</a>.</p>
<h3 id="2-1-引入-maven"><a href="#2-1-引入-maven" class="headerlink" title="2.1 引入 maven"></a>2.1 引入 maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-json-对象转为-Java-对象"><a href="#2-2-json-对象转为-Java-对象" class="headerlink" title="2.2 json 对象转为 Java 对象"></a>2.2 json 对象转为 Java 对象</h3><h4 id="2-2-1-创建实体-Student"><a href="#2-2-1-创建实体-Student" class="headerlink" title="2.2.1 创建实体 Student"></a>2.2.1 创建实体 Student</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean isValid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getIsValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsValid</span><span class="params">(Boolean valid)</span> </span>&#123;</span><br><span class="line">        isValid = valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-转换对象"><a href="#2-2-2-转换对象" class="headerlink" title="2.2.2 转换对象"></a>2.2.2 转换对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"julia\", \"age\":16, \"isValid\":true&#125;"</span>;</span><br><span class="line">    <span class="comment">// 将json字符串转为JSONObject对象</span></span><br><span class="line">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class="line">    <span class="comment">// 将JSONObject对象转为Student对象</span></span><br><span class="line">    Student student = (Student) JSONObject.toBean(jsonObject, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-json-数组转为-Java-的-List-lt-T-gt"><a href="#2-3-json-数组转为-Java-的-List-lt-T-gt" class="headerlink" title="2.3 json 数组转为 Java 的 List&lt;T&gt;"></a>2.3 json 数组转为 Java 的 List&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"name\":\"julia\", \"age\":16, \"isValid\":true&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\", \"age\":17, \"isValid\":false&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"jiang\", \"age\":18, \"isValid\":true&#125;]"</span>;</span><br><span class="line">    <span class="comment">// 将json数组转为JSONArray对象</span></span><br><span class="line">    JSONArray jsonArray = JSONArray.fromObject(jsonStr);</span><br><span class="line">    <span class="comment">// 将JSONArray对象转为List</span></span><br><span class="line">    List&lt;Student&gt; students = (List&lt;Student&gt;) JSONArray.toCollection(jsonArray, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(students);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-json-复杂数据转为-JavaBean-对象"><a href="#2-4-json-复杂数据转为-JavaBean-对象" class="headerlink" title="2.4 json 复杂数据转为 JavaBean 对象"></a>2.4 json 复杂数据转为 JavaBean 对象</h3><p>如果 json 对象中包含数组，这个数组中包含 json 对象，如下所示：</p>
<p><img src="/pictures/image-20200514143731277-1595486755603.png" alt="image-20200514143731277"></p>
<p>要将这个 json 字符串转为 JavaBean 对象，实体类需要有 List&lt;Student&gt; 属性。定义实体来 Teacher 如下：</p>
<h4 id="2-4-1-创建-Teacher-对象"><a href="#2-4-1-创建-Teacher-对象" class="headerlink" title="2.4.1 创建 Teacher 对象"></a>2.4.1 创建 Teacher 对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-转换对象"><a href="#2-4-2-转换对象" class="headerlink" title="2.4.2 转换对象"></a>2.4.2 转换对象</h4><p>我们还是采用前面的方式进行转换，发现在获取 <code>student.getName()</code> 时报错<strong>net.sf.ezmorph.bean.MorphDynaBean cannot be cast to</strong> 如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"teacher\", \"age\":30, \"students\":"</span> +</span><br><span class="line">        <span class="string">"[&#123;\"name\":\"julia\",\"age\":16,\"isValid\":true&#125;,"</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\",\"age\":17,\"isValid\":false&#125;]&#125;"</span>;</span><br><span class="line">    <span class="comment">// 将json数组转为JSONArray对象</span></span><br><span class="line">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class="line">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="keyword">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Teacher&#123;name='teacher', age=30, students=[net.sf.ezmorph.bean.MorphDynaBean@3c6aa04a[</span></span><br><span class="line"><span class="comment">  &#123;isValid=true, name=julia, age=16&#125;</span></span><br><span class="line"><span class="comment">], net.sf.ezmorph.bean.MorphDynaBean@2257fadf[</span></span><br><span class="line"><span class="comment">  &#123;isValid=false, name=fan, age=17&#125;</span></span><br><span class="line"><span class="comment">]]&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.juliajiang.blogtest.entity.Student</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这是因为：在操作 json 数据时，如果没有指明数据类型，那么只能是基本类型（比如上述Integer、Boolean等）或者String类型，不能出现复杂数据类型。</p>
<p>应该采用如下方式转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"teacher\", \"age\":30, \"students\":"</span> +</span><br><span class="line">        <span class="string">"[&#123;\"name\":\"julia\",\"age\":16,\"isValid\":true&#125;,"</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\",\"age\":17,\"isValid\":false&#125;]&#125;"</span>;</span><br><span class="line">    <span class="comment">// 将json数组转为JSONArray对象</span></span><br><span class="line">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class="line">    Map&lt;String, Class&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"students"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 添加map</span></span><br><span class="line">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="keyword">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class="line"><span class="comment">julia</span></span><br><span class="line"><span class="comment">fan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>其中 map 对象是 Teacher 中各个属性的类型，map 的 key 是属性的名，value 是属性的类型。</p>
<h2 id="3-使用-fastjson"><a href="#3-使用-fastjson" class="headerlink" title="3. 使用 fastjson"></a>3. 使用 fastjson</h2><p>fastjson 中文WiKi：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p>
<h3 id="3-1-什么是-fastjson"><a href="#3-1-什么是-fastjson" class="headerlink" title="3.1 什么是 fastjson?"></a>3.1 什么是 fastjson?</h3><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>
<h3 id="3-2-引入-maven"><a href="#3-2-引入-maven" class="headerlink" title="3.2 引入 maven"></a>3.2 引入 maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-json-字符串与-Java-对象互转"><a href="#3-3-json-字符串与-Java-对象互转" class="headerlink" title="3.3 json 字符串与 Java 对象互转"></a>3.3 json 字符串与 Java 对象互转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">"julia"</span>, <span class="number">16</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 将Java对象转为json字符串</span></span><br><span class="line">    String jsonString = JSON.toJSONString(student);</span><br><span class="line">    System.out.println(jsonString);</span><br><span class="line">    <span class="comment">// 将json字符串转为Java对象</span></span><br><span class="line">    Student student1 = JSON.parseObject(jsonString, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">&#123;"age":16,"isValid":true,"name":"julia"&#125;</span></span><br><span class="line"><span class="comment">Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-json-数组转为-List-lt-T-gt"><a href="#3-4-json-数组转为-List-lt-T-gt" class="headerlink" title="3.4 json 数组转为 List&lt;T&gt;"></a>3.4 json 数组转为 List&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"name\":\"julia\", \"age\":16, \"isValid\":true&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\", \"age\":17, \"isValid\":false&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"jiang\", \"age\":18, \"isValid\":true&#125;]"</span>;</span><br><span class="line">    List&lt;Student&gt; students = JSONArray.parseArray(jsonStr, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(students);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-json-复杂数据转为-Java-对象"><a href="#3-5-json-复杂数据转为-Java-对象" class="headerlink" title="3.5 json 复杂数据转为 Java 对象"></a>3.5 json 复杂数据转为 Java 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"teacher\", \"age\":30, \"students\":"</span> +</span><br><span class="line">        <span class="string">"[&#123;\"name\":\"julia\",\"age\":16,\"isValid\":true&#125;,"</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\",\"age\":17,\"isValid\":false&#125;]&#125;"</span>;</span><br><span class="line">    Teacher teacher = JSON.parseObject(jsonStr, Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="keyword">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class="line"><span class="comment">julia</span></span><br><span class="line"><span class="comment">fan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-fastjson-和-json-lib-对比"><a href="#4-fastjson-和-json-lib-对比" class="headerlink" title="4. fastjson 和 json-lib 对比"></a>4. fastjson 和 json-lib 对比</h2><p>就以上三种使用途径来看，fastjson 确实更加方便。</p>
<h2 id="5-json-数据的传输与接收"><a href="#5-json-数据的传输与接收" class="headerlink" title="5. json 数据的传输与接收"></a>5. json 数据的传输与接收</h2><p>JSON 通常用于与服务端交换数据，在向服务器发送数据时一般是字符串。我们可以使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为字符串。</p>
<p>向服务器发送请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> param = <span class="built_in">JSON</span>.stringify(searchList);</span><br><span class="line">$.post(url, &#123;</span><br><span class="line">            searchList:param</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/*...*/</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>springboot 后台 controller 接收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/search"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">search</span><span class="params">(String searchList)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将前台接收的 json 数组转化为实体SearchList的列表</span></span><br><span class="line">    List&lt;SearchList&gt; lists = JSONArray.parseArray(searchList, SearchList<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ol>
<li><a href="https://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/json/json-tutorial.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/07/17/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要介绍了 KMP算法的基本思想、代码、优化以及时间复杂度分析。</p>
<h2 id="1-KMP算法思想"><a href="#1-KMP算法思想" class="headerlink" title="1. KMP算法思想"></a>1. KMP算法思想</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p><strong>字符串匹配</strong> 是计算机的基本任务之一。举例来说，即有一个字符串”BBC ABCDAB ABCDABCDABDE”，判断该字符串中是否包含另一个字符串”ABCDABD”？许多算法可以完成这个任务，<a href="https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法" target="_blank" rel="noopener">Knuth-Morris-Pratt算法</a>（简称KMP）是最常用的之一。它以三个发明者命名，其中K代表著名科学家Donald Knuth。KMP算法可在一个字符串S内查找一个词P的出现位置，如果有返回P的起始索引，否则返回-1.</p>
<p>接下来，我会先举例对KMP算法的思路进行解释（不涉及任何代码）。</p>
<a id="more"></a>

<h3 id="1-2-基本思路"><a href="#1-2-基本思路" class="headerlink" title="1.2 基本思路"></a>1.2 基本思路</h3><ol>
<li><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”（称为文本串）的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<img src="/pictures/bg2013050103.png" alt="img" style="zoom:67%;" />
</li>
<li><p>因为B与A不匹配，模式串再往后移。</p>
<img src="/pictures/bg2013050104.png" alt="img" style="zoom:67%;" />
</li>
<li><p>就这样，直到文本串有一个字符，与模式串的第一个字符相同为止。</p>
<img src="/pictures/bg2013050105.png" alt="img" style="zoom:67%;" />
</li>
<li><p>接着比较文本串和模式串的下一个字符，还是相同。</p>
<img src="/pictures/bg2013050106.png" alt="img" style="zoom:67%;" />
</li>
<li><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<img src="/pictures/bg2013050107.png" alt="img" style="zoom:67%;" />
</li>
<li><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做固然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<img src="/pictures/bg2013050108.png" alt="img" style="zoom:67%;" />
</li>
<li><p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。</p>
<img src="/pictures/bg2013050107-1594975043794.png" alt="img" style="zoom:67%;" />
</li>
<li><p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<img src="/pictures/bg2013050109.png" alt="img" style="zoom:67%;" />
</li>
<li><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B（不匹配字符的前一个字符）对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的部分匹配值</span><br></pre></td></tr></table></figure>

<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
</li>
<li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<img src="/pictures/bg2013050110.png" alt="img" style="zoom:67%;" />
</li>
<li><p>因为空格与A不匹配，继续后移一位。</p>
<img src="/pictures/bg2013050111.png" alt="img" style="zoom:67%;" />
</li>
<li><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<img src="/pictures/bg2013050112.png" alt="img" style="zoom:67%;" />
</li>
<li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<img src="/pictures/bg2013050113.png" alt="img" style="zoom: 67%;" />
</li>
<li><p>下面介绍《部分匹配表》是如何产生的。</p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<img src="/pictures/bg2013050114.png" alt="img" style="zoom:67%;" />
</li>
<li><p>“部分匹配值”就是”前缀”和”后缀”的最大公共元素长度。以”ABCDABD”为例，计算过程如下：</p>
<p><img src="/pictures/20140725231726921" alt="img"></p>
</li>
<li><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<img src="/pictures/bg2013050112-1594975805920.png" alt="img" style="zoom:67%;" />

</li>
</ol>
<p>到此，我们对于KMP的基本思路有了一个大致的了解，下一部分介绍KMP具体算法细节、代码及优化。</p>
<h2 id="2-KMP算法代码及优化"><a href="#2-KMP算法代码及优化" class="headerlink" title="2. KMP算法代码及优化"></a>2. KMP算法代码及优化</h2><p>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>
<h3 id="2-1-暴力匹配算法"><a href="#2-1-暴力匹配算法" class="headerlink" title="2.1 暴力匹配算法"></a>2.1 暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>
<ul>
<li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li>
<li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>
</ul>
<p>暴力匹配代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-KMP算法"><a href="#2-2-KMP算法" class="headerlink" title="2.2 KMP算法"></a>2.2 KMP算法</h3><h4 id="2-2-1-求解-next-数组"><a href="#2-2-1-求解-next-数组" class="headerlink" title="2.2.1 求解 next 数组"></a>2.2.1 求解 next 数组</h4><h5 id="2-2-1-1-基本思路"><a href="#2-2-1-1-基本思路" class="headerlink" title="2.2.1.1 基本思路"></a>2.2.1.1 基本思路</h5><p>前文已经计算过“部分匹配表”，即前缀和后缀的最大公共元素长度，如下图所示：</p>
<p><img src="/pictures/20140725231726921" alt="img"></p>
<p>由前文可知，失配时，模式串向右移动的位数公式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的最大公共元素长度</span><br></pre></td></tr></table></figure>

<p>由此我们发现，当匹配一个字符失配时，我们并不会考虑当前字符，而是看失配字符的前一个字符的最大公共元素长度，如此，便引出了next数组。<strong>next 数组相当于最大长度值整体向右移动一位，然后初值赋为-1.</strong> 因而，对于给定的模式串，它的最大长度及next数组分别如下：</p>
<p><img src="/pictures/20140728110939595" alt="img"></p>
<p>求得next数组之后，失配时模式串向右移动的位数为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">移动位数 = 失配字符所在位置 - 失配字符对应的next值</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-2-代码计算-next-数组"><a href="#2-2-1-2-代码计算-next-数组" class="headerlink" title="2.2.1.2 代码计算 next 数组"></a>2.2.1.2 代码计算 next 数组</h5><ol>
<li><p>如果<strong>对于值 k, 已有 p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k</strong>。究其本质，<strong>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀</strong>。有了这个next 数组，在KMP匹配中，当模式串中 j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动 j - next[j] 位。</p>
</li>
<li><p>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</p>
<ul>
<li><p>若p[k] == p[j]，则next[j + 1] = next [j] + 1 = k + 1。</p>
<p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p>
<p><img src="/pictures/20140729182154066" alt="img"></p>
</li>
<li><p>若p[k ] ≠ p[j]，如果此时 p[next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</p>
<p>如下图所示，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。<br><img src="/pictures/20140729181940812" alt="img">   </p>
<p>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk’-1 pk’ = pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] = k’ + 1 = next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。</p>
<p>那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？ 这又归根到next数组的含义。<strong>我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。</strong></p>
</li>
</ul>
</li>
<li><p>综上，可以通过递推求得 next 数组，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] p)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            next[++j] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-2-1-3-总结-next-数组含义"><a href="#2-2-1-3-总结-next-数组含义" class="headerlink" title="2.2.1.3 总结 next 数组含义"></a>2.2.1.3 总结 next 数组含义</h5><ol>
<li>代表失配字符之前的字符串中，有多大长度的相同前缀后缀。</li>
<li>在某个字符失配后，next 值会告诉你下一步匹配中，模式串应该跳到哪个位置。如果next [j] 等于0或 -1，则跳到模式串的开头字符；若next [j] = k 且 k &gt; 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</li>
</ol>
<h4 id="2-2-2-KMP-算法"><a href="#2-2-2-KMP-算法" class="headerlink" title="2.2.2 KMP 算法"></a>2.2.2 KMP 算法</h4><p>根据上文的分析，KMP算法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || s[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-next-数组的优化"><a href="#2-2-3-next-数组的优化" class="headerlink" title="2.2.3 next 数组的优化"></a>2.2.3 next 数组的优化</h4><p>行文至此，我们全面了解了KMP算法的基本思路、流程、代码以及next 数组的求解，但忽略了一个小问题。</p>
<p>比如，如果用之前的next 数组方法求模式串“abab”的 next 数组，可得其 next 数组为 -1 0 0 1，当它跟下图中的文本串去匹配的时候，发现 b 跟 c 失配，于是模式串右移 j - next[j] = 3 - 1 = 2位。</p>
<img src="/pictures/8394323_1308075859Zfue.jpg" alt="8394323_1308075859Zfue" style="zoom:67%;" />

<p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</p>
<img src="/pictures/8394323_13080758591kyV-1595069195969.jpg" alt="8394323_13080758591kyV" style="zoom:67%;" />

<p>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p>
<p>因此，求解 next 数组的代码优化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNextval(<span class="keyword">char</span>[] p)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(p[j] != p[k])&#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-KMP-算法时间复杂度分析"><a href="#3-KMP-算法时间复杂度分析" class="headerlink" title="3. KMP 算法时间复杂度分析"></a>3. KMP 算法时间复杂度分析</h2><p>我们先来回顾一下KMP算法的流程，假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置：</p>
<ol>
<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</li>
</ol>
<p>我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。</p>
<p>所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p>
<h2 id="4-例题：实现-strStr-28"><a href="#4-例题：实现-strStr-28" class="headerlink" title="4. 例题：实现 strStr() [28]"></a>4. 例题：实现 strStr() [28]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a>；另一种动态规划在我的另一篇博客：<a href="">这里</a>.</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"aaaaa"</span>, needle = <span class="string">"bba"</span></span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] p = needle.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = getNextval(p);</span><br><span class="line">    <span class="keyword">return</span> kmp(s, p, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || s[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNextval(<span class="keyword">char</span>[] p)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(p[j] != p[k])&#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ol>
<li><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Algorithm</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap实现原理及其重要方法</title>
    <url>/2020/04/05/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要介绍了 HashMap 的底层实现结构、存储结构以及JDK1.8中相关的优化。同时，也分析了一些HashMap的重要方法，比如哈希桶索引位置、查询、新增、扩容。另外涉及几个细节性的问题，比如加载因子、HashMap与HashTable的区别等等。</p>
<a id="more"></a>

<h2 id="1-部分源码分析"><a href="#1-部分源码分析" class="headerlink" title="1. 部分源码分析"></a>1. 部分源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//HashMap初始化长度 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;		<span class="comment">//HashMap 最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;		<span class="comment">//默认的加载因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;				<span class="comment">//转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;			<span class="comment">//转换链表的临界值，当链表长度小于此值时，会将红黑树结构转换为链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;			<span class="comment">//最小树容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;				<span class="comment">//用来定位数组索引位置							</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;				<span class="comment">//链表的下一个node</span></span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;	<span class="comment">// Node[] table的初始化长度length(默认值是16)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;			<span class="comment">// HashMap中实际存在的键值对数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;		<span class="comment">// 记录HashMap内部结构发生变化的次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> threshold;				<span class="comment">// HashMap所能容纳的最大数据量的Node(键值对)个数</span></span><br><span class="line">    							<span class="comment">// threshold = length * Load factor </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;		<span class="comment">// 负载因子(默认值是0.75)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Hash 算法，共三步</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">        <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="comment">    // 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class="line"><span class="comment">    static int indexFor(int h, int length) &#123;  </span></span><br><span class="line"><span class="comment">    	//第三步 取模运算</span></span><br><span class="line"><span class="comment">     	return h &amp; (length-1);  </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>



<h2 id="2-HashMap-底层是如何实现的？JDK1-8如何优化？"><a href="#2-HashMap-底层是如何实现的？JDK1-8如何优化？" class="headerlink" title="2. HashMap 底层是如何实现的？JDK1.8如何优化？"></a>2. HashMap 底层是如何实现的？JDK1.8如何优化？</h2><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<img src="/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png" alt="img" style="zoom: 67%;" />

<p>JDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。Node 源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">"julia"</span>,<span class="string">"jiang"</span>);</span><br></pre></td></tr></table></figure>

<p>系统将调用 <code>&quot;julia&quot;</code> 这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（具体见哈希桶数组索引位置分析）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<h2 id="3-什么是加载因子？加载因子为什么是0-75？"><a href="#3-什么是加载因子？加载因子为什么是0-75？" class="headerlink" title="3. 什么是加载因子？加载因子为什么是0.75？"></a>3. 什么是加载因子？加载因子为什么是0.75？</h2><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p>
<p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p>
<p>这其实是出于容量和性能之间平衡的结果：</p>
<ol>
<li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li>
<li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li>
</ol>
<p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p>
<h2 id="4-HashMap源码中有哪些重要方法？"><a href="#4-HashMap源码中有哪些重要方法？" class="headerlink" title="4. HashMap源码中有哪些重要方法？"></a>4. HashMap源码中有哪些重要方法？</h2><h3 id="4-1-确定哈希桶数组索引位置"><a href="#4-1-确定哈希桶数组索引位置" class="headerlink" title="4.1 确定哈希桶数组索引位置"></a>4.1 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<img src="/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png" alt="img" style="zoom:80%;" />

<h3 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2 查询"></a>4.2 查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//下一个节点非空判断</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果第一个节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//非树结构，循环节点判断</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;   <span class="comment">//hash相等，并且 key相等，则返回此节点</span></span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p>
<h3 id="4-3-新增"><a href="#4-3-新增" class="headerlink" title="4.3 新增"></a>4.3 新增</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//哈希表为空则创建表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//根据 key 的哈希值计算出要插入的数组索引i</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果 tab[i] 为 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//如果key相等，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果 key 不存在，判断是否为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//为链表结构，循环准备插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//下一个元素为空时</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表长度大于 8 时转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//超过最大容量，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增方法的执行流程如下：</p>
<p><img src="/pictures/58e67eae921e4b431782c07444af824e_r.jpg" alt="preview"></p>
<h3 id="4-4-扩容"><a href="#4-4-扩容" class="headerlink" title="4.4 扩容"></a>4.4 扩容</h3><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">参考博文</a></p>
<h4 id="JDK1-7-的扩容"><a href="#JDK1-7-的扩容" class="headerlink" title="JDK1.7 的扩容"></a>JDK1.7 的扩容</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>  </span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">   Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">   <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">       Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">               e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">               newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">               e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">           &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="comment">// 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//第三步 取模运算</span></span><br><span class="line"> 	<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定哈希桶数组索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。下面举个例子说明下扩容过程。</p>
<p>这里我们假设 <code>hashCode()</code> 的哈希算法就是简单的 key % (数组长度)。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。</p>
<p>接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg" alt="preview"></p>
<h4 id="JDK1-8-在扩容方面的优化"><a href="#JDK1-8-在扩容方面的优化" class="headerlink" title="JDK1.8 在扩容方面的优化"></a>JDK1.8 在扩容方面的优化</h4><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg" alt="preview"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png" alt="img"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png" alt="img"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<h4 id="JDK1-8-中扩容源码"><a href="#JDK1-8-中扩容源码" class="headerlink" title="JDK1.8 中扩容源码"></a>JDK1.8 中扩容源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//扩容前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//扩容前数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">//预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//超过最大值就不可以扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容容量为当前容量的两倍，但不能超过MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前数组没有数据，前数组大小为0，新数组容量设置为初始阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//初始阈值为0，则使用默认的初始化容器</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新容量等于0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//开始赋值，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//原数据不为空，将原数据赋值到table中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据容量循环数组，赋值非空元素到新table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是红黑树存储</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">//链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将原索引+oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-HashMap-多线程操作导致死循环问题"><a href="#6-HashMap-多线程操作导致死循环问题" class="headerlink" title="6. HashMap 多线程操作导致死循环问题"></a>6. HashMap 多线程操作导致死循环问题</h2><p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">详细分析</a></p>
<p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<h2 id="7-HashMap-和-HashTable的区别"><a href="#7-HashMap-和-HashTable的区别" class="headerlink" title="7. HashMap 和 HashTable的区别"></a>7. HashMap 和 HashTable的区别</h2><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p>HashMap 中带有初始化容量的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);	 <span class="comment">// 保证HashMap总是使用2的幂作为哈希表大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于 HashMap 的知识点参考 <a href="https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-2Java集合?id=_226-hashmap-和-hashset区别" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String的特点以及方法</title>
    <url>/2020/04/04/String%E7%9A%84%E7%89%B9%E7%82%B9%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要从源码出发，介绍了 String 的一些特点和方法。包括了 String 的底层实现，源码中的几个重要方法实现，String 使用 final 修饰的原因，String 与 StringBuilder、StringBuffered 的区别，String 在 JVM 中的存储，intern() 方法，不可变性，+ 的重载以及编译器使用 StringBuilder 的优化。</p>
<a id="more"></a>

<h2 id="1-String-如何实现"><a href="#1-String-如何实现" class="headerlink" title="1. String 如何实现"></a>1. String 如何实现</h2><p>以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. 用于储存字符串的值*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string 缓存字符串的Hash Code*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    .....</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
<h2 id="2-String-源码中的几个重要方法"><a href="#2-String-源码中的几个重要方法" class="headerlink" title="2. String 源码中的几个重要方法"></a>2. String 源码中的几个重要方法</h2><h3 id="2-1-多构造方法"><a href="#2-1-多构造方法" class="headerlink" title="2.1 多构造方法"></a>2.1 多构造方法</h3><p>如下选出源码中 String 比较重要的几个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// char[] 为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StringBuffer 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StringBuilder 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-equals-比较两个字符串是否相等"><a href="#2-2-equals-比较两个字符串是否相等" class="headerlink" title="2.2 equals() 比较两个字符串是否相等"></a>2.2 equals() 比较两个字符串是否相等</h3><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Object 的 equals 方法以及与 == de 区别更详细解释请参考</a></p>
<p>Object 的 equals() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 的 equals() 方法重写了 Object 的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时先判断对比的值是否为 String 类型，如果不是直接返回false，如果是继续判断，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断对比的值是否为String类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="comment">//把两个字符串转为 char[] 数组对比</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p>
<p><strong>equals() 和 == 的区别：</strong></p>
<ol>
<li>== 对于基本数据类型来说，是比较<strong>值</strong>是否相等的；对于引用类型来说，是用于比较<strong>引用地址</strong>是否相等的</li>
<li>从 Object 的 equals() 方法源码来看，对于 Object 而言，equals() 方法其实就是 ==, 而 String 重写了 equals() 方法，用于比较两个字符串的值是否相等。</li>
</ol>
<h3 id="2-3-compareTo-比较两个字符串"><a href="#2-3-compareTo-比较两个字符串" class="headerlink" title="2.3 compareTo() 比较两个字符串"></a>2.3 compareTo() 比较两个字符串</h3><p>用于两个字符串的字典序比较，返回 int 类型的值，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p>
<p><strong>equals() 和 compareTo() 方法的区别：</strong></p>
<ol>
<li>equals() 可以接收一个Object类型的参数，而compareTo() 只接受String</li>
<li>equals 返回值为 boolean, compareTo 返回 int</li>
</ol>
<h3 id="2-4-其他重要方法"><a href="#2-4-其他重要方法" class="headerlink" title="2.4 其他重要方法"></a>2.4 其他重要方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">indexOf()：查询字符串首次出现的下标位置</span><br><span class="line">lastIndexOf()：查询字符串最后出现的下标位置</span><br><span class="line">contains()：查询字符串中是否包含另一个字符串</span><br><span class="line">toLowerCase()：把字符串全部转换成小写</span><br><span class="line">toUpperCase()：把字符串全部转换成大写</span><br><span class="line">length()：查询字符串的长度</span><br><span class="line">trim()：去掉字符串首尾空格</span><br><span class="line">replace()：替换字符串中的某些字符</span><br><span class="line">split()：把字符串分割并返回字符串数组</span><br><span class="line">join()：把字符串数组转为字符串</span><br></pre></td></tr></table></figure>

<h2 id="3-为什么-String-类型用-final-修饰？"><a href="#3-为什么-String-类型用-final-修饰？" class="headerlink" title="3. 为什么 String 类型用 final 修饰？"></a>3. 为什么 String 类型用 final 修饰？</h2><p>从 String 类的源码来看，String 是被 final 修饰的不可继承类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>那这样设计有什么好处呢？</p>
<p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时，不需要考虑谁会修改它的值；如果是可变的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上有一定的损失。</p>
<p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是<strong>安全</strong>。当你在调用其他方法时，比如在调用一些系统级操作指令之前，可能会有一系列校验，如果是可变的话，可能在你校验之后，它的内部值又被改变了，这样可能引起严重的系统崩溃问题，这是迫使 String 类设计为不可变类的一个重要原因。</p>
<p>总结来说，使用 final 修饰的第一个好处是<strong>安全</strong>，第二个好处是<strong>高效</strong>。我们以 JVM 中的字符串常量池为例，有如下两个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure>

<p>只有字符串是不可变时，我们才能实现字符串常量池，它可以为我们缓存字符串，提高程序运行效率。</p>
<p><img src="../pictures/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200405164821-1586080520904.png" alt="微信截图_20200405164821"></p>
<p>试想如果 String 是可变的，那当 s1 的值修改之后，s2 的值也会跟着改变，这样就和我们预期的结果不符合，因此也就没有办法实现字符串常量池的功能了。</p>
<h2 id="4-String-和-StringBuilder、StringBuffer-的区别"><a href="#4-String-和-StringBuilder、StringBuffer-的区别" class="headerlink" title="4. String 和 StringBuilder、StringBuffer 的区别"></a>4. String 和 StringBuilder、StringBuffer 的区别</h2><h3 id="（1）-可变性"><a href="#（1）-可变性" class="headerlink" title="（1） 可变性"></a>（1） 可变性</h3><p>上文提到，String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<p>但StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，所以这两种对象都是可变的。AbstractStringBuilder 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="（2）线程安全性"><a href="#（2）线程安全性" class="headerlink" title="（2）线程安全性"></a>（2）线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁 synchronized，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer 截取部分源码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StringBuilder 截取部分源码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）性能"><a href="#（3）性能" class="headerlink" title="（3）性能"></a>（3）性能</h3><p>因为 String 类型是不可变的，所以每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 性能更高一些，但却线程不安全的风险，因而我们可以再非并发操作的环境下使用 StringBuilder 操作字符串。</p>
<h3 id="（4）对于三者使用的总结"><a href="#（4）对于三者使用的总结" class="headerlink" title="（4）对于三者使用的总结"></a>（4）对于三者使用的总结</h3><pre><code>- 操作少量的数据: 适用 String
- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</code></pre><h2 id="5-String-在-JVM（Java虚拟机）中是如何存储的？"><a href="#5-String-在-JVM（Java虚拟机）中是如何存储的？" class="headerlink" title="5. String 在 JVM（Java虚拟机）中是如何存储的？"></a>5. String 在 JVM（Java虚拟机）中是如何存储的？</h2><p>String常见的创建方式有两种，直接赋值的方式<code>Strings1 = &quot;Java&quot;;</code>和<code>Strings2 = new String(&quot;Java&quot;);</code>的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量 s1 会先去<strong>字符串常量池</strong>中找字符串“Java”，如果有相同的字符则直接返回<strong>常量句柄</strong>（一个唯一的整数，作为对象的身份id, 区分不同的对象和同类中的不同实例），如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 s2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中，它们在 JVM 中的存储位置如下图所示：</p>
<p><img src="../pictures/image-20200405194407416.png" alt="image-20200405194407416"></p>
<p>代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Strings1 = newString(<span class="string">"Java"</span>);</span><br><span class="line">Strings2 = s1.intern();</span><br><span class="line">Strings3 = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="6-String-的-intern-方法有什么含义"><a href="#6-String-的-intern-方法有什么含义" class="headerlink" title="6. String 的 intern 方法有什么含义?"></a>6. String 的 intern 方法有什么含义?</h2><p>public String <strong>intern</strong>() 返回字符串对象的规范化表示形式，返回值是一个字符串，内容与此字符串相等，但它保证来自字符串池中。</p>
<p>一个初始为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果字符串池中已经包含一个等于此 String 对象的字符串（是否等于由 String 的 equals 方法来确定），则返回池中的字符串；否则将此 String 对象添加到池中，并且返回此 String 对象的引用。所有的字面值字符串和字符串赋值常量表达式都是内部的。</p>
<p>如下例子中，变量 str1 会先去字符串常量池中找字符串 “ab”, 如果有相同的字符串则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 str2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中。</p>
<p>字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如 str3 str4）则不会进入字符串池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1 == str2);           <span class="comment">//false 引用地址不同</span></span><br><span class="line">System.out.println(str1.equals(str2));      <span class="comment">//true 字符串值相同</span></span><br><span class="line">System.out.println(str1 == str2.intern());  <span class="comment">//true</span></span><br><span class="line">String str3 = <span class="string">"a"</span>;</span><br><span class="line">String str4 = <span class="string">"b"</span>;</span><br><span class="line">System.out.println(str3 + str4 == str1);    <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">"a"</span> + <span class="string">"b"</span> == str1);      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>前文中说明了 equals 和 == 的区别，对于 String 而言，== 判断的是引用地址，那么什么时候会出现引用地址相同的情况呢？现在来看，如果给变量赋值的是静态字符串，就会在字符串中找相同字符串，如果有返回引用，这时候就存在相同的引用地址；而 new String 构造的字符串用 == 判断一定是 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str5 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str2 == str5);           <span class="comment">//false</span></span><br><span class="line">String str6 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str1 ==str6);            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="7-String-的不可变"><a href="#7-String-的不可变" class="headerlink" title="7. String 的不可变"></a>7. String 的不可变</h2><p>String 对象是不可变的。从 JDK 文档可以发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象来包含修改后的字符串内容，而最初的 String 对象纹丝未动。</p>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String q = <span class="string">"howdy"</span>;</span><br><span class="line">    System.out.println(q); <span class="comment">// howdy </span></span><br><span class="line">    String qq = upcase(q);</span><br><span class="line">    System.out.println(qq); <span class="comment">// HOWDY </span></span><br><span class="line">    System.out.println(q); <span class="comment">// howdy </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当把 <code>q</code>传递给<code>upcase()</code>方法时，实际传递的是引用的一个拷贝。每当 String 对象作为方法的参数时，都会复制一份引用，而该引用所指的对象一直在物理位置上没有任何变化。</p>
<p>回到 upcase() 的定义，传入其中的引用有了名字 s, 只有 upcase() 方法运行时局部引用 s 才存在。一旦 upcase() 结束，s 就消失了。其返回值也就指向了一个新的对象，而 q 仍然在原来的位置。</p>
<h2 id="8-的重载与-StringBuilder"><a href="#8-的重载与-StringBuilder" class="headerlink" title="8. + 的重载与 StringBuilder"></a>8. + 的重载与 StringBuilder</h2><p>String 对象是不可变的，你可以给一个 String 对象添加任意多的别名，因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，这样也就不会影响到其他引用。</p>
<p>不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子：操作符 + 可以连接 String。当使用 + 操作符时，编译器会做一定的优化，例如在下面的代码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String mango = <span class="string">"mango"</span>; </span><br><span class="line">String s = <span class="string">"abc"</span> + mango + <span class="string">"def"</span> + <span class="number">47</span>;</span><br></pre></td></tr></table></figure>

<p>编译器会自动引入<code>java.lang.StringBuilder</code>类（虽然源代码中并没有使用 StringBuilder 类，但因为其高效，编译器会使用它），先创建一个 StringBuilder 对象，对每个字符串调用一次 append 方法，共4次，最后调用 toString() 方法，存为 s。</p>
<p>现在你可能觉得可以随意使用 String 对象，反正编译器会为你做性能优化。在这之前让我们深入看看编译器会为我们优化到什么程度。下面例子中采用两种方式生成 String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitherStringBuilder</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">implicit</span><span class="params">(String[] fields)</span> </span>&#123; </span><br><span class="line">        String result = <span class="string">""</span>; </span><br><span class="line">        <span class="keyword">for</span>(String field : fields) &#123; </span><br><span class="line">            result += field;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">explicit</span><span class="params">(String[] fields)</span> </span>&#123; </span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line">        <span class="keyword">for</span>(String field : fields) &#123; </span><br><span class="line">            result.append(field); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方式中，StringBuilder 是在循环体内部创建的，这意味着每进行一次循环，就会创建一个 StringBuilder 对象。第二种显示定义 StringBuilder 只生成一个 StringBuilder 对象。因此如果使用循环，且可能存在性能问题，那么最好自己创建一个 StringBuilder 对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
