<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>贪心算法总结</title>
    <url>/2020/09/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要介绍了贪心算法以及 LeetCode 的相关题目。</p>
<h2 id="1-什么是贪心算法？"><a href="#1-什么是贪心算法？" class="headerlink" title="1. 什么是贪心算法？"></a>1. 什么是贪心算法？</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基定义</a>：（英语：greedy algorithm），又称<strong>贪婪算法</strong>，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在 <a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">旅行推销员问题</a> 中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p>
<p>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p>
<p><strong>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</strong></p>
<a id="more"></a>

<p>参考 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti" target="_blank" rel="noopener">这里</a> 给出对于贪心算法的理解：</p>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>
<p>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决。</p>
<h2 id="2-区间调度问题"><a href="#2-区间调度问题" class="headerlink" title="2. 区间调度问题"></a>2. 区间调度问题</h2><p>参考 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti" target="_blank" rel="noopener">这里</a> .</p>
<h3 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1. 问题描述"></a>2.1. 问题描述</h3><p>首先解决一个很经典的贪心算法问题：区间调度问题（Interval Scheduling）。给出形如 <code>[start, end]</code> 的闭区间，设计一个算法，求出这些区间 <strong>最多有几个互不相交的区间</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p>
<p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天<strong>最多能参加几个活动呢？</strong>显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p>
<h3 id="2-2-题目分析"><a href="#2-2-题目分析" class="headerlink" title="2.2. 题目分析"></a>2.2. 题目分析</h3><p>这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：</p>
<p>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p>
<p>正确的思路其实很简单，可以分为以下三步：</p>
<ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ol>
<p>把这个思路实现成算法的话，可以按每个区间的 <code>end</code> 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多。如下图所示：</p>
<img src="/pictures/image-20200912154659563.png" alt="image-20200912154659563" style="zoom:67%;" />

<p>前三个区间属于相交区间，count 不用 +1，第四个区间就是一个新的不相交区间，访问到第四个区间时，count 需要+1，并且更新 end。</p>
<p>这种思路的贪心算法体现在：在上图中，第一个区间和第二个区间属于相交区间，肯定是二选一的，如何选择呢？当然是选择第一个。因为第一个给后面区间的选择留有更大的空间，这就属于当前情况下的最优选择，之后的选择就在这个选择的基础上，进行选择。</p>
<h3 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3. 代码"></a>2.3. 代码</h3><p>参考博客的代码，做了一些修改，这样可以和后面两个题统一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intvs.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 按 end 排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时，至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intvs.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intvs[i][<span class="number">0</span>] &gt;= end)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            end = intvs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无重叠区间-435"><a href="#3-无重叠区间-435" class="headerlink" title="3. 无重叠区间 [435]"></a>3. 无重叠区间 [435]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1. 题目描述"></a>3.1. 题目描述</h3><p><img src="/pictures/image-20200912101636226.png" alt="image-20200912101636226"></p>
<h3 id="3-2-方法一：区间调度算法（推荐）"><a href="#3-2-方法一：区间调度算法（推荐）" class="headerlink" title="3.2. 方法一：区间调度算法（推荐）"></a>3.2. 方法一：区间调度算法（推荐）</h3><p>使用本文第 2 小节的区间调度问题的思路即可。上文中，区间调度问题求的是最多不相交的区间个数，这里求移除几个区间后，区间互不重叠，即就是返回 <code>总的区间数 - 不重叠的区间数</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 互补重叠的区间数量（能留下的区间数量），初值为 1</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= end)&#123;</span><br><span class="line">            end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-方法二：从起点的贪心算法"><a href="#3-2-方法二：从起点的贪心算法" class="headerlink" title="3.2. 方法二：从起点的贪心算法"></a>3.2. 方法二：从起点的贪心算法</h3><p>参考 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode/" target="_blank" rel="noopener">这里</a> .</p>
<p>方法一是从终点的贪心算法。这里按照起点对区间进行排序。当按照起点先后顺序考虑区间的时候。我们利用一个 prev 指针追踪刚刚添加到最终列表中的区间。遍历的时候，可能遇到图中的三种情况：</p>
<p><img src="/pictures/image-20200912104507992.png" alt="image-20200912104507992"></p>
<ul>
<li>情况一：当前考虑的两个区间不重叠。在这种情况下，不移除任何区间，将 prev<em>p<strong>r</strong>e**v</em> 赋值为后面的区间，移除区间数量不变。</li>
<li>情况二：两个区间重叠，后一个区间的终点在前一个终点之前，即前一个区间包含后一个区间。显然，前一个区间的长度更小，会给后面留下更多空间，因此，prev 更新为当前区间，移除区间数量 +1.</li>
<li>情况三：两个区间重叠，后一个区间的终点在前一个终点之后，这种情况下，我们用贪心策略处理，直接移除后一个区间。（官方解释没看懂…）。我的理解是：这里如果移除前一个区间，会留出 A 的额外空间，但这部分空间是用不到的，不是当前的最优解；但如果移除后一个空间，会留出 B 的额外空间，给后面的区间留下了更多的空间。</li>
</ul>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 按照 start 排序</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// prev 指针追踪刚刚添加到最终列表中的区间</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 需要移除的数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[prev][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">// case 2</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[prev][<span class="number">1</span>] &gt; intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 3</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// case 1</span></span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-用最少数量的箭引爆气球-452"><a href="#4-用最少数量的箭引爆气球-452" class="headerlink" title="4. 用最少数量的箭引爆气球 [452]"></a>4. 用最少数量的箭引爆气球 [452]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></p>
<h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1. 题目描述"></a>4.1. 题目描述</h3><p><img src="/pictures/image-20200912114154510.png" alt="image-20200912114154510"></p>
<h3 id="4-2-方法一：区间调度算法"><a href="#4-2-方法一：区间调度算法" class="headerlink" title="4.2. 方法一：区间调度算法"></a>4.2. 方法一：区间调度算法</h3><p>参考 [这里]。</p>
<p>仔细思考后，这个问题和区间调度算法一模一样。如果最多有 n 个不重叠的区间，那么就至少需要 n 个箭头穿透所有区间，如下图所示：</p>
<img src="/pictures/image-20200912160847665.png" alt="image-20200912160847665" style="zoom: 67%;" />

<p>只是有一点不一样，在 <code>intervalSchedule</code> 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</p>
<img src="/pictures/image-20200912161028162.png" alt="image-20200912161028162" style="zoom:67%;" />

<p>所以只需要将区间调度算法稍作修改，就可以得到题目代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 按照 end 排序</span></span><br><span class="line">    Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 互不重叠的区间数量（射箭数量，选中第一个区间时，肯定会射一箭）</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 注意：这里把首尾相接的视为相交，去掉等号</span></span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; end)&#123;</span><br><span class="line">            end = points[i][<span class="number">1</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用贪心算法的题目列表"><a href="#5-使用贪心算法的题目列表" class="headerlink" title="5. 使用贪心算法的题目列表"></a>5. 使用贪心算法的题目列表</h2><p>本文中使用贪心算法解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">435</td>
<td align="center"><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">无重叠区间</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">452</td>
<td align="center"><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">用最少数量的箭引爆气球</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">122</td>
<td align="center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></td>
<td align="center">Hard</td>
</tr>
</tbody></table>
<h2 id="6-买卖股票的最佳时机-II-122"><a href="#6-买卖股票的最佳时机-II-122" class="headerlink" title="6. 买卖股票的最佳时机 II [122]"></a>6. 买卖股票的最佳时机 II [122]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p>
<h3 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1. 题目描述"></a>6.1. 题目描述</h3><p><img src="/pictures/image-20200911103413418.png" alt="image-20200911103413418"></p>
<h3 id="6-2-贪心算法"><a href="#6-2-贪心算法" class="headerlink" title="6.2. 贪心算法"></a>6.2. 贪心算法</h3><p>参考 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/" target="_blank" rel="noopener">这里</a> 的方法二。</p>
<p>这道题使用贪心算法的流程是这样的：从第 i 天（这里 i &gt;= 1）开始，与第 i - 1 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。下面对这个算法进行几点说明：</p>
<ol>
<li><p>该算法仅可以用于计算，但计算的过程并不是真正交易的过程，但可以用贪心算法计算题目要求的最大利润。下面说明这个等价性：以 [1, 2, 3, 4] 为例，这 4 天的股价依次上升，按照贪心算法，得到的最大利润是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res =  (prices[<span class="number">3</span>] - prices[<span class="number">2</span>]) + (prices[<span class="number">2</span>] - prices[<span class="number">1</span>]) + (prices[<span class="number">1</span>] - prices[<span class="number">0</span>])</span><br><span class="line">    =  prices[<span class="number">3</span>] - prices[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>仔细观察上面的式子，按照贪心算法，在索引为 1、2、3 的这三天，我们做的操作应该是买进昨天的，卖出今天的，虽然这种操作题目并不允许，但是它等价于：“在索引为 0 的那一天买入，在索引为 3 的那一天卖出”。</p>
</li>
<li><p>解释一下，它为什么叫做贪心算法？</p>
<p>“贪心算法” 在每一步总是做出在当前看来最好的选择。</p>
<p>因此，</p>
<ul>
<li><p>“贪心算法” 和 “动态规划”、“回溯搜索” 算法一样，完成一件事情，是分步决策的；</p>
</li>
<li><p>“贪心算法” 在每一步总是做出在当前看来最好的选择，我是这样理解 “最好” 这两个字的意思：</p>
<ul>
<li>“最好” 的意思往往根据题目而来，可能是 “最小”，也可能是 “最大”；</li>
</ul>
</li>
<li><p>贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。</p>
</li>
<li><p>这道题 “贪心” 的地方在于，对于 “今天的股价 - 昨天的股价”，得到的结果有 3 种可能：（1）正数（2）0（3）负数。<strong>贪心算法的决策是：只加正数</strong> 。</p>
</li>
</ul>
</li>
</ol>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res += diff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-参考引用"><a href="#7-参考引用" class="headerlink" title="7. 参考引用"></a>7. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tan-xin-suan-fa-zhi-qu-jian-tiao-du-wen-ti</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表总结</title>
    <url>/2020/08/17/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要总结了 LeetCode 上链表相关的题目，会持续更新~</p>
<h2 id="1-链表相关的题目列表"><a href="#1-链表相关的题目列表" class="headerlink" title="1. 链表相关的题目列表"></a>1. 链表相关的题目列表</h2><p>本文的题目列表如下：</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">83</td>
<td align="center"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">82</td>
<td align="center"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">86</td>
<td align="center"><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">分隔链表</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">61</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">206</td>
<td align="center"><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">92</td>
<td align="center"><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">反转链表 II</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="2-删除排序链表中的重复元素-83"><a href="#2-删除排序链表中的重复元素-83" class="headerlink" title="2. 删除排序链表中的重复元素 [83]"></a>2. 删除排序链表中的重复元素 [83]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></p>
<h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1. 题目描述"></a>2.1. 题目描述</h3><p><img src="/pictures/image-20200818094630464.png" alt="image-20200818094630464"></p>
<h3 id="2-2-方法一：迭代"><a href="#2-2-方法一：迭代" class="headerlink" title="2.2. 方法一：迭代"></a>2.2. 方法一：迭代</h3><p>保存前一个节点 pre, 遇到与 pre 相同的节点就往后移，找到不同的节点，接到 pre 的后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line"></span><br><span class="line">    ListNode pre = head, curr = head.next;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; curr.val == pre.val)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = curr;</span><br><span class="line">        pre = curr;</span><br><span class="line">        <span class="keyword">if</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-方法二：迭代（去掉-pre）"><a href="#2-3-方法二：迭代（去掉-pre）" class="headerlink" title="2.3. 方法二：迭代（去掉 pre）"></a>2.3. 方法二：迭代（去掉 pre）</h3><p>参考 <a href="https://leetcode.wang/leetCode-83-Remove-Duplicates-from-Sorted-List.html" target="_blank" rel="noopener">这里</a> 解法二。这道题其实不用 pre 节点也可以完成，不用找到所有重复的数字进行删除，即遇到一个重复数字，删除一个。这样代码看起来更加简洁了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-删除排序链表中的重复元素-II-82"><a href="#3-删除排序链表中的重复元素-II-82" class="headerlink" title="3. 删除排序链表中的重复元素 II [82]"></a>3. 删除排序链表中的重复元素 II [82]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1. 题目描述"></a>3.1. 题目描述</h3><p><img src="/pictures/image-20200818100806984.png" alt="image-20200818100806984"></p>
<p>注意：和上一题相比，本题要求只要是重复的元素需要全部删除，一个不留。</p>
<h3 id="3-2-迭代"><a href="#3-2-迭代" class="headerlink" title="3.2. 迭代"></a>3.2. 迭代</h3><p>这道题自己写了很久…还是没写出来..</p>
<p>参考 <a href="https://leetcode.wang/leetCode-82-Remove-Duplicates-from-Sorted-ListII.html" target="_blank" rel="noopener">这里</a> 的解法一。对于链表的操作，如果头结点可能删除，可以使用 dummy 节点，指向 head，最终返回 dummy.next 节点即可，这样可以简化边界问题，不用单独处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义dummy节点</span></span><br><span class="line">    ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode dummy = pre;</span><br><span class="line">    pre.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> equal = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// cur 和 cur.next 一直相等，一直后移</span></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            equal = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相等</span></span><br><span class="line">        <span class="comment">// pre.next 直接指向 cur.next 删除所有重复数字</span></span><br><span class="line">        <span class="keyword">if</span>(equal)&#123;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不相等</span></span><br><span class="line">            <span class="comment">// pre 移到 cur 的地方</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cur 后移</span></span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-分隔链表-86"><a href="#4-分隔链表-86" class="headerlink" title="4. 分隔链表 [86]"></a>4. 分隔链表 [86]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></p>
<h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1. 题目描述"></a>4.1. 题目描述</h3><p><img src="/pictures/image-20200818112245505.png" alt="image-20200818112245505"></p>
<h3 id="4-2-解法一：分成两个链表"><a href="#4-2-解法一：分成两个链表" class="headerlink" title="4.2. 解法一：分成两个链表"></a>4.2. 解法一：分成两个链表</h3><p>注意链表出现环的情况，参考 <a href="https://leetcode.wang/leetCode-86-Partition-List.html" target="_blank" rel="noopener">这里</a> 的解法二。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小于x的链表</span></span><br><span class="line">    ListNode lowDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode lowCur = lowDummy;</span><br><span class="line">    <span class="comment">// 大于等于x的链表</span></span><br><span class="line">    ListNode highDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode highCur = highDummy;</span><br><span class="line"></span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; x)&#123;</span><br><span class="line">            lowCur.next = cur;</span><br><span class="line">            lowCur = lowCur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            highCur.next = cur;</span><br><span class="line">            highCur = highCur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一定要注意添加这一步，不然链表会出现环</span></span><br><span class="line">    highCur.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 链表拼接</span></span><br><span class="line">    lowCur.next = highDummy.next;</span><br><span class="line">    <span class="keyword">return</span> lowDummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-解法二：头插法"><a href="#4-3-解法二：头插法" class="headerlink" title="4.3. 解法二：头插法"></a>4.3. 解法二：头插法</h3><p>遍历整个链表，找到小于 x 的节点，插入到前面。前面和后面都需要一个 pre 节点保存应该插入和删除的位置。（自己想的..）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// pre 表示遍历节点cur的前一个，用于删除</span></span><br><span class="line">    ListNode cur = head, pre = dummy;</span><br><span class="line">    <span class="comment">// pre2 表示插入位置的前一个</span></span><br><span class="line">    ListNode pre2 = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = cur.val;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; x)&#123;</span><br><span class="line">            <span class="comment">// 删除原位置元素</span></span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            <span class="comment">// 插入到前面位置</span></span><br><span class="line">            cur.next = pre2.next;</span><br><span class="line">            pre2.next = cur;</span><br><span class="line">            pre2 = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的题目，一定要仔细。</p>
<h2 id="5-反转链表-206"><a href="#5-反转链表-206" class="headerlink" title="5. 反转链表 [206]"></a>5. 反转链表 [206]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></p>
<h3 id="5-1-题目描述"><a href="#5-1-题目描述" class="headerlink" title="5.1. 题目描述"></a>5.1. 题目描述</h3><p><img src="/pictures/image-20200826094442518.png" alt="image-20200826094442518"></p>
<h3 id="5-2-方法一：迭代"><a href="#5-2-方法一：迭代" class="headerlink" title="5.2. 方法一：迭代"></a>5.2. 方法一：迭代</h3><p>迭代方法比较好想，添加一个 dummy 节点更好理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode tmp = cur.next;</span><br><span class="line">        cur.next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-方法二：递归"><a href="#5-3-方法二：递归" class="headerlink" title="5.3. 方法二：递归"></a>5.3. 方法二：递归</h3><p>思路参考：<a href="https://leetcode.wang/leetcode-206-Reverse-Linked-List.html" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大问题变为小问题：head.next作为剩余部分的头指针</span></span><br><span class="line">    ListNode newHead = reverseList(head.next);</span><br><span class="line">    <span class="comment">// head.next 代表新链表的尾，将他的 next 置为 head，即就是把 head 加到末尾</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-反转链表-II-92"><a href="#6-反转链表-II-92" class="headerlink" title="6. 反转链表 II [92]"></a>6. 反转链表 II [92]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></p>
<h3 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1. 题目描述"></a>6.1. 题目描述</h3><p><img src="/pictures/image-20200826101920949.png" alt="image-20200826101920949"></p>
<h3 id="6-2-代码"><a href="#6-2-代码" class="headerlink" title="6.2. 代码"></a>6.2. 代码</h3><p>头结点需要单独处理，使用 dummy 节点。这题不难，仔细一点注意节点指向即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == count)&#123;</span><br><span class="line">            ListNode pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">for</span>(; count &lt;= n; count++)&#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = pre2.next;</span><br><span class="line">                pre2.next = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-参考引用"><a href="#7-参考引用" class="headerlink" title="7. 参考引用"></a>7. 参考引用</h2><ol>
<li><a href="https://leetcode.wang/leetCode-83-Remove-Duplicates-from-Sorted-List.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-83-Remove-Duplicates-from-Sorted-List.html</a></li>
<li><a href="https://leetcode.wang/leetCode-86-Partition-List.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-86-Partition-List.html</a></li>
<li><a href="https://leetcode.wang/leetcode-206-Reverse-Linked-List.html" target="_blank" rel="noopener">https://leetcode.wang/leetcode-206-Reverse-Linked-List.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划总结</title>
    <url>/2020/08/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要介绍了动态规划的概念、解题框架，并以斐波那契数列、零钱兑换为例，进一步说明动态规划如何运用和理解。另外，本文还解决了LeetCode中部分使用动态规划思想的题目，这部分会持续更新。</p>
<h2 id="1-什么是动态规划？"><a href="#1-什么是动态规划？" class="headerlink" title="1. 什么是动态规划？"></a>1. 什么是动态规划？</h2><p><a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">维基定义</a>：（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p>
<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<a id="more"></a>

<h3 id="1-1-适用情况"><a href="#1-1-适用情况" class="headerlink" title="1.1 适用情况"></a>1.1 适用情况</h3><ol>
<li>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
<li>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</li>
</ol>
<h2 id="2-动态规划解题框架"><a href="#2-动态规划解题框架" class="headerlink" title="2. 动态规划解题框架"></a>2. 动态规划解题框架</h2><p>这一节参考 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">这里</a> 给出一些对于动态规划的理解和解体框架。</p>
<p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等。</p>
<p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。</p>
<p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p>
<p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>下文中的斐波那契数列可以帮助理解动态规划问题，零钱兑换问题使用总结的框架进行流程化求解。</p>
<h2 id="3-以斐波那契数列-509-为例"><a href="#3-以斐波那契数列-509-为例" class="headerlink" title="3. 以斐波那契数列 [509] 为例"></a>3. 以斐波那契数列 [509] 为例</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 N，计算 F(N)。</p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p>0 ≤ N ≤ 30</p>
<h3 id="3-2-方法一：暴力递归"><a href="#3-2-方法一：暴力递归" class="headerlink" title="3.2 方法一：暴力递归"></a>3.2 方法一：暴力递归</h3><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，画出的递归树如下：</p>
<img src="/pictures/1-1595902107828.jpg" alt="img" style="zoom:33%;" />

<p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p>
<p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<h3 id="3-3-方法二：带备忘录的递归解法"><a href="#3-3-方法二：带备忘录的递归解法" class="headerlink" title="3.3 方法二：带备忘录的递归解法"></a>3.3 方法二：带备忘录的递归解法</h3><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经计算过</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p>
<p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p>
<p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<h3 id="3-4-方法三：动态规划"><a href="#3-4-方法三：动态规划" class="headerlink" title="3.4 方法三：动态规划"></a>3.4 方法三：动态规划</h3><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<img src="/pictures/fib.png" alt="img" style="zoom: 67%;" />

<p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib3</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = pre + curr;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<h2 id="4-框架求解零钱兑换-322"><a href="#4-框架求解零钱兑换-322" class="headerlink" title="4. 框架求解零钱兑换 [322]"></a>4. 框架求解零钱兑换 [322]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p>
<h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>


<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<h3 id="4-2-题目分析与代码"><a href="#4-2-题目分析与代码" class="headerlink" title="4.2 题目分析与代码"></a>4.2 题目分析与代码</h3><p>分析参考 <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie#er-cou-ling-qian-wen-ti" target="_blank" rel="noopener">这里</a> , 使用上文中总结的动态规划框架。</p>
<p>首先，这是一个动态规划问题。满足三个条件：</p>
<ol>
<li><p>最优子结构。即问题的最优解所包含的子问题的解也是最优的，且子问题间必须相互独立。什么叫做相互独立？我用一个直观的例子来讲解。</p>
<p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制约，是互相独立的。</p>
</li>
<li><p>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p>
</li>
<li><p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。</p>
</li>
</ol>
<p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p>
<p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p>
<p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p>
<p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。<em>目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。</em> 所以说 <strong>所有硬币的面值</strong> ，就是你的「选择」。</p>
<p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p>
<p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p>
<h4 id="4-2-1-先使用暴力递归"><a href="#4-2-1-先使用暴力递归" class="headerlink" title="4.2.1 先使用暴力递归"></a>4.2.1 先使用暴力递归</h4><p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>据此，我们可以得出状态转移方程如下图，以上解法属于暴力递归解法。</p>
<img src="/pictures/coin.png" alt="img" style="zoom:67%;" />

<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<h4 id="4-2-2-带备忘录的递归解法，消除重叠子问题"><a href="#4-2-2-带备忘录的递归解法，消除重叠子问题" class="headerlink" title="4.2.2 带备忘录的递归解法，消除重叠子问题"></a>4.2.2 带备忘录的递归解法，消除重叠子问题</h4><p>显然，上述解法中存在重叠子问题，比如<code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p>
<img src="/pictures/5-1595987693352.jpg" alt="img" style="zoom: 33%;" />

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<h4 id="4-2-3-动态规划，自底向上"><a href="#4-2-3-动态规划，自底向上" class="headerlink" title="4.2.3 动态规划，自底向上"></a>4.2.3 动态规划，自底向上</h4><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p>
<p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i] = n 表示：当目标金额为 i 时，至少需要 n 枚硬币</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化dp数组，初始值为 amount+1, 因为dp 数组最大值取到 amount</span></span><br><span class="line">    Arrays.fill(dp, amount+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">        <span class="comment">// 内层for求所有子问题的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (j - coin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = dp[j] &lt; dp[j - coin] + <span class="number">1</span> ? dp[j] : dp[j - coin] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount+<span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<h2 id="5-动态规划总结"><a href="#5-动态规划总结" class="headerlink" title="5. 动态规划总结"></a>5. 动态规划总结</h2><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p>
<p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p>
<p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p>
<p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p>
<p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>
<p>之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。</p>
<h2 id="6-使用动态规划的题目列表"><a href="#6-使用动态规划的题目列表" class="headerlink" title="6. 使用动态规划的题目列表"></a>6. 使用动态规划的题目列表</h2><p>本文中使用动态规划解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">509</td>
<td align="center"><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">322</td>
<td align="center"><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">300</td>
<td align="center"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1143</td>
<td align="center"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">72</td>
<td align="center"><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">正则表达式匹配</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">62</td>
<td align="center"><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">63</td>
<td align="center"><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现 strStr()</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">64</td>
<td align="center"><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">85</td>
<td align="center"><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">87</td>
<td align="center"><a href="https://leetcode-cn.com/problems/scramble-string/" target="_blank" rel="noopener">扰乱字符串</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">89</td>
<td align="center"><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">格雷编码</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">91</td>
<td align="center"><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">97</td>
<td align="center"><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">交错字符串</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">115</td>
<td align="center"><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">不同的子序列</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">120</td>
<td align="center"><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a></td>
<td align="center">Hard</td>
</tr>
</tbody></table>
<h2 id="7-例题：最长上升子序列-300"><a href="#7-例题：最长上升子序列-300" class="headerlink" title="7. 例题：最长上升子序列 [300]"></a>7. 例题：最长上升子序列 [300]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></p>
<h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。</p>
<h3 id="7-2-题目分析"><a href="#7-2-题目分析" class="headerlink" title="7.2 题目分析"></a>7.2 题目分析</h3><p>本题分析参考 <a href="https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g" target="_blank" rel="noopener">这里</a> .</p>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p>
<h3 id="7-3-方法一：动态规划（如何找到状态转移关系）"><a href="#7-3-方法一：动态规划（如何找到状态转移关系）" class="headerlink" title="7.3 方法一：动态规划（如何找到状态转移关系）"></a>7.3 方法一：动态规划（如何找到状态转移关系）</h3><p>动态规划的难点本来就在于寻找正确的状态转移方程，本文就借助经典的「最长递增子序列问题」来讲一讲设计动态规划的通用技巧：<strong>数学归纳思想</strong>。</p>
<p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么<strong>我们先假设这个结论在 k 时成立，然后根据这个假设，想办法推导证明出 <code>k=n</code> 的时候此结论也成立</strong>。如果能够证明出来，那么就说明这个结论对于 <code>k</code> 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <code>dp[0...i-1]</code> 都已经被算出来了，然后问自己：怎么通过这些结果算出 <code>dp[i]</code>？</p>
<p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 <code>dp[i]</code> 的值到底代表着什么？</p>
<p><strong>我们的定义是这样的：<code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。</strong></p>
<p>PS：<strong>为什么这样定义呢？</strong> 这是解决子序列问题的一个套路，后文动态规划之子序列问题解题模板 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 <code>dp</code> 数组的定义方法也就那几种。</p>
<p>反过来想，如果 <code>dp[i]</code> 表示 <code>nums[0...i]</code> 这个数组中的最长递增子序列的长度，当求得 <code>dp[i]</code> 时，想要求出 <code>dp[i+1]</code> 是不行的，因为递增子序列是从数组中选出的，知道 <code>dp[i]</code> 并不能确定当前选择的是哪几个数字，当然也不知道选出的递增子序列最后一位，这样是没法推出 <code>dp[i+1]</code> 的。但如果我们定义 <code>dp[i]</code> 表示以<code>nums[i]</code> 结尾的最长递增子序列的长度，就可以明确知道选出的递增子序列的最后一位，从而推出 <code>dp[i]</code> . 只有这样定义才能将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程。</p>
<p>根据这个定义，我们就可以推出 base case：<code>dp[i]</code> 初始值为 1，因为以 <code>nums[i]</code> 结尾的最长递增子序列起码要包含它自己。</p>
<p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p>
<p>那么我们应该怎么设计算法逻辑来正确计算每个 <code>dp[i]</code> 呢？</p>
<p>这就是动态规划的重头戏了，要思考如何设计算法逻辑进行状态转移，才能正确运行呢？这里就可以使用数学归纳的思想：</p>
<p><strong>假设我们已经知道了 <code>dp[0..4]</code> 的所有结果，我们如何通过这些已知结果推出 <code>dp[5]</code> 呢</strong>？</p>
<p>根据刚才我们对 <code>dp</code> 数组的定义，现在想求 <code>dp[5]</code> 的值，也就是想求以 <code>nums[5]</code> 为结尾的最长递增子序列。</p>
<p><strong><code>nums[5] = 3</code>，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一</strong>。</p>
<p>显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 <code>dp[5]</code> 的值即可。</p>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i] = n 表示：以 nums[i] 这个数字结尾的最长上升子序列的长度（想不到）</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 初始化，最长上升子序列最少为数字本身，故初始化为1</span></span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下如何找到动态规划的状态转移关系：</p>
<p><strong>1、</strong>明确 <code>dp</code> 数组所存数据的含义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p><strong>2、</strong>根据 <code>dp</code> 数组的定义，运用数学归纳法的思想，假设 <code>dp[0...i-1]</code> 都已知，想办法求出 <code>dp[i]</code>，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 <code>dp</code> 数组的定义不够恰当，需要重新定义 <code>dp</code> 数组的含义；或者可能是 <code>dp</code> 数组存储的信息还不够，不足以推出下一步的答案，需要把 <code>dp</code> 数组扩大成二维数组甚至三维数组。</p>
<h3 id="7-4-方法二：二分查找"><a href="#7-4-方法二：二分查找" class="headerlink" title="7.4 方法二：二分查找"></a>7.4 方法二：二分查找</h3><p>详解请看：<a href="https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g##" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g##</a></p>
<p>这个解法的时间复杂度为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 牌初始堆数定义为0</span></span><br><span class="line">    <span class="keyword">int</span> piles = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 要处理的扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> poker = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//*********** 二分查找：搜索左侧边界 ***************/</span></span><br><span class="line">        <span class="comment">// piles 表示堆数，即就是数组的长度；如果写成 right = piles + 1, 当 nums=[0] 时返回 0， 正确结果是 1</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = piles;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(top[mid] == poker)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(top[mid] &gt; poker)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(top[mid] &lt; poker)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 牌比每一个都大，则新建一个堆</span></span><br><span class="line">        <span class="keyword">if</span>(left == piles)&#123;</span><br><span class="line">            piles++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 牌比每一个都小、或者找到合适位置，放入 top 数组即可</span></span><br><span class="line">        top[left] = poker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> piles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-例题：最长公共子序列-1143"><a href="#8-例题：最长公共子序列-1143" class="headerlink" title="8. 例题：最长公共子序列 [1143]"></a>8. 例题：最长公共子序列 [1143]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p>
<h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>若这两个字符串没有公共子序列，则返回 0。 </p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abcde"</span>, text2 = <span class="string">"ace"</span> </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 <span class="string">"ace"</span>，它的长度为 3。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abc"</span>, text2 = <span class="string">"def"</span></span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>


<p>提示:</p>
<p>1 &lt;= text1.length &lt;= 1000<br>1 &lt;= text2.length &lt;= 1000<br>输入的字符串只含有小写英文字符。</p>
<h3 id="8-2-题目分析"><a href="#8-2-题目分析" class="headerlink" title="8.2 题目分析"></a>8.2 题目分析</h3><p>最长公共子序列（Longest Common Subsequence，简称 LCS）是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。</p>
<p>详细分析参考：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie</a></p>
<h3 id="8-3-代码"><a href="#8-3-代码" class="headerlink" title="8.3 代码"></a>8.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="comment">// 让 text1,text2 的索引从 1 开始</span></span><br><span class="line">    <span class="comment">// dp[i][j] = n 表示：对于 text1[1...i] 和 text2[1...j] 的最长公共子序列为 n</span></span><br><span class="line">    <span class="comment">//base case 是：dp[0][..] 和 dp[..][0] 初始化为0</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-例题：最大子序列和-53"><a href="#9-例题：最大子序列和-53" class="headerlink" title="9. 例题：最大子序列和 [53]"></a>9. 例题：最大子序列和 [53]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>


<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="9-2-题目分析"><a href="#9-2-题目分析" class="headerlink" title="9.2 题目分析"></a>9.2 题目分析</h3><p>参考：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu</a></p>
<p>解决这个问题需要动态规划技巧，但是 <code>dp</code> 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 <code>dp</code> 数组：</p>
<p><strong><code>nums[0..i]</code></strong> <strong>中的「最大的子数组和」为</strong> <strong><code>dp[i]</code></strong>。</p>
<p>如果这样定义的话，整个 <code>nums</code> 数组的「最大子数组和」就是 <code>dp[n-1]</code>。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 <code>dp[i-1]</code>，如何推导出 <code>dp[i]</code> 呢？利用数学归纳法，你能用 <code>dp[i]</code> 推出 <code>dp[i+1]</code> 吗？</p>
<p><strong>实际上是不行的，因为子数组一定是连续的，按照我们当前</strong> <strong><code>dp</code></strong> <strong>数组定义，并不能保证</strong> <strong><code>nums[0..i]</code></strong> <strong>中的最大子数组与</strong> <strong><code>nums[i+1]</code></strong> <strong>是相邻的</strong>，也就没办法从 <code>dp[i]</code> 推导出 <code>dp[i+1]</code>。</p>
<p>所以说我们这样定义 <code>dp</code> 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 <code>dp</code> 数组的含义：</p>
<p><strong>以</strong> <strong><code>nums[i]</code></strong> <strong>为结尾的「最大子数组和」为</strong> <strong><code>dp[i]</code></strong>。</p>
<p>这种定义之下，想得到整个 <code>nums</code> 数组的「最大子数组和」，不能直接返回 <code>dp[n-1]</code>，而需要遍历整个 <code>dp</code> 数组。</p>
<p>虽然说动态规划推状态转移方程确实比较玄学，但大部分还是有些规律可循的。</p>
<p>这道「最大子数组和」就和「最长递增子序列」非常类似，<code>dp</code> 数组的定义是「以 <code>nums[i]</code> 为结尾的最大子数组和/最长递增子序列为 <code>dp[i]</code>」。因为只有这样定义才能将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程。</p>
<h3 id="9-3-代码"><a href="#9-3-代码" class="headerlink" title="9.3 代码"></a>9.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// dp[i] = x 表示以 nums[i] 结尾的最大子序列和为x</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-例题：编辑距离-72"><a href="#10-例题：编辑距离-72" class="headerlink" title="10. 例题：编辑距离 [72]"></a>10. 例题：编辑距离 [72]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p>
<h3 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 <span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="10-2-题目分析"><a href="#10-2-题目分析" class="headerlink" title="10.2 题目分析"></a>10.2 题目分析</h3><p>dp 问题自底向上求解，定义 dp 数组：<code>dp[i][j] = n</code> 表示：<code>word1[1..i]</code> 和 <code>word2[1..j]</code> 的最小编辑距离为 n，注意 word1 和 word2 的下标从1开始。</p>
<p>base case：当 i=0 或者 j=0 时，属于base case。</p>
<p>状态：距离。</p>
<p>选择：有三种选择，即删除、替换、插入，选出距离最小的。做出每一种选择后，使用前面求出 dp 数组的值。比如如果选择删除，则 <code>dp[i][j] = dp[i-1][j] + 1</code> ；如果选择替换，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>；如果选择插入，则<code>dp[i][j] = dp[i][j-1] + 1</code>入，当插入时应该注意，不能在 <code>word1[i]</code> 之前插入，因为在前面插入后，没法使用已经求出的 dp 数组的值，而是在 <code>word1[i]</code> 的后面插入。</p>
<p>状态转移方程：如果字符相等，跳过；否则在删除、替换、插入中选择一种。</p>
<h3 id="10-3-代码"><a href="#10-3-代码" class="headerlink" title="10.3 代码"></a>10.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">    <span class="comment">//word1 和 word2 的下标从 1 开始</span></span><br><span class="line">    <span class="comment">//dp[i][j] = n 表示：word1[1..i] 和 word2[1..j] 的最小编辑距离为 n</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//三种情况：插入、删除、替换</span></span><br><span class="line">                dp[i][j] = min(dp[i][j-<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.min(a,b),c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-例题：正则表达式匹配-10"><a href="#11-例题：正则表达式匹配-10" class="headerlink" title="11. 例题：正则表达式匹配 [10]"></a>11. 例题：正则表达式匹配 [10]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p>
<h3 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1 题目描述"></a>11.1 题目描述</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">'.'</span> 匹配任意单个字符</span><br><span class="line"><span class="string">'*'</span> 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>


<p>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="string">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">".*"</span> 表示可匹配零个或多个（<span class="string">'*'</span>）任意字符（<span class="string">'.'</span>）。</span><br></pre></td></tr></table></figure>

<h3 id="11-2-题目分析"><a href="#11-2-题目分析" class="headerlink" title="11.2 题目分析"></a>11.2 题目分析</h3><p>两个字符串比较的动态规划问题。<code>dp[i][j]</code> 表示 <code>s[i-1]</code> 和 <code>p[i-1]</code> 是否可以匹配。</p>
<p>base case：<code>dp[0][0] = true</code>， 但这还不够，字符串 “” 和 “a*” 也是匹配的。</p>
<p>状态：是否可以匹配。</p>
<p>选择：字符串 s 和 p 各前进一位。</p>
<p>状态转换：见代码。</p>
<h3 id="11-3-代码"><a href="#11-3-代码" class="headerlink" title="11.3 代码"></a>11.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = p.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp 数组中 字符串下标从 1 开始，索引 0 存储空字符</span></span><br><span class="line">    <span class="comment">//dp[i][j] = true 表示：s[0..(i-1)] p[0..(j-1)] 可以匹配</span></span><br><span class="line">    <span class="comment">//base case：dp[..][0] 初始化为 0, 不存在可以匹配的可能</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//base case: dp[0][..] 初始化，如果出现 * 则可以消去上一个字符，且 上上一个字符对应 dp 值为 true，则当前 dp 值为true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++)&#123;</span><br><span class="line">        <span class="comment">//j-1</span></span><br><span class="line">        <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//j+1</span></span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">            <span class="comment">//如果元素匹配或者为任意元素</span></span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'.'</span> || s.charAt(i) == p.charAt(j))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="comment">//如果前一个元素不匹配，则消去这两个元素</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * 如果前一个元素匹配，存在三种情况：</span></span><br><span class="line"><span class="comment">                        * 重复前一个字符多次（abbbb ab*）dp[i + 1][j + 1] = dp[i][j + 1]</span></span><br><span class="line"><span class="comment">                        * 重复前一个字符一次（ab ab*）dp[i + 1][j + 1] = dp[i + 1][j]</span></span><br><span class="line"><span class="comment">                        * 重复前一个字符零次（a ab*）dp[i + 1][j + 1] = dp[i + 1][j - 1]</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br></pre></td></tr></table></figure>

<h2 id="12-例题：通配符匹配-44"><a href="#12-例题：通配符匹配-44" class="headerlink" title="12. 例题：通配符匹配 [44]"></a>12. 例题：通配符匹配 [44]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></p>
<h3 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1 题目描述"></a>12.1 题目描述</h3><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">'?'</span> 可以匹配任何单个字符。</span><br><span class="line"><span class="string">'*'</span> 可以匹配任意字符串（包括空字符串）。</span><br><span class="line">两个字符串完全匹配才算匹配成功。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<p>输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">'*'</span> 可以匹配任意字符串。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"cb"</span></span><br><span class="line">p = <span class="string">"?a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">'?'</span> 可以匹配 <span class="string">'c'</span>, 但第二个 <span class="string">'a'</span> 无法匹配 <span class="string">'b'</span>。</span><br></pre></td></tr></table></figure>

<p>示例 4:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"adceb"</span></span><br><span class="line">p = <span class="string">"*a*b"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 第一个 <span class="string">'*'</span> 可以匹配空字符串, 第二个 <span class="string">'*'</span> 可以匹配字符串 <span class="string">"dce"</span>.</span><br></pre></td></tr></table></figure>

<p>示例 5:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"acdcb"</span></span><br><span class="line">p = <span class="string">"a*c?b"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>PS：? 不可以匹配空字符串。</p>
<h3 id="12-2-题目分析"><a href="#12-2-题目分析" class="headerlink" title="12.2 题目分析"></a>12.2 题目分析</h3><p>两个字符串比较的动态规划问题。</p>
<p>本体类似于上一题，但我在考虑问题时始终不能跳出问题本身，使用动态规划的思想，而是一再考虑可能出现的不同情况，特别是出现 * 时。例如字符串 “abc” 和 “a*” , 当 p 中出现了 * 时，有两种处理方式：</p>
<ol>
<li>把 * 当做一个空字符串，那么 <code>dp[i + 1][j + 1] = dp[i + 1][j]</code></li>
<li><code>*</code> 匹配任意字符串，那么 <code>dp[i + 1][j + 1] = dp[i][j + 1]</code></li>
</ol>
<p>要注意理解，dp 问题注重的是当前状态的转化，即只考虑当前这一位，并把这个问题转化为更小问题的答案。</p>
<h3 id="12-3-代码"><a href="#12-3-代码" class="headerlink" title="12.3 代码"></a>12.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = p.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp 数组中 字符串下标从 1 开始，索引 0 存储空字符</span></span><br><span class="line">    <span class="comment">//dp[i][j] = true 表示：s[0..(i-1)] p[0..(j-1)] 可以匹配</span></span><br><span class="line">    <span class="comment">//base case：dp[..][0] 初始化为 0, 不存在可以匹配的可能</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//base case: dp[0][..] 初始化，如果出现 * 则可以视为空字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'?'</span> || s.charAt(i) == p.charAt(j))&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="comment">//情况一：s = "a", p = "a*", 此时 * 被当做空字符串 dp[i + 1][j + 1] = dp[i + 1][j]</span></span><br><span class="line">                <span class="comment">//情况二：s = "abc", p = "a*", 此时 * 被当做任意字符串 dp[i + 1][j + 1] = dp[i][j + 1]</span></span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-例题：不同路径-62"><a href="#13-例题：不同路径-62" class="headerlink" title="13. 例题：不同路径 [62]"></a>13. 例题：不同路径 [62]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p>
<h3 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1 题目描述"></a>13.1 题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<h3 id="13-2-题目分析"><a href="#13-2-题目分析" class="headerlink" title="13.2 题目分析"></a>13.2 题目分析</h3><p>简单题。</p>
<p><code>dp[i-1][j-1]</code>表示：i * j 的网格上机器人的移动步数</p>
<p>状态转移：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<h3 id="13-3-代码"><a href="#13-3-代码" class="headerlink" title="13.3 代码"></a>13.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i-1][j-1] 表示：i * j 的网格上机器人的移动步数</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-例题：不同路径II-63"><a href="#14-例题：不同路径II-63" class="headerlink" title="14. 例题：不同路径II [63]"></a>14. 例题：不同路径II [63]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></p>
<h3 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1 题目描述"></a>14.1 题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<h3 id="14-2-题目分析"><a href="#14-2-题目分析" class="headerlink" title="14.2 题目分析"></a>14.2 题目分析</h3><p>注意与上一题的区别。</p>
<h3 id="14-3-代码"><a href="#14-3-代码" class="headerlink" title="14.3 代码"></a>14.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//dp[i-1][j-1] 表示：i * j 的网格上机器人的移动步数</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// base case，与上一题不同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-例题：实现strStr-15"><a href="#15-例题：实现strStr-15" class="headerlink" title="15. 例题：实现strStr() [15]"></a>15. 例题：实现strStr() [15]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></p>
<h3 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1 题目描述"></a>15.1 题目描述</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"aaaaa"</span>, needle = <span class="string">"bba"</span></span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h3 id="15-2-题目分析"><a href="#15-2-题目分析" class="headerlink" title="15.2 题目分析"></a>15.2 题目分析</h3><p>详细分析参考：<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa" target="_blank" rel="noopener">这里</a> . 太难了….</p>
<p>标准的KMP方法在我的另一篇博客：<a href="https://juliajiang7.github.io/2020/07/17/KMP算法/#more" target="_blank" rel="noopener">这里</a> .</p>
<p>我们可以认为 <code>pat</code> 的匹配就是状态的转移。比如当 pat = “ABABC”：</p>
<img src="/pictures/state.jpg" alt="img" style="zoom:33%;" />

<p>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时 <code>pat</code> 处于起始状态，一旦转移到终止状态，就说明在 <code>txt</code> 中找到了 <code>pat</code>。比如说当前处于状态 2，就说明字符 “AB” 被匹配：</p>
<img src="/pictures/state2.jpg" alt="img" style="zoom:33%;" />

<p><code>dp[j][c] = next</code> 表示，当前是状态 <code>j</code>，遇到了字符 <code>c</code>，应该转移到状态 <code>next</code>。</p>
<p>base case：<code>dp[0][pat.charAt(0)] = 1;</code>, 只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）.</p>
<p>如何构建这个 <code>dp</code> 数组，需要一个辅助状态 <code>X</code>，它永远比当前状态 <code>j</code> 落后一个状态，拥有和 <code>j</code> 最长的相同前缀，我们给它起了个名字叫「影子状态」。</p>
<p>在构建当前状态 <code>j</code> 的转移方向时，只有字符 <code>pat[j]</code> 才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态 <code>X</code> 应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中 <code>other</code> 是除了 <code>pat[j]</code> 之外所有字符）。</p>
<p>对于影子状态 <code>X</code>，我们把它初始化为 0，并且随着 <code>j</code> 的前进进行更新，更新的方式和 search 过程更新 <code>j</code> 的过程非常相似（<code>X = dp[X][pat[j]]</code>）。</p>
<h3 id="15-3-代码"><a href="#15-3-代码" class="headerlink" title="15.3 代码"></a>15.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span></span>&#123;</span><br><span class="line">    String txt = haystack;</span><br><span class="line">    String pat = needle;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line">    <span class="keyword">int</span> N = txt.length();</span><br><span class="line">    <span class="keyword">if</span>(M == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j][c] = i 表示： 当前状态为 j，且遇到的下一个字符是 c 时, 下一个状态位 i</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line">    KMP(pat, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pat 的初始状态为 0</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">//计算 pat 的下一个状态</span></span><br><span class="line">        j = dp[j][txt.charAt(i)];</span><br><span class="line">        <span class="comment">//到达终止状态，匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == M)&#123;<span class="keyword">return</span> i - M + <span class="number">1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没到达终止状态，匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 dp, 即就是 next</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(String pat, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//影子状态，初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构建状态转移图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span>; c++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pat.charAt(j) == c)&#123;</span><br><span class="line">                dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新影子状态</span></span><br><span class="line">        X = dp[X][pat.charAt(j)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-接雨水-42"><a href="#16-接雨水-42" class="headerlink" title="16. 接雨水 [42]"></a>16. 接雨水 [42]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p>
<h3 id="16-1-题目描述"><a href="#16-1-题目描述" class="headerlink" title="16.1. 题目描述"></a>16.1. 题目描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/pictures/image-20200810100323970.png" alt="image-20200810100323970"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<h3 id="16-2-题目分析"><a href="#16-2-题目分析" class="headerlink" title="16.2. 题目分析"></a>16.2. 题目分析</h3><p>本题分析参考：<a href="https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html" target="_blank" rel="noopener">这里</a>.</p>
<h3 id="16-3-方法一：暴力解法（按列求）"><a href="#16-3-方法一：暴力解法（按列求）" class="headerlink" title="16.3. 方法一：暴力解法（按列求）"></a>16.3. 方法一：暴力解法（按列求）</h3><p>参考 <a href="https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html" target="_blank" rel="noopener">这里</a> 的解法二按列求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最两端的不用考虑，因为一定不会有雨水</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max_left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出 height[i] 左边最高（包括height[i]），要把最左端考虑在内</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            max_left = Math.max(height[j], max_left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出 height[i] 右边最高（包括height[i]），要把最右端考虑在内</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; height.length;j++)&#123;</span><br><span class="line">            max_right = Math.max(height[j], max_right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果自己就是最高的话 max_left = max_right = height[i]</span></span><br><span class="line">        sum += Math.min(max_left, max_right) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n²），遍历每一列需要 n，找出左边最高和右边最高的墙加起来刚好又是一个 n，所以是 n²。</p>
<p>空间复杂度：O（1）。</p>
<h3 id="16-4-方法二：动态规划"><a href="#16-4-方法二：动态规划" class="headerlink" title="16.4. 方法二：动态规划"></a>16.4. 方法二：动态规划</h3><p>参考 <a href="https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html" target="_blank" rel="noopener">这里</a> 的解法三动态规划。dp 数组定义不同，本文采用的方法和暴力解法同步。</p>
<p>我们注意到，解法一中，对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p>
<p>首先用两个数组，max_left [ i ] 代表到第 i 列左边最高的墙的高度（包括第 i 列），max_right [ i ] 代表到第 i 列右边最高的墙的高度（包括第 i 列）。</p>
<p>这样，我们利用解法一的思路，不用在 for 循环中再重新遍历求 max_left 和 max_right 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = height.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max_left[i] = x 表示：height[0..i] 中最大值为x</span></span><br><span class="line">    <span class="keyword">int</span> max_left[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// max_right[i] = x 表示：height[i..(len-1)] 中最大值为x</span></span><br><span class="line">    <span class="keyword">int</span> max_right[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    max_left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    max_right[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        max_left[i] = Math.max(height[i], max_left[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">2</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">        max_right[j] = Math.max(height[j], max_right[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        sum += Math.min(max_left[i], max_right[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n）。</p>
<p>空间复杂度：O（n），用来保存每一列左边最高的墙和右边最高的墙。</p>
<h2 id="17-最长有效括号-32"><a href="#17-最长有效括号-32" class="headerlink" title="17. 最长有效括号 [32]"></a>17. 最长有效括号 [32]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></p>
<h3 id="17-1-题目描述"><a href="#17-1-题目描述" class="headerlink" title="17.1. 题目描述"></a>17.1. 题目描述</h3><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(()"</span></span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 <span class="string">"()"</span></span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">")()())"</span></span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 <span class="string">"()()"</span></span><br></pre></td></tr></table></figure>

<p>注意：题目要求找 <strong>子串</strong>， 即字符串中连续的一段。</p>
<h3 id="17-2-题目分析"><a href="#17-2-题目分析" class="headerlink" title="17.2 题目分析"></a>17.2 题目分析</h3><p>本题分析参考：<a href="https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html" target="_blank" rel="noopener">这里</a>.</p>
<p>做题先从暴力解法入手，慢慢想如何进行优化。直接考虑高效率解法考虑会不周全，而且找不到思路啊，千万别心急。</p>
<h3 id="17-3-方法一：暴力解法"><a href="#17-3-方法一：暴力解法" class="headerlink" title="17.3. 方法一：暴力解法"></a>17.3. 方法一：暴力解法</h3><p>暴力解法就是：对每一个子串判断是否有效，返回最长的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 注意：substring 是左闭右开，所以这里j的取值小于等于len</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= len; j += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s.substring(i, j)))&#123;</span><br><span class="line">                max = Math.max(max, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(<span class="string">'('</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: 列举字符串是 O（n²），判断是否是合法序列是 O（n），所以总共是 O（n³）。</p>
<p>空间复杂度：O（n），每次判断的时候，栈的大小。</p>
<p>这个算法，leetCode 会报时间超时。</p>
<h3 id="17-4-方法二：暴力解法优化"><a href="#17-4-方法二：暴力解法优化" class="headerlink" title="17.4. 方法二：暴力解法优化"></a>17.4. 方法二：暴力解法优化</h3><p>在解法一中，我们会做很多重复的判断，比如 <code>()()()</code> ，从下标 0 开始，我们先判断长度为 2 的是否是合法序列，再判断长度为 4 时的字符串是否合法，但依旧从下标 0 开始。判断长度为 6 时，依旧从下标 0 开始，但其实之前已经确认前 4 个是合法序列了，所以我们从 4 开始判断即可。</p>
<p>基于此，我们可以换一个思路，我们判断从每个位置开始的最长合法子串是多长即可。在判断是否是合法子串时，我们不使用栈，而是用一个变量记录当前的括号情况，遇到左括号加1，遇到右括号减1，如果变成0，更新最长合法子串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j) == <span class="string">'('</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                max = Math.max(max, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n²）。</p>
<p>空间复杂度：O（1）。</p>
<h3 id="17-5-方法三：动态规划"><a href="#17-5-方法三：动态规划" class="headerlink" title="17.5. 方法三：动态规划"></a>17.5. 方法三：动态规划</h3><p>分析参考：<a href="https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html#解法三-动态规划" target="_blank" rel="noopener">这里</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[i]=x 表示：以s[i]结尾的子串最长有效长度为x</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果遇到左括号，dp[i]=0，就是初始值</span></span><br><span class="line">        <span class="comment">// 遇到右括号时，才会更新dp数组</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="comment">// 右括号的前一位是左括号</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>)&#123;</span><br><span class="line">                dp[i] = (i &gt; <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 右括号前一位是右括号</span></span><br><span class="line">                <span class="comment">// 并且除去前边的合法序列的前一位是左括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt; <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：遍历了一次，O（n）。</p>
<p>空间复杂度：O（n）。</p>
<h2 id="18-最大矩形-85"><a href="#18-最大矩形-85" class="headerlink" title="18. 最大矩形 [85]"></a>18. 最大矩形 [85]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></p>
<h3 id="18-1-题目描述"><a href="#18-1-题目描述" class="headerlink" title="18.1. 题目描述"></a>18.1. 题目描述</h3><p><img src="/pictures/image-20200820100311020.png" alt="image-20200820100311020"></p>
<h3 id="18-2-方法一：暴力解法"><a href="#18-2-方法一：暴力解法" class="headerlink" title="18.2. 方法一：暴力解法"></a>18.2. 方法一：暴力解法</h3><p>最原始地，我们可以列举每个可能的矩形。这可以通过遍历所有的(x1, y1) (x2, y2) 坐标，并以它们为对角顶点来完成。该方法过慢，不足以通过所有测试用例。</p>
<p>时间复杂度：O(N<sup>3</sup>M<sup>3</sup>)，空间复杂度：O(1).</p>
<h3 id="18-3-方法二：动态规划-使用柱状图的优化暴力解法"><a href="#18-3-方法二：动态规划-使用柱状图的优化暴力解法" class="headerlink" title="18.3. 方法二：动态规划 - 使用柱状图的优化暴力解法"></a>18.3. 方法二：动态规划 - 使用柱状图的优化暴力解法</h3><p>参考 <a href="https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/" target="_blank" rel="noopener">这里</a>，这道题的难点是根本想不到…</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[i][j] = x 表示：以 matrix[i][j] 结尾的最大可能宽度</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="comment">// 更新最大最大宽度</span></span><br><span class="line">                dp[i][j] = (j == <span class="number">0</span>) ? <span class="number">1</span> : dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> width = dp[i][j];</span><br><span class="line">                <span class="comment">// 计算以 matrix[i][j] 为右下角的矩形最大面积</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">                    width = Math.min(width, dp[k][j]);</span><br><span class="line">                    maxArea = Math.max(maxArea, width * (i - k + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4-方法三：动态规划-每个点的最大高度"><a href="#18-4-方法三：动态规划-每个点的最大高度" class="headerlink" title="18.4. 方法三：动态规划 - 每个点的最大高度"></a>18.4. 方法三：动态规划 - 每个点的最大高度</h3><p>参考 <a href="https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/" target="_blank" rel="noopener">这里</a> 的方法四。太强了….更想不到… 而且不好理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">    <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">    Arrays.fill(right, col);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_right = col - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高度</span></span><br><span class="line">        <span class="comment">// 遍历这一行的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="comment">// 在上一行的高度上加1</span></span><br><span class="line">                height[j]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                height[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                left[j] = Math.max(left[j], cur_left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[j] = <span class="number">0</span>;</span><br><span class="line">                cur_left = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                right[j] = Math.min(right[j], cur_right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[j] = col - <span class="number">1</span>;</span><br><span class="line">                cur_right = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 面积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea, (right[j] - left[j] + <span class="number">1</span>) * height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-扰乱字符串-87"><a href="#19-扰乱字符串-87" class="headerlink" title="19. 扰乱字符串 [87]"></a>19. 扰乱字符串 [87]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/scramble-string/" target="_blank" rel="noopener">87. 扰乱字符串</a></p>
<h3 id="19-1-题目描述"><a href="#19-1-题目描述" class="headerlink" title="19.1. 题目描述"></a>19.1. 题目描述</h3><p><img src="/pictures/image-20200821104157163.png" alt="image-20200821104157163"></p>
<p><img src="/pictures/image-20200821104215491.png" alt="image-20200821104215491"></p>
<h3 id="19-2-代码"><a href="#19-2-代码" class="headerlink" title="19.2. 代码"></a>19.2. 代码</h3><p>本题的难点在于没有思路… 也很难构造出 dp 的定义和状态。</p>
<p>具体分析参考：<a href="https://leetcode-cn.com/problems/scramble-string/solution/miao-dong-de-qu-jian-xing-dpsi-lu-by-sha-yu-la-jia/" target="_blank" rel="noopener">这里</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chs1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chs2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = s1.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i][j][len]dp[i][j][len] 表示从字符串 S 中 i 开始（包括 i）长度为 len 的字符串是否能变换为</span></span><br><span class="line">    <span class="comment">// 从字符串 T 中 j （包括 j）开始长度为 len 的字符串</span></span><br><span class="line">    <span class="keyword">boolean</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 初始化单个字符的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = (chs1[i] == chs2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举长度区间 len</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">        <span class="comment">// 枚举 S 的起点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - len; i++)&#123;</span><br><span class="line">            <span class="comment">// 枚举 T 的起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - len; j++)&#123;</span><br><span class="line">                <span class="comment">// 枚举划分位置</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len - <span class="number">1</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">// 第一种情况：不交换</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k])&#123;</span><br><span class="line">                        dp[i][j][len] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 第二种情况：交换</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j + len - k][k] &amp;&amp; dp[i + k][j][len - k])&#123;</span><br><span class="line">                        dp[i][j][len] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-格雷编码-89"><a href="#20-格雷编码-89" class="headerlink" title="20. 格雷编码 [89]"></a>20. 格雷编码 [89]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></p>
<h3 id="20-1-题目描述"><a href="#20-1-题目描述" class="headerlink" title="20.1. 题目描述"></a>20.1. 题目描述</h3><p><img src="/pictures/image-20200822094721670.png" alt="image-20200822094721670"></p>
<h3 id="20-2-代码"><a href="#20-2-代码" class="headerlink" title="20.2. 代码"></a>20.2. 代码</h3><p>感觉应该用 dp，但是没找到怎么 dp，所以 dp 问题首先应该找到小问题，然后考虑怎么根据小问题解决大问题。</p>
<p>详细参考：<a href="https://leetcode.wang/leetCode-89-Gray-Code.html" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp 列表存储最终结果</span></span><br><span class="line">    List&lt;Integer&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// base case，n = 0 时</span></span><br><span class="line">    dp.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历要加的数的次数，从 0 开始，到 n-1 结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 要加的数，即 2^i</span></span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="comment">// 倒序遍历，加上 add 添加到结果集中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = dp.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            dp.add(dp.get(j) + add);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-解码方法-91"><a href="#21-解码方法-91" class="headerlink" title="21. 解码方法 [91]"></a>21. 解码方法 [91]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></p>
<h3 id="21-1-题目描述"><a href="#21-1-题目描述" class="headerlink" title="21.1. 题目描述"></a>21.1. 题目描述</h3><p><img src="/pictures/image-20200825143910613.png" alt="image-20200825143910613"></p>
<h3 id="21-2-代码"><a href="#21-2-代码" class="headerlink" title="21.2. 代码"></a>21.2. 代码</h3><p>分析参考：<a href="https://leetcode-cn.com/problems/decode-ways/solution/dong-tai-gui-hua-java-python-by-liweiwei1419/" target="_blank" rel="noopener">这里</a> ，再结合自己的思路，写了一个更好理解的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">// dp[i] = x 表示：s[0...i] 有 x 中解码方法</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (charArray[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span> * (charArray[i - <span class="number">1</span>] - <span class="string">'0'</span>) + (charArray[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">// 如果是 0</span></span><br><span class="line">        <span class="keyword">if</span>(charArray[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="comment">// 只有和前一位组成的数字在 10 到 26 之内，dp 才会有值，否则是初始值 0</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">10</span> &lt;= num &amp;&amp; num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果不是 0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 和前一位组成的数字在 10 到 26 之内，dp 值增大</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">10</span> &lt;= num &amp;&amp; num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不在 10 到 26 之内，dp 和 前一位相同</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题的难点在于：出现 0 的处理，边界条件太多了…可能的情况太多了…是真的费时间。</p>
<h2 id="22-最大子序和-53"><a href="#22-最大子序和-53" class="headerlink" title="22. 最大子序和 [53]"></a>22. 最大子序和 [53]</h2><p>题目描述：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p>
<h3 id="22-1-题目描述"><a href="#22-1-题目描述" class="headerlink" title="22.1. 题目描述"></a>22.1. 题目描述</h3><p><img src="/pictures/image-20200826102906095.png" alt="image-20200826102906095"></p>
<h3 id="22-2-代码"><a href="#22-2-代码" class="headerlink" title="22.2. 代码"></a>22.2. 代码</h3><p>典型的动态规划问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// dp[i] = x 表示以 nums[i] 结尾的最大子序列和为x</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-交错字符串-97"><a href="#23-交错字符串-97" class="headerlink" title="23. 交错字符串 [97]"></a>23. 交错字符串 [97]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></p>
<h3 id="23-1-题目描述"><a href="#23-1-题目描述" class="headerlink" title="23.1. 题目描述"></a>23.1. 题目描述</h3><p><img src="/pictures/image-20200828110613718.png" alt="image-20200828110613718"></p>
<h3 id="23-2-方法一：动态规划"><a href="#23-2-方法一：动态规划" class="headerlink" title="23.2. 方法一：动态规划"></a>23.2. 方法一：动态规划</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>dp 数组定义：定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。</p>
<p>注意，<code>dp[0][0]</code> 表示 s1 和 s2 都取空串，组成一个空串，则值为 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> &amp;&amp; s2.length() == <span class="number">0</span> &amp;&amp; s3.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">    <span class="comment">// dp[i][j] = true 表示：s1[0..i) 和 s2[0..j) 组合后能构成 s3[0..i+j)</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>))</span><br><span class="line">                || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-3-方法二：回溯"><a href="#23-3-方法二：回溯" class="headerlink" title="23.3. 方法二：回溯"></a>23.3. 方法二：回溯</h3><p>可前往我的博客 <a href="http://juliajiang.top/2020/07/25/回溯算法总结/" target="_blank" rel="noopener">回溯算法总结</a> 的 15. 交错字符串 [97] 查看。</p>
<h2 id="24-最小路径和-64"><a href="#24-最小路径和-64" class="headerlink" title="24. 最小路径和 [64]"></a>24. 最小路径和 [64]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></p>
<h3 id="24-1-题目描述"><a href="#24-1-题目描述" class="headerlink" title="24.1. 题目描述"></a>24.1. 题目描述</h3><p><img src="/pictures/image-20200901100037412.png" alt="image-20200901100037412"></p>
<h3 id="24-2-代码"><a href="#24-2-代码" class="headerlink" title="24.2. 代码"></a>24.2. 代码</h3><p>典型的动态规划问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// dp[i][j] = x 表示：到grid[i][j]的最小路径和为 x</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)&#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-不同的子序列-115"><a href="#25-不同的子序列-115" class="headerlink" title="25. 不同的子序列 [115]"></a>25. 不同的子序列 [115]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a></p>
<h3 id="25-1-题目描述"><a href="#25-1-题目描述" class="headerlink" title="25.1. 题目描述"></a>25.1. 题目描述</h3><p><img src="/pictures/image-20200904105932893.png" alt="image-20200904105932893"></p>
<h3 id="25-2-代码"><a href="#25-2-代码" class="headerlink" title="25.2. 代码"></a>25.2. 代码</h3><p>参考：<a href="https://leetcode.wang/leetcode-115-Distinct-Subsequences.html" target="_blank" rel="noopener">这里</a> 的解法三，将 dp 从逆序改为正序。</p>
<p>这道题一开始用的回溯，发现超时，需要用 map 存之前的递归结果，不太好存，也不好理解，参考 <a href="https://leetcode.wang/leetcode-115-Distinct-Subsequences.html" target="_blank" rel="noopener">这里</a> 的解法二。</p>
<p>还是用 dp 吧…</p>
<p>两个字符串的 dp 问题，依旧是用 <code>dp[0][0]</code> 表示两个字符串均为空串的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">    <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">    <span class="comment">// dp[i + 1][j + 1] = x 表示：s[0..i] 中的子序列 t[0..j] 的个数为 x</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sLen + <span class="number">1</span>][tLen + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tLen; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; i++)&#123;</span><br><span class="line">            <span class="comment">// 如果相等</span></span><br><span class="line">            <span class="keyword">if</span>(t.charAt(j - <span class="number">1</span>) == s.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 有两种选择：不选择当前字母 dp[i - 1][j] 和选择当前字母 dp[i - 1][j - 1]</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 如果不相等</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 只有一种选择：不选当前字母</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sLen][tLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-三角形最小路径和-120"><a href="#26-三角形最小路径和-120" class="headerlink" title="26. 三角形最小路径和 [120]"></a>26. 三角形最小路径和 [120]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></p>
<h3 id="26-1-题目描述"><a href="#26-1-题目描述" class="headerlink" title="26.1 题目描述"></a>26.1 题目描述</h3><p><img src="/pictures/image-20200910185227369.png" alt="image-20200910185227369"></p>
<h3 id="26-2-方法一：动态规划"><a href="#26-2-方法一：动态规划" class="headerlink" title="26.2 方法一：动态规划"></a>26.2 方法一：动态规划</h3><p>参考 <a href="https://leetcode.wang/leetcode-120-Triangle.html" target="_blank" rel="noopener">这里</a> 做了一些改动。但是这种 dp 空复为 O(n^2)。</p>
<p>为什么..最近做题老是想不到动态规划.. 老想回溯…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">    <span class="comment">// dp[i][j] = x 表示：triangle[i][j] 的最小路径和为 x</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="comment">// 遍历这一行的每一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="comment">// 这一行的最后一个数</span></span><br><span class="line">            <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle.get(i).get(j);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + triangle.get(i).get(j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        min = Math.min(min, dp[size-<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-3-方法一的优化"><a href="#26-3-方法一的优化" class="headerlink" title="26.3. 方法一的优化"></a>26.3. 方法一的优化</h3><p>上面的动态规划 dp 数组是二维数组，但是每一次只用到上一层的数据。所以使用一维的 dp 数组即可。此时，空复是 O(n)。</p>
<p>如果正着更新的话，会把后面要用的值覆盖掉。因此，倒着更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    dp[<span class="number">0</span>]=triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + triangle.get(i).get(j);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[j] = dp[j] + triangle.get(i).get(j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        min = Math.min(min, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-参考引用"><a href="#27-参考引用" class="headerlink" title="27. 参考引用"></a>27. 参考引用</h2><ol>
<li><a href="[https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92](https://zh.wikipedia.org/wiki/动态规划)">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie</a></li>
<li><a href="https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7QFapCuvi-2nkh6gREcR9g</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-chang-gong-gong-zi-xu-lie</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/zui-da-zi-shu-zu</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa</a></li>
<li><a href="https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-42-Trapping-Rain-Water.html</a></li>
<li><a href="https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html</a></li>
<li><a href="https://leetcode.wang/leetCode-89-Gray-Code.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-89-Gray-Code.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法总结</title>
    <url>/2020/07/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要介绍了回溯法的定义、回溯法的代码框架，以及回溯法的典型问题全排列问题、N皇后问题等。另外，还介绍了LeetCode中使用回溯法的部分题目，这部分内容会持续更新。</p>
<h2 id="1-什么是回溯法？"><a href="#1-什么是回溯法？" class="headerlink" title="1. 什么是回溯法？"></a>1. 什么是回溯法？</h2><p><strong><a href="https://zh.wikipedia.org/wiki/回溯法" target="_blank" rel="noopener">维基定义</a></strong> : （英语：backtracking）是<a href="https://zh.wikipedia.org/wiki/暴力搜尋法" target="_blank" rel="noopener">暴力搜索法</a>中的一种。</p>
<p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，<strong><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">八皇后问题</a></strong>展示了回溯法的用例。</p>
<a id="more"></a>

<p>回溯法采用<a href="https://zh.wikipedia.org/wiki/试错" target="_blank" rel="noopener">试错</a>的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<p>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。而回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。</p>
<h2 id="2-回溯法框架"><a href="#2-回溯法框架" class="headerlink" title="2. 回溯法框架"></a>2. 回溯法框架</h2><p>上文主要是 Wikipedia 对于回溯法的介绍，这一节，将参考 <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">这里</a> 给出一个回溯算法的框架。</p>
<p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p>
<ol>
<li>路径：也就是已经做出的选择</li>
<li>选择列表：也就是你当前可以做的选择</li>
<li>结束条件：也就是到达决策树底层，无法再做选择的条件</li>
</ol>
<p>如果现在不理解这三个词语没关系，下一节我们将以全排列问题为例，进行详细介绍。下面给出回溯法的框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</strong></p>
<h2 id="3-以全排列问题（无重复数字）为例-46"><a href="#3-以全排列问题（无重复数字）为例-46" class="headerlink" title="3. 以全排列问题（无重复数字）为例 [46]"></a>3. 以全排列问题（无重复数字）为例 [46]</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-问题分析"><a href="#3-2-问题分析" class="headerlink" title="3.2 问题分析"></a>3.2 问题分析</h3><p>我们知道，对于 n 个不重复的数，全排列共有 n! 个。如果使用穷举法，我们一般会：</p>
<p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p>
<p>其实这就是回溯算法，可以转化为下面的回溯树：</p>
<img src="/pictures/1.jpg" alt="img" style="zoom: 33%;" />

<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p>
<p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p>
<img src="/pictures/2.jpg" alt="img" style="zoom:33%;" />

<p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p>
<p><strong>现在可以解答开头的几个名词：</strong><code>[2]</code> <strong>就是「路径」，记录你已经做过的选择；<code>[1,3]</code>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p>
<p>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p>
<img src="/pictures/3.jpg" alt="img" style="zoom:33%;" />

<p><strong>框架中定义的 <code>backtrace</code>  函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p>
<p>在回溯法中，<strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。因此，框架中的核心代码详细化如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录路径（已做出的选择）</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 满足结束条件（到达决策树底层，无法再做选择的条件）</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length == track.size())&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span>(track.contains(num))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(num);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们并没有显示记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表。</p>
<p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p>
<p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p>
<p>明白了全排列问题，就可以直接套回溯算法框架了。</p>
<h3 id="3-4-另一种方法"><a href="#3-4-另一种方法" class="headerlink" title="3.4 另一种方法"></a>3.4 另一种方法</h3><p>上文中没有显示记录「选择列表」，通过用路径的 <code>contains</code> 方法来判断是否选择。这里我们 <strong>“以空间换时间”</strong> 的思想，使用一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)  的时间复杂度判断这个数是否被选择过。（参考 <a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">这里</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute2(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    backtrace2(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> used 标记数组，used[i]=true时，表示已被选择</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrace2</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == len)&#123;</span><br><span class="line">        res2.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        backtrace2(nums, track, used);</span><br><span class="line"></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-N皇后问题-51"><a href="#4-N皇后问题-51" class="headerlink" title="4. N皇后问题 [51]"></a>4. N皇后问题 [51]</h2><h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p>
<p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p>
<p><img src="/pictures/8-queens.png" alt="img"></p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  // 解法 1</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // 解法 2</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<h3 id="4-2-问题分析"><a href="#4-2-问题分析" class="headerlink" title="4.2 问题分析"></a>4.2 问题分析</h3><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p>
<h3 id="4-3-代码"><a href="#4-3-代码" class="headerlink" title="4.3 代码"></a>4.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化棋盘 board 为二维字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : board)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Arrays.fill(chars, <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径：board中小于row的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">     * 可选择列表: 第row行的所有列都是放置 Q 的选择</span></span><br><span class="line"><span class="comment">     * 结束条件: row超过board的最后一行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前放置第几行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.length) &#123;</span><br><span class="line">        res.add(charToString(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">//排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">//进入下一层决策树</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以在 board[row][col] 放置皇后</span></span><br><span class="line"><span class="comment">     * 不需要检查 这一行，因为每一行只放一个皇后就到下一行</span></span><br><span class="line"><span class="comment">     * 不需要检查 左下、右下斜线，因为下面还没放元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.length;</span><br><span class="line">    <span class="comment">//检查这一列是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : board)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上斜线上是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; rows; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上斜线上是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">charToString</span><span class="params">(<span class="keyword">char</span>[][] array)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : array) &#123;</span><br><span class="line">        result.add(String.valueOf(chars));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝。</p>
<h2 id="5-回溯法总结"><a href="#5-回溯法总结" class="headerlink" title="5. 回溯法总结"></a>5. 回溯法总结</h2><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>写</strong> <strong><code>backtrack</code></strong> <strong>函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p>
<p>下面几节记录了一些平时遇到的，可以使用回溯解决的经典例题，会持续更新~</p>
<h2 id="6-使用回溯法的题目列表"><a href="#6-使用回溯法的题目列表" class="headerlink" title="6. 使用回溯法的题目列表"></a>6. 使用回溯法的题目列表</h2><p>本文中使用回溯法解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">46</td>
<td align="center"><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center"><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">70</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">79</td>
<td align="center"><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">78</td>
<td align="center"><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></td>
<td align="center">Medium</td>
</tr>
<tr>
<td align="center">90</td>
<td align="center"><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">子集 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">93</td>
<td align="center"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">97</td>
<td align="center"><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">交错字符串</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">113</td>
<td align="center"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="7-例题：全排列问题（有重复数字）-47"><a href="#7-例题：全排列问题（有重复数字）-47" class="headerlink" title="7. 例题：全排列问题（有重复数字）[47]"></a>7. 例题：全排列问题（有重复数字）[47]</h2><h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="7-2-题目分析"><a href="#7-2-题目分析" class="headerlink" title="7.2 题目分析"></a>7.2 题目分析</h3><p>这道题与上面 46 题不同，给出的序列是包含重复数字的，所以，46题的第一种方法使用track的contain来判断是否选择在这里不使用。而第二种方法，标记数组是可行的，但直接使用 used 数组判断，最终得到的全排列结果可能会有重复，如下图所示：（图片来自：<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">这里</a>）</p>
<img src="/pictures/全排列2.png" alt="全排列2" style="zoom: 33%;" />

<p>如上所示，绿色框中的序列都是重复的，不属于结果集。为什么会出现这种情况呢？</p>
<p>观察发现，在决策树中，同一父节点下的子节点中，选中两个相同的数字时，必然出现重复的全排列结果。那么如何避免这种情况呢？</p>
<p>对给出的序列进行排序，这样相同的数字都会放在一起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">	做选择</span><br><span class="line">	backtrack(路径, 选择列表)</span><br><span class="line">	撤销选择</span><br></pre></td></tr></table></figure>

<p>在框架的核心代码中，撤销选择处撤销的数字，就是下一个遍历节点的左侧兄弟节点，保存这个数组为 pre，如下图所示，当遍历到nums[i] 处时，如果 pre == nums[i]，则说明需要剪枝。</p>
<img src="/pictures/image-20200725154024914.png" alt="image-20200725154024914" style="zoom:67%;" />

<h3 id="7-3-代码"><a href="#7-3-代码" class="headerlink" title="7.3 代码"></a>7.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序；相同的数字放在一起，重复的剪枝方便</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    backtrack(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// 满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(track.size() == len)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为数组中没有的数</span></span><br><span class="line">    <span class="keyword">int</span> pre = nums[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] || pre == nums[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 记录刚被撤销的数字</span></span><br><span class="line">        pre = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h3><p>还是按照回溯法的框架来解决，但是剪枝的部分一开始想不到。</p>
<h2 id="8-例题：组合总和-39"><a href="#8-例题：组合总和-39" class="headerlink" title="8. 例题：组合总和 [39]"></a>8. 例题：组合总和 [39]</h2><h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= candidates.length &lt;= 30</span><br><span class="line">1 &lt;= candidates[i] &lt;= 200</span><br><span class="line">candidate 中的每个元素都是独一无二的。</span><br><span class="line">1 &lt;= target &lt;= 500</span><br></pre></td></tr></table></figure>

<h3 id="8-2-题目分析"><a href="#8-2-题目分析" class="headerlink" title="8.2 题目分析"></a>8.2 题目分析</h3><p>这道题依旧可以使用回溯法进行暴力穷举。有几点需要注意：</p>
<ol>
<li>选择列表candidates可以重复选择，即选择列表自始至终都不变，是candidates</li>
<li>candidate 中的每个元素都是独一无二的</li>
<li>解集不能包含重复的组合，即最终的结果不能重复</li>
</ol>
<p>鉴于最终结果不可以重复，我们可以剪掉会重复的枝，即将选择列表排序，路径的下一个节点选择从当前节点开始遍历（由于candidate 中的每个元素不重复，所以start从 i 开始就可以解决结果重复的问题）。另外，这道题改用减法更好理解。</p>
<h3 id="8-3-代码"><a href="#8-3-代码" class="headerlink" title="8.3 代码"></a>8.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化添加的代码1：先对数组排序，可以提前终止判断</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, track, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> residue 剩余</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 下一次从 start 开始判断是否添加到路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> residue, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(residue == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 从 start 开始，剪掉小于 candidates[i] 的枝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span>(residue - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(candidates[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        <span class="comment">// residue-candidates[i] 为下一轮剩余</span></span><br><span class="line">        <span class="comment">// i 为下一轮的 start值，原因：为了避免重复，选择的数字只能大于等于candidates[i]</span></span><br><span class="line">        backtrack(candidates, track, residue-candidates[i], i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-例题：组合总和-2-40"><a href="#9-例题：组合总和-2-40" class="headerlink" title="9. 例题：组合总和 2 [40]"></a>9. 例题：组合总和 2 [40]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="9-2-题目分析"><a href="#9-2-题目分析" class="headerlink" title="9.2 题目分析"></a>9.2 题目分析</h3><p>本题与上一题的区别有两个：</p>
<ol>
<li>candidates 中的每个数字在每个组合中只能使用一次</li>
<li>candidates 中有重复数字</li>
</ol>
<p>思路如下：</p>
<ol>
<li>要保证每个数字用一次，先对序列排序， 且 start 从 i+1 开始</li>
<li>要保证结果不重复，第一步是不够的，因为 candidates 中有重复数字。这个问题和上文的 <strong>全排列问题（有重复数字）</strong> 类似，使用 pre 标记刚撤销的数字，与当前值比较后进行剪枝。</li>
</ol>
<h3 id="9-3-代码"><a href="#9-3-代码" class="headerlink" title="9.3 代码"></a>9.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, track, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> residue 剩余</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 下一次从 start 开始判断是否添加到路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> residue, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(residue == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pre = candidates[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="comment">// candidates排序之后，如果第一个不满足，后面的肯定不满足，直接break</span></span><br><span class="line">        <span class="keyword">if</span>(residue - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前值和上一个撤销的值相同，会重复，continue</span></span><br><span class="line">        <span class="keyword">if</span>(candidates[i] == pre)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        track.add(candidates[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        <span class="comment">// start 从 i+1 开始</span></span><br><span class="line">        backtrack(candidates, track, residue-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        pre = candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-例题：组合-70"><a href="#10-例题：组合-70" class="headerlink" title="10. 例题：组合 [70]"></a>10. 例题：组合 [70]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></p>
<h3 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h3><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="10-2-题目分析"><a href="#10-2-题目分析" class="headerlink" title="10.2 题目分析"></a>10.2 题目分析</h3><p>这种数字组合的题目是典型的回溯法问题，先选一个数字，进入递归继续选，如果满足条件则加入结果中，然后回溯到上一步，继续递归。</p>
<h3 id="10-3-代码"><a href="#10-3-代码" class="headerlink" title="10.3 代码"></a>10.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解法一：回溯法</span></span><br><span class="line"><span class="comment">     * 回溯的常规解法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(track, n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果满足条件</span></span><br><span class="line">    <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为避免重复，i 从 start 开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(i);</span><br><span class="line">        backtrack(track, n, k, i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-优化"><a href="#10-4-优化" class="headerlink" title="10.4 优化"></a>10.4 优化</h3><p>参考 <a href="https://leetcode.wang/leetCode-77-Combinations.html" target="_blank" rel="noopener">这里</a> 对上面代码进行优化。将 for 循环改为 <code>for(int i = start; i &lt;= (n-k)+1 + track.size(); i++)</code>, 其中，<code>(n-k)+1</code>  表示要在 n 中找到 k 个数字组合，start 必须从 (n-k)+1 处开始；<code>(n-k)+1 + track.size()</code>  表示当前 i 取到的最大数字。原因如下：</p>
<p>我们发现，如果 n = 5, k = 3,  那么 start 最大取到3，因为如果 start = 4，最终结果只能得到到 (4,5), 结果的个数必定小于k，不满足条件。</p>
<p>如果 n = 5, k = 3, start = 1, 当 i = 2, track.size() = 1时，i 最大取到 (5-3)+1 + 1 = 4，否则，如果 i 取到 5，结果只能为 (1,5), 数字个数肯定不满足条件。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack2</span><span class="params">(LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (n-k)+1 表示要在n中找到k个数字组合，start必须从(n-k)+1处开始</span></span><br><span class="line">    <span class="comment">// 即如果n=5,k=3, 那么start最大取到3，因为如果当start=4时，组合中数字的个数不足</span></span><br><span class="line">    <span class="comment">// (n-k)+1 + track.size() 表示当前i取到的最大数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= (n-k)+<span class="number">1</span> + track.size(); i++)&#123;</span><br><span class="line">        track.add(i);</span><br><span class="line">        backtrack(track, n, k, i+<span class="number">1</span>);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然只改了一句代码，但速度快了很多。</p>
<h2 id="11-单词搜索-79"><a href="#11-单词搜索-79" class="headerlink" title="11. 单词搜索 [79]"></a>11. 单词搜索 [79]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></p>
<h3 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1. 题目描述"></a>11.1. 题目描述</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">"ABCCED"</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 word = <span class="string">"SEE"</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 word = <span class="string">"ABCB"</span>, 返回 <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>board 和 word 中只包含大写和小写英文字母。</li>
<li>1 &lt;= board.length &lt;= 200</li>
<li>1 &lt;= board[i].length &lt;= 200</li>
<li>1 &lt;= word.length &lt;= 10^3</li>
</ul>
<h3 id="11-2-题目分析"><a href="#11-2-题目分析" class="headerlink" title="11.2. 题目分析"></a>11.2. 题目分析</h3><p>基本思路：找第一个匹配的字符，然后在其上下左右的四个字符中找与第二个字符匹配的字符，找到后，以次类推。上下左右字符需要首先判断是否越界、是否已经访问过。</p>
<p>但是，在做题的过程中，完全忽略了这是标准的回溯思想，参考之前的博客：<a href="https://juliajiang7.github.io/2020/07/25/回溯算法总结/#more" target="_blank" rel="noopener">回溯算法</a>.</p>
<p>回溯法采用试错的思想，尝试分步解决一个问题。在本题中，匹配下一个字符时就有上下左右四种选择。当它发现现有的分布答辩不能得到有效的正确答案时，将取消上一步或者上几步的计算，再通过其他分步尝试得到问题答案。</p>
<p>在做题中有一个很大问题：忽略了回溯，即选择一条路走完发现不能匹配时，就返回了false，没有取消这一步操作。这一点要注意。</p>
<p>另外，这一题使用框架不太好写，还是基于回溯思想（DFS），按照正常的思路来写。</p>
<h3 id="11-3-代码"><a href="#11-3-代码" class="headerlink" title="11.3. 代码"></a>11.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="comment">// 找到第一个字母</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 判断从 board[i][j] 出发，后面能否全部匹配</span></span><br><span class="line">                <span class="keyword">if</span>(isValid(i, j, word, <span class="number">0</span>, board, visited))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 board[i][j] 匹配 word[k] 时，后面是否可以全部匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> visited 当前已访问的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> k, <span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(k == word.length() - <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="comment">// 上面</span></span><br><span class="line">    <span class="keyword">boolean</span> left = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j] &amp;&amp; board[i - <span class="number">1</span>][j] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i - <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        left = isValid(i - <span class="number">1</span>, j, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left)&#123;<span class="keyword">return</span> left;&#125;</span><br><span class="line">    <span class="comment">// 下面</span></span><br><span class="line">    <span class="keyword">boolean</span> right = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; row &amp;&amp; !visited[i + <span class="number">1</span>][j] &amp;&amp; board[i + <span class="number">1</span>][j] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i + <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        right = isValid(i + <span class="number">1</span>, j, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right)&#123;<span class="keyword">return</span> right;&#125;</span><br><span class="line">    <span class="comment">// 左边</span></span><br><span class="line">    <span class="keyword">boolean</span> up = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>] &amp;&amp; board[i][j - <span class="number">1</span>] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i][j - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        up = isValid(i, j - <span class="number">1</span>, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(up)&#123;<span class="keyword">return</span> up;&#125;</span><br><span class="line">    <span class="comment">// 右边</span></span><br><span class="line">    <span class="keyword">boolean</span> down = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; col &amp;&amp; !visited[i][j + <span class="number">1</span>] &amp;&amp; board[i][j + <span class="number">1</span>] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i][j + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        down = isValid(i, j + <span class="number">1</span>, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(down)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="comment">// 如果上下左右都没有匹配，则取消这一步，回溯</span></span><br><span class="line">    visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-子集-78"><a href="#12-子集-78" class="headerlink" title="12. 子集 [78]"></a>12. 子集 [78]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p>
<h3 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1. 题目描述"></a>12.1. 题目描述</h3><p><img src="/pictures/image-20200824094845802.png" alt="image-20200824094845802"></p>
<h3 id="12-1-方法一：迭代"><a href="#12-1-方法一：迭代" class="headerlink" title="12.1. 方法一：迭代"></a>12.1. 方法一：迭代</h3><p>利用数学归纳的思想：假设现在知道了规模更小的子问题，如何推导出当前问题的结果呢？即知道了 [1,2] 的子集，如何求 [1,2,3] 的子集。</p>
<p>可以发现，[1,2,3] 的子集包括两部分：第一部分是已知的 [1,2] 的子集；另一部分是给每一个 [1,2] 子集加上 3。发现这个规律后，即可写出下面的迭代代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = res.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="comment">// 注意：这里需要 new 一个对象，不可以直接赋值</span></span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> LinkedList&lt;&gt;(res.get(i));</span><br><span class="line">            cur.add(num);</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：迭代次数是 N，每次迭代都遍历 res，res 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。所以，总的时间复杂度是 O(N * 2 ^ N)。</p>
<p>空间复杂度：如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p>
<h3 id="12-2-方法二：回溯算法"><a href="#12-2-方法二：回溯算法" class="headerlink" title="12.2. 方法二：回溯算法"></a>12.2. 方法二：回溯算法</h3><p>参考 <a href="https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA" target="_blank" rel="noopener">这里</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        backtrack(nums, track, start + <span class="number">1</span>);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-子集-II-90"><a href="#13-子集-II-90" class="headerlink" title="13. 子集 II [90]"></a>13. 子集 II [90]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></p>
<h3 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1. 题目描述"></a>13.1. 题目描述</h3><p><img src="/pictures/image-20200824101740024.png" alt="image-20200824101740024"></p>
<h3 id="13-2-代码"><a href="#13-2-代码" class="headerlink" title="13.2. 代码"></a>13.2. 代码</h3><p>有了上一题的基础，回溯法稍作修改即可。</p>
<p>为了方便的剪枝，要对序列进行排序，排序之后所有相同的数字都会放在一起。为了避免结果中出现相同的子集，兄弟节点中不能出现相同的数字，即在 <code>track.add</code> 之前，需要先判断，是否和已经加入的兄弟节点值相同（如果是第一个加入的子节点，不需要判断）。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(nums, track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == start || nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            backtrack(nums, track, i + <span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-复原IP地址-93"><a href="#14-复原IP地址-93" class="headerlink" title="14. 复原IP地址 [93]"></a>14. 复原IP地址 [93]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></p>
<h3 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1. 题目描述"></a>14.1. 题目描述</h3><p><img src="/pictures/image-20200827104857215.png" alt="image-20200827104857215"></p>
<h3 id="14-2-解法一：暴力破解（迭代）"><a href="#14-2-解法一：暴力破解（迭代）" class="headerlink" title="14.2. 解法一：暴力破解（迭代）"></a>14.2. 解法一：暴力破解（迭代）</h3><p>参考 <a href="https://leetcode.wang/leetCode-93-Restore-IP-Addresses.html" target="_blank" rel="noopener">这里</a>.</p>
<p>要求划分为四部分，我们直接利用三个指针将字符串强行分为4部分，遍历所有的划分，然后选取合法的解。这种解法没有超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">// i &lt; 4 保证第一部分不超过3位数</span></span><br><span class="line">    <span class="comment">// i &lt; len - 2 保证剩余的字符串还能分成3部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + <span class="number">4</span> &amp;&amp; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; j + <span class="number">4</span> &amp;&amp; k &lt; len; k++) &#123;</span><br><span class="line">                <span class="comment">// 保存四部分字符串</span></span><br><span class="line">                String s1 = s.substring(<span class="number">0</span>, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);</span><br><span class="line">                <span class="comment">// 判断是否合法</span></span><br><span class="line">                <span class="keyword">if</span> (isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4)) &#123;</span><br><span class="line">                    res.add(s1 + <span class="string">"."</span> + s2 + <span class="string">"."</span> + s3 + <span class="string">"."</span> + s4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &gt; <span class="number">3</span> || s.length() == <span class="number">0</span> || (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>) || Integer.parseInt(s) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：如果不考虑我们调用的内部函数，Integer.parseInt，s.substring，那么就是 O（1）。因为每一层循环最多遍历 4 次。考虑的话每次调用的时间复杂度是 O（n），常数次调用，所以是 O（n）。</p>
<p>空间复杂度：O（1）。</p>
<h3 id="14-3-解法二：回溯"><a href="#14-3-解法二：回溯" class="headerlink" title="14.3. 解法二：回溯"></a>14.3. 解法二：回溯</h3><p>字符串划分问题，需要划分为4部分。直接使用回溯的思想，第一部分可能是 1 位数，然后进入递归；也可能是2位数，然后进入递归；也可能是三位数，然后进入递归。即每一次循环有三种选择。</p>
<p>本题虽然使用了回溯的思想，但前面总结的框架不能直接使用，下面代码是它的变形，而且本题的难点在于需要考虑的情况比较多，剪枝条件也比较多。具体剪枝的分析参考 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">这里</a> .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(s, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 字符串开始部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 已经划分部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res   保存所有的解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 当前已经加入了几部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, <span class="keyword">int</span> start, StringBuilder track, List&lt;String&gt; res, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果剩余长度大于剩下部分都取3位数的长度，剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() - start &gt; <span class="number">3</span> * (<span class="number">4</span> - count)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前刚好到达末尾</span></span><br><span class="line">    <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">        <span class="comment">// 当前刚好是4部分，将结果加入，否则剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">            res.add(track.substring(<span class="number">0</span>, track.length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前到达末尾，但不是4部分，剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前超过末尾，剪枝</span></span><br><span class="line">    <span class="comment">// 当前未到达末尾，但有4部分，剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; s.length() || count == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存当前的解</span></span><br><span class="line">    StringBuilder before = <span class="keyword">new</span> StringBuilder(track);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择：加入一位数</span></span><br><span class="line">    track.append(s.charAt(start) + <span class="string">""</span> + <span class="string">'.'</span>);</span><br><span class="line">    backtrack(s, start + <span class="number">1</span>, track, res, count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开头是0，直接结束，即选择2或3位数之前可进行剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做出选择：加入2位数</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 撤销选择：恢复为之前的解</span></span><br><span class="line">        track = <span class="keyword">new</span> StringBuilder(before);</span><br><span class="line">        track.append(s.substring(start, start + <span class="number">2</span>) + <span class="string">""</span> + <span class="string">'.'</span>);</span><br><span class="line">        backtrack(s, start + <span class="number">2</span>, track, res, count + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做出选择：加入3位数</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">2</span> &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 撤销选择：恢复为之前的解</span></span><br><span class="line">        track = <span class="keyword">new</span> StringBuilder(before);</span><br><span class="line">        <span class="comment">// 当选择3位数时，要判断数字大小</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(s.substring(start, start + <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= num &amp;&amp; num &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">            track.append(s.substring(start, start + <span class="number">3</span>) + <span class="string">""</span> + <span class="string">'.'</span>);</span><br><span class="line">            backtrack(s, start + <span class="number">3</span>, track, res, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-交错字符串-97"><a href="#15-交错字符串-97" class="headerlink" title="15. 交错字符串 [97]"></a>15. 交错字符串 [97]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></p>
<h3 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1. 题目描述"></a>15.1. 题目描述</h3><p><img src="/pictures/image-20200828102111964.png" alt="image-20200828102111964"></p>
<h3 id="15-2-方法一：回溯法"><a href="#15-2-方法一：回溯法" class="headerlink" title="15.2. 方法一：回溯法"></a>15.2. 方法一：回溯法</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>感觉要用回溯解决，但是不知道怎么回溯，如何递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backtrack(s1, s2, s3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(String s1, String s2, String s3, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i，j,k 全部到达末尾就返回true</span></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length() &amp;&amp; j == s2.length() &amp;&amp; k == s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i 到达末尾，直接移动 j 和 k 不停比较</span></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.charAt(j) != s3.charAt(k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j 到达末尾，直接移动 i 和 k 不停比较</span></span><br><span class="line">    <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s3.charAt(k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 i 和 k 指向的字符是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(i) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="comment">// 后移 i 和 k 继续判断，如果成功直接返回true</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack(s1, s2, s3, i + <span class="number">1</span>, j, k + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动 i 和 k 失败，尝试移动 j 和 k</span></span><br><span class="line">    <span class="keyword">if</span> (s2.charAt(j) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrack(s1, s2, s3, i, j + <span class="number">1</span>, k + <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动 i 和 j 都失败，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3-方法二：回溯法的优化（备忘录）"><a href="#15-3-方法二：回溯法的优化（备忘录）" class="headerlink" title="15.3. 方法二：回溯法的优化（备忘录）"></a>15.3. 方法二：回溯法的优化（备忘录）</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>由于递归的分支，所以会造成很多重复情况的判断，所以我们用 memoization 技术，把求出的结果用 hashmap 保存起来，第二次过来的时候直接返回结果以免再次进入递归。</p>
<p>hashmap key 的话用字符串 i + “@” + j ，之所以中间加 “@”，是为了防止 i = 1 和 j = 22。以及 i = 12，j = 2。这样的两种情况产生的就都是 122。加上 “@” 可以区分开来。</p>
<p>原文中：map 的 value 取值有三个，用 1 表示 true，0 表示 false，-1 代表还未赋值。</p>
<p>但其实这里并不会用到三个值，因为一旦遇到的 i 和 j 满足要求，直接返回 true 即可，不需要再存入 map 中。因此，这里定义的 memo 就是一个不满足要求的 i 和 j 组合，只要 memo中含有 i 和 j 的组合，则直接返回 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// memo 的 key 是：i + "@" + j，用@隔开是为了防止i=1,j=22时，可能出现两种组合情况：(1,22),(12,2)</span></span><br><span class="line">    <span class="comment">// memo 的 value 取值：-1 表示为赋值；0 表示false；1 表示true</span></span><br><span class="line">    <span class="comment">// value 其实用不到三个值，因为一旦当前的 i 和 j 符合要求，直接返回 true 即可。因此 memo 中只需要存不满足情况的 i 和 j 即可</span></span><br><span class="line">    Map&lt;String, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> backtrack2(s1, s2, s3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack2</span><span class="params">(String s1, String s2, String s3, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, Map&lt;String, Integer&gt; memo)</span> </span>&#123;</span><br><span class="line">    String key = i + <span class="string">"@"</span> + j;</span><br><span class="line">    <span class="keyword">if</span> (memo.containsKey(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == s1.length() &amp;&amp; j == s2.length() &amp;&amp; k == s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.charAt(j) != s3.charAt(k)) &#123;</span><br><span class="line">                memo.put(key, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s3.charAt(k)) &#123;</span><br><span class="line">                memo.put(key, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(i) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrack2(s1, s2, s3, i + <span class="number">1</span>, j, k + <span class="number">1</span>, memo)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s2.charAt(j) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrack2(s1, s2, s3, i, j + <span class="number">1</span>, k + <span class="number">1</span>, memo))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo.put(key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-方法三：动态规划"><a href="#15-4-方法三：动态规划" class="headerlink" title="15.4. 方法三：动态规划"></a>15.4. 方法三：动态规划</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>dp 数组定义：定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。</p>
<p>注意，<code>dp[0][0]</code> 表示 s1 和 s2 都取空串，组成一个空串，则值为 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> &amp;&amp; s2.length() == <span class="number">0</span> &amp;&amp; s3.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">    <span class="comment">// dp[i][j] = true 表示：s1[0..i) 和 s2[0..j) 组合后能构成 s3[0..i+j)</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>))</span><br><span class="line">                || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-路径总和-II-113"><a href="#16-路径总和-II-113" class="headerlink" title="16. 路径总和 II [113]"></a>16. 路径总和 II [113]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></p>
<h3 id="16-1-题目描述"><a href="#16-1-题目描述" class="headerlink" title="16.1. 题目描述"></a>16.1. 题目描述</h3><p><img src="/pictures/image-20200903093332125.png" alt="image-20200903093332125"></p>
<h3 id="16-2-代码"><a href="#16-2-代码" class="headerlink" title="16.2. 代码"></a>16.2. 代码</h3><p>典型的回溯思路：采用试错的思想，尝试分步去解决问题，在分步解决问题的过程中，当通过尝试发现现有的分布答案不能得到有效的正确答案时，取消上一步甚至是上几步的计算，再通过其他的分布尝试寻找问题的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    track.add(root.val);</span><br><span class="line">    backtrack(root, sum, track, root.val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 做出选择：左子树</span></span><br><span class="line">        track.add(root.left.val);</span><br><span class="line">        backtrack(root.left, sum, track, tmp + root.left.val);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        track.add(root.right.val);</span><br><span class="line">        backtrack(root.right, sum, track, tmp + root.right.val);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-参考引用"><a href="#17-参考引用" class="headerlink" title="17. 参考引用"></a>17. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></li>
<li><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></li>
<li><a href="https://leetcode.wang/leetCode-77-Combinations.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-77-Combinations.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA</a></li>
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/</a></li>
<li><a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-97-Interleaving-String.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON与Java对象的转换</title>
    <url>/2020/07/23/JSON%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>本文简要介绍了 JSON 的定义、语法规则，同时总结了两个把 JSON 字符串转为 JavaBean 的库分别是 json-lib、fastjson，另外还有 json 数据的传输与接收的简单使用。</p>
<h2 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h2><h3 id="1-1-什么是-JSON？"><a href="#1-1-什么是-JSON？" class="headerlink" title="1.1 什么是 JSON？"></a>1.1 什么是 JSON？</h3><p><strong>JSON（JavaScript Object Notation，JavaScript对象表示法）：</strong>（from Wikipedia）是一种由道格拉斯·克罗克福特构想和设计、<em>轻量级的数据交换语言</em>，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是<em>独立于语言的文本格式</em>，并且采用了类似于C语言家族的一些习惯。</p>
<p>JSON 数据格式与语言无关。即便它源自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。</p>
<a id="more"></a>

<h3 id="1-2-JSON-语法规则"><a href="#1-2-JSON-语法规则" class="headerlink" title="1.2 JSON 语法规则"></a>1.2 JSON 语法规则</h3><ul>
<li>数据格式为 键/值 对（一个名称对应一个值）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"name":"julia"</span><br></pre></td></tr></table></figure>

<ul>
<li>数据由逗号分隔</li>
<li>大括号保存对象（对象可以保存多个键值对）</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"julia"</span>, <span class="attr">"url"</span>:<span class="string">"juliajiang7.github.io/"</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方括号保存数组，数组可以包含对象</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"sites":[</span><br><span class="line">    &#123;"name":"julia", "url":"juliajiang7.github.io"&#125;,</span><br><span class="line">    &#123;<span class="attr">"name"</span>:<span class="string">"Google"</span>, <span class="attr">"url"</span>:<span class="string">"www.google.com"</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>详细请参考 <a href="https://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">JSON教程</a></p>
<h2 id="2-使用-json-lib"><a href="#2-使用-json-lib" class="headerlink" title="2. 使用 json-lib"></a>2. 使用 json-lib</h2><p><a href="http://json-lib.sourceforge.net/" target="_blank" rel="noopener">http://json-lib.sourceforge.net/</a></p>
<p>JSON-lib is a java library for transforming beans, maps, collections, java arrays and XML to JSON and back again to beans and DynaBeans.<br>It is based on the work by Douglas Crockford in <a href="http://www.json.org/java" target="_blank" rel="noopener">http://www.json.org/java</a>.</p>
<h3 id="2-1-引入-maven"><a href="#2-1-引入-maven" class="headerlink" title="2.1 引入 maven"></a>2.1 引入 maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-json-对象转为-Java-对象"><a href="#2-2-json-对象转为-Java-对象" class="headerlink" title="2.2 json 对象转为 Java 对象"></a>2.2 json 对象转为 Java 对象</h3><h4 id="2-2-1-创建实体-Student"><a href="#2-2-1-创建实体-Student" class="headerlink" title="2.2.1 创建实体 Student"></a>2.2.1 创建实体 Student</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean isValid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getIsValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsValid</span><span class="params">(Boolean valid)</span> </span>&#123;</span><br><span class="line">        isValid = valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-转换对象"><a href="#2-2-2-转换对象" class="headerlink" title="2.2.2 转换对象"></a>2.2.2 转换对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"julia\", \"age\":16, \"isValid\":true&#125;"</span>;</span><br><span class="line">    <span class="comment">// 将json字符串转为JSONObject对象</span></span><br><span class="line">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class="line">    <span class="comment">// 将JSONObject对象转为Student对象</span></span><br><span class="line">    Student student = (Student) JSONObject.toBean(jsonObject, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-json-数组转为-Java-的-List-lt-T-gt"><a href="#2-3-json-数组转为-Java-的-List-lt-T-gt" class="headerlink" title="2.3 json 数组转为 Java 的 List&lt;T&gt;"></a>2.3 json 数组转为 Java 的 List&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"name\":\"julia\", \"age\":16, \"isValid\":true&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\", \"age\":17, \"isValid\":false&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"jiang\", \"age\":18, \"isValid\":true&#125;]"</span>;</span><br><span class="line">    <span class="comment">// 将json数组转为JSONArray对象</span></span><br><span class="line">    JSONArray jsonArray = JSONArray.fromObject(jsonStr);</span><br><span class="line">    <span class="comment">// 将JSONArray对象转为List</span></span><br><span class="line">    List&lt;Student&gt; students = (List&lt;Student&gt;) JSONArray.toCollection(jsonArray, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(students);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-json-复杂数据转为-JavaBean-对象"><a href="#2-4-json-复杂数据转为-JavaBean-对象" class="headerlink" title="2.4 json 复杂数据转为 JavaBean 对象"></a>2.4 json 复杂数据转为 JavaBean 对象</h3><p>如果 json 对象中包含数组，这个数组中包含 json 对象，如下所示：</p>
<p><img src="/pictures/image-20200514143731277-1595486755603.png" alt="image-20200514143731277"></p>
<p>要将这个 json 字符串转为 JavaBean 对象，实体类需要有 List&lt;Student&gt; 属性。定义实体来 Teacher 如下：</p>
<h4 id="2-4-1-创建-Teacher-对象"><a href="#2-4-1-创建-Teacher-对象" class="headerlink" title="2.4.1 创建 Teacher 对象"></a>2.4.1 创建 Teacher 对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-转换对象"><a href="#2-4-2-转换对象" class="headerlink" title="2.4.2 转换对象"></a>2.4.2 转换对象</h4><p>我们还是采用前面的方式进行转换，发现在获取 <code>student.getName()</code> 时报错<strong>net.sf.ezmorph.bean.MorphDynaBean cannot be cast to</strong> 如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"teacher\", \"age\":30, \"students\":"</span> +</span><br><span class="line">        <span class="string">"[&#123;\"name\":\"julia\",\"age\":16,\"isValid\":true&#125;,"</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\",\"age\":17,\"isValid\":false&#125;]&#125;"</span>;</span><br><span class="line">    <span class="comment">// 将json数组转为JSONArray对象</span></span><br><span class="line">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class="line">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="keyword">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Teacher&#123;name='teacher', age=30, students=[net.sf.ezmorph.bean.MorphDynaBean@3c6aa04a[</span></span><br><span class="line"><span class="comment">  &#123;isValid=true, name=julia, age=16&#125;</span></span><br><span class="line"><span class="comment">], net.sf.ezmorph.bean.MorphDynaBean@2257fadf[</span></span><br><span class="line"><span class="comment">  &#123;isValid=false, name=fan, age=17&#125;</span></span><br><span class="line"><span class="comment">]]&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.juliajiang.blogtest.entity.Student</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这是因为：在操作 json 数据时，如果没有指明数据类型，那么只能是基本类型（比如上述Integer、Boolean等）或者String类型，不能出现复杂数据类型。</p>
<p>应该采用如下方式转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"teacher\", \"age\":30, \"students\":"</span> +</span><br><span class="line">        <span class="string">"[&#123;\"name\":\"julia\",\"age\":16,\"isValid\":true&#125;,"</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\",\"age\":17,\"isValid\":false&#125;]&#125;"</span>;</span><br><span class="line">    <span class="comment">// 将json数组转为JSONArray对象</span></span><br><span class="line">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class="line">    Map&lt;String, Class&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"students"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 添加map</span></span><br><span class="line">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class="class">.<span class="keyword">class</span>, <span class="title">map</span>)</span>;</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="keyword">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class="line"><span class="comment">julia</span></span><br><span class="line"><span class="comment">fan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>其中 map 对象是 Teacher 中各个属性的类型，map 的 key 是属性的名，value 是属性的类型。</p>
<h2 id="3-使用-fastjson"><a href="#3-使用-fastjson" class="headerlink" title="3. 使用 fastjson"></a>3. 使用 fastjson</h2><p>fastjson 中文WiKi：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p>
<h3 id="3-1-什么是-fastjson"><a href="#3-1-什么是-fastjson" class="headerlink" title="3.1 什么是 fastjson?"></a>3.1 什么是 fastjson?</h3><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>
<h3 id="3-2-引入-maven"><a href="#3-2-引入-maven" class="headerlink" title="3.2 引入 maven"></a>3.2 引入 maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-json-字符串与-Java-对象互转"><a href="#3-3-json-字符串与-Java-对象互转" class="headerlink" title="3.3 json 字符串与 Java 对象互转"></a>3.3 json 字符串与 Java 对象互转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="string">"julia"</span>, <span class="number">16</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 将Java对象转为json字符串</span></span><br><span class="line">    String jsonString = JSON.toJSONString(student);</span><br><span class="line">    System.out.println(jsonString);</span><br><span class="line">    <span class="comment">// 将json字符串转为Java对象</span></span><br><span class="line">    Student student1 = JSON.parseObject(jsonString, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">&#123;"age":16,"isValid":true,"name":"julia"&#125;</span></span><br><span class="line"><span class="comment">Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-json-数组转为-List-lt-T-gt"><a href="#3-4-json-数组转为-List-lt-T-gt" class="headerlink" title="3.4 json 数组转为 List&lt;T&gt;"></a>3.4 json 数组转为 List&lt;T&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"name\":\"julia\", \"age\":16, \"isValid\":true&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\", \"age\":17, \"isValid\":false&#125;, "</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"jiang\", \"age\":18, \"isValid\":true&#125;]"</span>;</span><br><span class="line">    List&lt;Student&gt; students = JSONArray.parseArray(jsonStr, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(students);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-json-复杂数据转为-Java-对象"><a href="#3-5-json-复杂数据转为-Java-对象" class="headerlink" title="3.5 json 复杂数据转为 Java 对象"></a>3.5 json 复杂数据转为 Java 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"teacher\", \"age\":30, \"students\":"</span> +</span><br><span class="line">        <span class="string">"[&#123;\"name\":\"julia\",\"age\":16,\"isValid\":true&#125;,"</span> +</span><br><span class="line">        <span class="string">"&#123;\"name\":\"fan\",\"age\":17,\"isValid\":false&#125;]&#125;"</span>;</span><br><span class="line">    Teacher teacher = JSON.parseObject(jsonStr, Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(teacher);</span><br><span class="line">    <span class="keyword">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class="line"><span class="comment">julia</span></span><br><span class="line"><span class="comment">fan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-fastjson-和-json-lib-对比"><a href="#4-fastjson-和-json-lib-对比" class="headerlink" title="4. fastjson 和 json-lib 对比"></a>4. fastjson 和 json-lib 对比</h2><p>就以上三种使用途径来看，fastjson 确实更加方便。</p>
<h2 id="5-json-数据的传输与接收"><a href="#5-json-数据的传输与接收" class="headerlink" title="5. json 数据的传输与接收"></a>5. json 数据的传输与接收</h2><p>JSON 通常用于与服务端交换数据，在向服务器发送数据时一般是字符串。我们可以使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为字符串。</p>
<p>向服务器发送请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> param = <span class="built_in">JSON</span>.stringify(searchList);</span><br><span class="line">$.post(url, &#123;</span><br><span class="line">            searchList:param</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/*...*/</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>springboot 后台 controller 接收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/search"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">search</span><span class="params">(String searchList)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将前台接收的 json 数组转化为实体SearchList的列表</span></span><br><span class="line">    List&lt;SearchList&gt; lists = JSONArray.parseArray(searchList, SearchList<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ol>
<li><a href="https://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/json/json-tutorial.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/07/16/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要介绍了 KMP算法的基本思想、代码、优化以及时间复杂度分析。</p>
<h2 id="1-KMP算法思想"><a href="#1-KMP算法思想" class="headerlink" title="1. KMP算法思想"></a>1. KMP算法思想</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p><strong>字符串匹配</strong> 是计算机的基本任务之一。举例来说，即有一个字符串”BBC ABCDAB ABCDABCDABDE”，判断该字符串中是否包含另一个字符串”ABCDABD”？许多算法可以完成这个任务，<a href="https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法" target="_blank" rel="noopener">Knuth-Morris-Pratt算法</a>（简称KMP）是最常用的之一。它以三个发明者命名，其中K代表著名科学家Donald Knuth。KMP算法可在一个字符串S内查找一个词P的出现位置，如果有返回P的起始索引，否则返回-1.</p>
<p>接下来，我会先举例对KMP算法的思路进行解释（不涉及任何代码）。</p>
<a id="more"></a>

<h3 id="1-2-基本思路"><a href="#1-2-基本思路" class="headerlink" title="1.2 基本思路"></a>1.2 基本思路</h3><ol>
<li><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”（称为文本串）的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<img src="/pictures/bg2013050103.png" alt="img" style="zoom:67%;" />
</li>
<li><p>因为B与A不匹配，模式串再往后移。</p>
<img src="/pictures/bg2013050104.png" alt="img" style="zoom:67%;" />
</li>
<li><p>就这样，直到文本串有一个字符，与模式串的第一个字符相同为止。</p>
<img src="/pictures/bg2013050105.png" alt="img" style="zoom:67%;" />
</li>
<li><p>接着比较文本串和模式串的下一个字符，还是相同。</p>
<img src="/pictures/bg2013050106.png" alt="img" style="zoom:67%;" />
</li>
<li><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<img src="/pictures/bg2013050107.png" alt="img" style="zoom:67%;" />
</li>
<li><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做固然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<img src="/pictures/bg2013050108.png" alt="img" style="zoom:67%;" />
</li>
<li><p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。</p>
<img src="/pictures/bg2013050107-1594975043794.png" alt="img" style="zoom:67%;" />
</li>
<li><p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<img src="/pictures/bg2013050109.png" alt="img" style="zoom:67%;" />
</li>
<li><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B（不匹配字符的前一个字符）对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的部分匹配值</span><br></pre></td></tr></table></figure>

<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
</li>
<li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<img src="/pictures/bg2013050110.png" alt="img" style="zoom:67%;" />
</li>
<li><p>因为空格与A不匹配，继续后移一位。</p>
<img src="/pictures/bg2013050111.png" alt="img" style="zoom:67%;" />
</li>
<li><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<img src="/pictures/bg2013050112.png" alt="img" style="zoom:67%;" />
</li>
<li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<img src="/pictures/bg2013050113.png" alt="img" style="zoom: 67%;" />
</li>
<li><p>下面介绍《部分匹配表》是如何产生的。</p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<img src="/pictures/bg2013050114.png" alt="img" style="zoom:67%;" />
</li>
<li><p>“部分匹配值”就是”前缀”和”后缀”的最大公共元素长度。以”ABCDABD”为例，计算过程如下：</p>
<p><img src="/pictures/20140725231726921" alt="img"></p>
</li>
<li><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<img src="/pictures/bg2013050112-1594975805920.png" alt="img" style="zoom:67%;" />

</li>
</ol>
<p>到此，我们对于KMP的基本思路有了一个大致的了解，下一部分介绍KMP具体算法细节、代码及优化。</p>
<h2 id="2-KMP算法代码及优化"><a href="#2-KMP算法代码及优化" class="headerlink" title="2. KMP算法代码及优化"></a>2. KMP算法代码及优化</h2><p>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>
<h3 id="2-1-暴力匹配算法"><a href="#2-1-暴力匹配算法" class="headerlink" title="2.1 暴力匹配算法"></a>2.1 暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>
<ul>
<li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li>
<li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>
</ul>
<p>暴力匹配代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-KMP算法"><a href="#2-2-KMP算法" class="headerlink" title="2.2 KMP算法"></a>2.2 KMP算法</h3><h4 id="2-2-1-求解-next-数组"><a href="#2-2-1-求解-next-数组" class="headerlink" title="2.2.1 求解 next 数组"></a>2.2.1 求解 next 数组</h4><h5 id="2-2-1-1-基本思路"><a href="#2-2-1-1-基本思路" class="headerlink" title="2.2.1.1 基本思路"></a>2.2.1.1 基本思路</h5><p>前文已经计算过“部分匹配表”，即前缀和后缀的最大公共元素长度，如下图所示：</p>
<p><img src="/pictures/20140725231726921" alt="img"></p>
<p>由前文可知，失配时，模式串向右移动的位数公式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的最大公共元素长度</span><br></pre></td></tr></table></figure>

<p>由此我们发现，当匹配一个字符失配时，我们并不会考虑当前字符，而是看失配字符的前一个字符的最大公共元素长度，如此，便引出了next数组。<strong>next 数组相当于最大长度值整体向右移动一位，然后初值赋为-1.</strong> 因而，对于给定的模式串，它的最大长度及next数组分别如下：</p>
<p><img src="/pictures/20140728110939595" alt="img"></p>
<p>求得next数组之后，失配时模式串向右移动的位数为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">移动位数 = 失配字符所在位置 - 失配字符对应的next值</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-2-代码计算-next-数组"><a href="#2-2-1-2-代码计算-next-数组" class="headerlink" title="2.2.1.2 代码计算 next 数组"></a>2.2.1.2 代码计算 next 数组</h5><ol>
<li><p>如果<strong>对于值 k, 已有 p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k</strong>。究其本质，<strong>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀</strong>。有了这个next 数组，在KMP匹配中，当模式串中 j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动 j - next[j] 位。</p>
</li>
<li><p>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</p>
<ul>
<li><p>若p[k] == p[j]，则next[j + 1] = next [j] + 1 = k + 1。</p>
<p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p>
<p><img src="/pictures/20140729182154066" alt="img"></p>
</li>
<li><p>若p[k ] ≠ p[j]，如果此时 p[next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</p>
<p>如下图所示，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。<br><img src="/pictures/20140729181940812" alt="img">   </p>
<p>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk’-1 pk’ = pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] = k’ + 1 = next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。</p>
<p>那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？ 这又归根到next数组的含义。<strong>我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。</strong></p>
</li>
</ul>
</li>
<li><p>综上，可以通过递推求得 next 数组，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] p)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            next[++j] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-2-1-3-总结-next-数组含义"><a href="#2-2-1-3-总结-next-数组含义" class="headerlink" title="2.2.1.3 总结 next 数组含义"></a>2.2.1.3 总结 next 数组含义</h5><ol>
<li>代表失配字符之前的字符串中，有多大长度的相同前缀后缀。</li>
<li>在某个字符失配后，next 值会告诉你下一步匹配中，模式串应该跳到哪个位置。如果next [j] 等于0或 -1，则跳到模式串的开头字符；若next [j] = k 且 k &gt; 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</li>
</ol>
<h4 id="2-2-2-KMP-算法"><a href="#2-2-2-KMP-算法" class="headerlink" title="2.2.2 KMP 算法"></a>2.2.2 KMP 算法</h4><p>根据上文的分析，KMP算法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || s[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-next-数组的优化"><a href="#2-2-3-next-数组的优化" class="headerlink" title="2.2.3 next 数组的优化"></a>2.2.3 next 数组的优化</h4><p>行文至此，我们全面了解了KMP算法的基本思路、流程、代码以及next 数组的求解，但忽略了一个小问题。</p>
<p>比如，如果用之前的next 数组方法求模式串“abab”的 next 数组，可得其 next 数组为 -1 0 0 1，当它跟下图中的文本串去匹配的时候，发现 b 跟 c 失配，于是模式串右移 j - next[j] = 3 - 1 = 2位。</p>
<img src="/pictures/8394323_1308075859Zfue.jpg" alt="8394323_1308075859Zfue" style="zoom:67%;" />

<p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</p>
<img src="/pictures/8394323_13080758591kyV-1595069195969.jpg" alt="8394323_13080758591kyV" style="zoom:67%;" />

<p>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p>
<p>因此，求解 next 数组的代码优化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNextval(<span class="keyword">char</span>[] p)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(p[j] != p[k])&#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-KMP-算法时间复杂度分析"><a href="#3-KMP-算法时间复杂度分析" class="headerlink" title="3. KMP 算法时间复杂度分析"></a>3. KMP 算法时间复杂度分析</h2><p>我们先来回顾一下KMP算法的流程，假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置：</p>
<ol>
<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</li>
</ol>
<p>我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。</p>
<p>所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p>
<h2 id="4-例题：实现-strStr-28"><a href="#4-例题：实现-strStr-28" class="headerlink" title="4. 例题：实现 strStr() [28]"></a>4. 例题：实现 strStr() [28]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a>；另一种动态规划在我的另一篇博客：<a href="">这里</a>.</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"aaaaa"</span>, needle = <span class="string">"bba"</span></span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] p = needle.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = getNextval(p);</span><br><span class="line">    <span class="keyword">return</span> kmp(s, p, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || s[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNextval(<span class="keyword">char</span>[] p)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(p[j] != p[k])&#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><ol>
<li><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Algorithm</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>设计数据库的一些认识</title>
    <url>/2020/07/12/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>近期把之前一个小项目重新进行了规整，发现之前数据库设计存在很多问题。本文参考了一些数据库设计的基本规范以及经验等等，谈一些自己对于数据库设计的认识吧。</p>
<h2 id="1-关系数据库的范式"><a href="#1-关系数据库的范式" class="headerlink" title="1. 关系数据库的范式"></a>1. 关系数据库的范式</h2><p><strong><a href="[https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96](https://zh.wikipedia.org/wiki/数据库规范化)">数据库规范化</a></strong>，又称正规化、标准化，是数据库设计的一系列原理和技术，以减少数据库中数据冗余，增进数据的一致性。</p>
<p>关系数据库的范式有：第一范式、第二范式、第三范式、BC范式（第三范式的改进范式），除外还包括针对多值依赖的第四范式，连接依赖的第五范式、DK范式和第六范式。</p>
<a id="more"></a>

<p>现在数据库设计最多满足3NF，普遍认为范式过高，虽然具有对数据关系更好的约束性，但也导致数据关系表增加而令数据库IO更易繁忙，原来交由数据库处理的关系约束现更多在数据库使用程序中完成。</p>
<p><img src="/pictures/image-20200426223214696.png" alt="image-20200426223214696"></p>
<h3 id="1-1-第一范式"><a href="#1-1-第一范式" class="headerlink" title="1.1. 第一范式"></a>1.1. 第一范式</h3><p><a href="[https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E6%AD%A3%E8%A6%8F%E5%8C%96](https://zh.wikipedia.org/wiki/第一正規化)">第一范式（1NF）</a> 是数据库正规化所使用的正规形式。第一范式是为了要排除 <em>重复组</em> 的出现，所采用的方法是要求数据库的每个列的值域都是由 <strong>原子值</strong> 组成；每个字段的值都只能是单一值。</p>
<p>不符合第一范式的情况：</p>
<ol>
<li><p>重复组</p>
<p>重复组通常会出现在会计账上，每一笔记录可能有不定个数的值。举例来说：</p>
<img src="/pictures/image-20200426223643952.png"/>

<p>“数量”就是所谓的重复组了，而在这种情况下这份数据就不符合第一范式。想要消除重复组的话，只要把每笔记录都转化为单一记录即可：</p>
<img src="/pictures/image-20200426223715720.png" />
</li>
<li><p>缺乏唯一标识符</p>
<p>一样是在交易这个例子中，同一天同一个人买了同样的数量，这样的交易做了两次：</p>
<img src="/pictures/image-20200426224653184.png" />

<p>如上所示，这两笔交易可以说是一模一样，也就是说如果只靠这些数据我们没有办法分辨这两笔记录。我们之所以说它不符合第一范式，是因为上面这样的表示法欠缺一个唯一标识符，可以是一个字段，也可以是一组字段，而且可以保证在这个数据中唯一标识符不会重复出现。要将它正规化到符合第一范式的原则只需要加入一个唯一标识符即可：</p>
<img src="/pictures/image-20200426224741598.png"  />
</li>
<li><p>单一字段中有多个有意义的值</p>
<p>在单一字段中存放多个值是违反第一范式的做法，下面这个就是很好的例子，它把多个值用逗号分开来表示：</p>
<img src="/pictures/image-20200426225059906.png" />

<p>以这样的设计看来，想要知道有什么人不喜欢某样特定的东西是很不容易的。不过可以把这个数据表转化成下面这种符合第一范式的型式：</p>
<img src="/pictures/image-20200426225223170.png" />
</li>
<li><p>用很多字段来表达同一个事实</p>
<p>在同一个数据表里用多个字段来表达同一个事情也是违反第一范式的：</p>
<img src="/pictures/image-20200426225402284.png" />

<p>就算我们能确定每个人不喜欢吃的食物最多不会超过三样，这还是一个很糟的设计。举例来说，我们想要知道所有不喜欢同一种食物的人的组合的话，这就不是件容易的事，因为食物有可能出现在任何一个字段，也就是说每一次的查询都要去检查 9 (3 x 3) 组不同的字段组合。</p>
</li>
</ol>
<h3 id="1-2-第二范式"><a href="#1-2-第二范式" class="headerlink" title="1.2. 第二范式"></a>1.2. 第二范式</h3><p><strong><a href="[https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E6%AD%A3%E8%A6%8F%E5%8C%96](https://zh.wikipedia.org/wiki/第二正規化)">第二范式（2NF）</a></strong> 是数据库正规化所使用的正规形式。规则是要求数据表里的所有数据都要和该数据表的键（主键与<em>候选键 [下文有介绍 ]</em>）有完全依赖关系：每个非键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些数据只和一个键的一部分有关的话，就得把它们独立出来变成另一个数据表。如果一个数据表的键只有单个字段的话，它就一定符合第二范式。</p>
<p>一个数据表符合第二范式当且仅当：</p>
<ul>
<li>它符合第一范式</li>
<li>所有非键字段都不能是候选键非全体字段的函数</li>
</ul>
<p>示例：</p>
<p>有一个数据表记录了设备组件的信息，如下所示</p>
<img src="/pictures/image-20200426230751958.png"  />

<p>这个数据表的每个值都是单一值，所以它符合第一范式。因为同一个组件有可能由不同的供应商提供，所以得把组件 ID 和供应商 ID 合在一起组成一个主键。</p>
<p>组件（关键词）和价格之间的关系很正确：同一个组件在不同供应商有可能会有不同的报价，所以价格确实和主键完全相关（完全依赖）。</p>
<p>另一方面，供应商的名称和住址就只和供应商 ID 有关（部分依赖），这不符合第二范式的原则。仔细看就会发现 “Stylized Parts” 这个名称和 “VA” 这个住址重复出现了两次；要是它改名了或是被其他公司并购了怎么办？这时候最好把这些数据存到第二个数据表中：</p>
<img src="/pictures/image-20200426230943516.png" />

<p>这么一来，原本的 “组件来源” 数据表就得要做相对应的改动：</p>
<img src="/pictures/image-20200426231044849.png" />

<p>检查数据表里的每个字段，确认它们是不是都和关键词完全相关， 这样才能知道这个数据表是不是符合第二范式； 如果不是的话，就把那些不完全相关的字段移到独立的数据表里。 接下来的步骤是要确保所有不是键的字段都和彼此没有相依关系，这就叫做 <a href="https://zh.wikipedia.org/wiki/第三正規化" target="_blank" rel="noopener">第三范式</a>。</p>
<h3 id="1-3-第三范式"><a href="#1-3-第三范式" class="headerlink" title="1.3. 第三范式"></a>1.3. 第三范式</h3><p><strong><a href="[https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%89%E6%AD%A3%E8%A6%8F%E5%8C%96](https://zh.wikipedia.org/wiki/第三正規化)">第三范式（3NF）</a></strong> 是数据库正规化所使用的正规形式，要求所有非主键属性都只和候选键有相关性，也就是说非主键属性之间应该是独立无关的。如果再对第三范式做进一步加强就成了<a href="https://zh.wikipedia.org/wiki/BC正規化" target="_blank" rel="noopener">BC正规化</a>，强调的重点在于“数据间的关系是奠基在主键上、以整个主键为考量、而且除了主键之外不考虑其他因素”。</p>
<p>以下面这个定义机械组件的关系为例：</p>
<img src="/pictures/image-20200427232114257.png" />

<p>本例中制造商地址很明显地不该被列在这个关系里面，因为和组件本身比起来，制造商地址应该和制造商比较有关系；正确的做法应该是把独立成为一个新的数据表：</p>
<img src="/pictures/image-20200427232353749.png" />

<p>然后把原本的数据表改成这样：</p>
<img src="/pictures/image-20200427232447340.png" />

<p>先前那个数据表的问题在于每提到一次制造商名称就要多存一次它的地址，而这就不符合第三范式的原则。</p>
<p>下面提供了另一个例子：</p>
<img src="/pictures/image-20200427232554631.png" />

<p>在本例中，非主键字段完全依赖于主键订单编号，也就是说唯一的订单编号能导出唯一非主键字段值，符合第二范式。第三范式要求非主键字段之间不能有依赖关系，显然本例中小计依赖于非主键字段“单价”和“数量”，不符合第三范式。小计不应该放在这个数据表里面，只要把单价乘上数量就可以得到小计了；如果想要符合第三范式的话，就把小计拿掉吧 (不过在做查询的时候，本来用 SELECT Order.Total FROM Order 就要改成用 SELECT UnitPrice * Quantity FROM Order 了)。</p>
<img src="/pictures/image-20200427232650317.png" />

<h3 id="1-4-第四范式"><a href="#1-4-第四范式" class="headerlink" title="1.4. 第四范式"></a>1.4. 第四范式</h3><p><strong><a href="[https://zh.wikipedia.org/wiki/%E7%AC%AC%E5%9B%9B%E6%AD%A3%E8%A6%8F%E5%8C%96](https://zh.wikipedia.org/wiki/第四正規化)">第四正规化（4NF）</a></strong> 是数据库正规化中所使用的一种正规形式，是BC范式之后的另一层次的规范化。第二范式、第三范式、BC范式关注于属性集合之间的函数依赖；而第四范式关注更一般形式称作 <strong>多值依赖</strong>。</p>
<p>例子：</p>
<img src="/pictures/image-20200428230552342.png" />

<p>每一行指出一家饭店能提供一种披萨与一个配货地区。</p>
<p>该表没有非键属性，因为它仅有的键是{Restaurant, Pizza Variety, Delivery Area}。因此，它满足到BC范式为止的所有范式。如果假设，饭店提供的披萨种类与配货地区无关。也即饭店为所有的供货地区提供它能制作的所有披萨类型。那么，这个表不满足第四范式。因为这个表在{Restaurant}属性（它不是超键）上提供了两个非平凡的多值依赖:</p>
<ul>
<li>{Restaurant} -&gt; {Pizza Variety}</li>
<li>{Restaurant} -&gt; {Delivery Area}</li>
</ul>
<p>这些在一个非超键上的非平凡多值依赖说明了饭店提供的披萨的多样性独立于饭店的供货地区。这导致了该表中的数据冗余：例如，A1 Pizza供货 Stuffed Crust就重复了3遍；如果A1 Pizza开始生产Cheese Crust pizzas那么向表中增加多行，A1 Pizza的每个供货地区都需要一行。这就可能在给A1 Pizza的每个供货地区增加一行Cheese Crust披萨时，遗漏了一个供货地区，从而导致不满足于多值依赖{Restaurant}-&gt;{Pizza Variety}。</p>
<p>为了避免上述的错误发生，需要把披萨的多样性与供货地区放置在不同的表中，产生了两张满足第四范式的表：</p>
<img src="/pictures/image-20200428231345713.png" />

<p>如果披萨的种类随着供货地区不同而变化，那么最初的三列的表就满足第四范式。</p>
<h3 id="1-5-第五范式"><a href="#1-5-第五范式" class="headerlink" title="1.5. 第五范式"></a>1.5. 第五范式</h3><p><strong><a href="[https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F](https://zh.wikipedia.org/wiki/第五范式)">第五范式 (5NF)</a></strong>，也称投影-连接范式（project-join normal form，PJ/NF）是数据库规范化的一个级别，以去除多个关系之间的语义相关。一张表满足第五范式当且仅当它的每个连接依赖可由候选键推出。</p>
<p>例子：</p>
<img src="/pictures/image-20200428232129091.png" />

<p>三列共同组成了主键。该表也满足第四范式，因为不存在多值依赖。</p>
<p>如果没有任何规则限制上门推销员、品牌、产品类型的组合，那么上述三个属性的表是必须的以描述这些数据。但是，如果假定存在下述规则：如果上门推销员经营某个品牌与某个产品类型，那么该推销员必须经营该品牌制造的该产品类型的商品。这种情形下，可以把上表分为三个表：</p>
<p><img src="/pictures/image-20200428232253846.png" alt="image-20200428232253846"></p>
<p>在这种情形下，如果上门推销员推销Acme的其它类型的产品也推销其它品牌的真空吸尘器，则他Louis Ferguson不可能拒绝销售由ACME制造的真空吸尘器（Vacuum Cleaner）。</p>
<p>注意这种方式是如何去除数据冗余。假设经营面包箱与真空吸尘器的上门推销员Jack Schneider开始新增销售Robusto品牌。在最初的那张表中，需要增加两行： (&lt;Jack Schneider, Robusto, Breadboxes&gt;, &lt;Jack Schneider, Robusto, Vacuum Cleaners&gt;)。而在分解后的三张表的设计中，仅需要在表“Brands By Traveling Salesman”中增加一行：(&lt;Jack Schneider, Robusto&gt;)。</p>
<p>用途：</p>
<p>仅在很少情况下满足第四范式的表可能会不满足第五范式。这发生在复杂的真实世界的约束限定了属性的有效组合，但不能在满足第四范式的表的结构中体现出来。这种表如果不能规范化为第五范式，就需要应用程序通过插入、修改、删除等操作来维护表中的数据的逻辑一致性。相反，满足第五范式的表的设计排除了这种不一致性。</p>
<h2 id="2-关系键"><a href="#2-关系键" class="headerlink" title="2. 关系键"></a>2. 关系键</h2><p><strong><a href="[https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E9%94%AE](https://zh.wikipedia.org/wiki/关系键)">关系键</a></strong> 是关系数据库的重要组成部分。关系键是一个表中的一个或几个属性，用来标识该表的每一行或与另一个表产生联系。</p>
<p><img src="/pictures/280px-PrimaryKey_zht.svg.png" alt="img"></p>
<h2 id="3-书写高质量SQL的建议"><a href="#3-书写高质量SQL的建议" class="headerlink" title="3. 书写高质量SQL的建议"></a>3. 书写高质量SQL的建议</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">MySQL高性能优化规范建议</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树总结</title>
    <url>/2020/07/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文介绍了什么是二叉树，同时解决了部分LeetCode上二叉树相关的题目，这部分会持续更新。</p>
<h2 id="1-什么是二叉树？"><a href="#1-什么是二叉树？" class="headerlink" title="1. 什么是二叉树？"></a>1. 什么是二叉树？</h2><p><a href="https://zh.wikipedia.org/wiki/二叉树" target="_blank" rel="noopener">维基定义</a>：在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p>
<p>二叉树的第 <code>i</code> 层至多拥有 2<sup>i-1</sup> 个节点；深度为 k 的二叉树至多总共有 2<sup>k</sup>-1 个节点（定义根节点所在深度 k<sub>0</sub>=0}），而总计拥有节点数符合的，称为 <strong>满二叉树</strong>；深度为 k 有 n 个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度 k 的满二叉树，序号为1到 n 的节点一对一对应时，称为 <strong>完全二叉树</strong>。对任何一棵非空的二叉树T，如果其叶片（终端节点）数为 n<sub>0</sub>，分支度为2的节点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1。</p>
<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p>
<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。</p>
<a id="more"></a>

<h2 id="2-二叉树相关的题目列表"><a href="#2-二叉树相关的题目列表" class="headerlink" title="2. 二叉树相关的题目列表"></a>2. 二叉树相关的题目列表</h2><table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">94</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">144</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">145</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">102</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">107</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层次遍历 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">104</td>
<td align="center"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">100</td>
<td align="center"><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">101</td>
<td align="center"><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">103</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">105</td>
<td align="center"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">106</td>
<td align="center"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">98</td>
<td align="center"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">99</td>
<td align="center"><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">108</td>
<td align="center"><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">109</td>
<td align="center"><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">有序链表转换二叉搜索树</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">110</td>
<td align="center"><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">114</td>
<td align="center"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">116</td>
<td align="center"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener"> 填充每个节点的下一个右侧节点指针</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">117</td>
<td align="center"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针 II</a></td>
<td align="center">Hard</td>
</tr>
</tbody></table>
<h3 id="2-1-队列操作总结（LinkedList）"><a href="#2-1-队列操作总结（LinkedList）" class="headerlink" title="2.1. 队列操作总结（LinkedList）"></a>2.1. 队列操作总结（LinkedList）</h3><p>参考 <a href="https://blog.csdn.net/NRlovestudy/article/details/98666030" target="_blank" rel="noopener">这里</a>，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 尾部添加元素</span></span><br><span class="line">queue.add(<span class="string">"A"</span>);</span><br><span class="line">queue.add(<span class="string">"B"</span>);</span><br><span class="line">queue.add(<span class="string">"C"</span>);</span><br><span class="line">System.out.println(queue); <span class="comment">// [A, B, C]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取但不删除第一个元素</span></span><br><span class="line">String peek = queue.peek();</span><br><span class="line">System.out.println(peek + <span class="string">" ## "</span> + queue); <span class="comment">// A ## [A, B, C]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并删除第一个元素，没有元素时会发生异常</span></span><br><span class="line">String pop = queue.pop();</span><br><span class="line">System.out.println(pop + <span class="string">" ## "</span> + queue); <span class="comment">// A ## [B, C]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并删除第一个元素，没有元素时返回null</span></span><br><span class="line">String poll = queue.poll();</span><br><span class="line">System.out.println(poll + <span class="string">" ## "</span> + poll); <span class="comment">// B ## B</span></span><br></pre></td></tr></table></figure>

<p>总结：pop 与 poll 都是取出 LinkedList 的第一个元素，并将该元素删除，等效于 removeFirst；不同点：两者的实现所用数据结构不同：</p>
<ul>
<li>poll 是基于队列结构实现的方法，当队列中没有元素时，调用该方法返回 null</li>
<li>pop 是基于栈结构实现的方法，当栈中没有元素时，调用该方法会发生异常</li>
</ul>
<h3 id="2-2-栈操作总结（ArrayDeque）"><a href="#2-2-栈操作总结（ArrayDeque）" class="headerlink" title="2.2. 栈操作总结（ArrayDeque）"></a>2.2. 栈操作总结（ArrayDeque）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">// 入栈，即在首部添加元素</span></span><br><span class="line">stack.push(<span class="string">"A"</span>);</span><br><span class="line">stack.push(<span class="string">"B"</span>);</span><br><span class="line">stack.push(<span class="string">"C"</span>);</span><br><span class="line">System.out.println(stack);      <span class="comment">// [C, B, A]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素，即第一个元素</span></span><br><span class="line">System.out.println(stack.peek() + <span class="string">" ## "</span> + stack); <span class="comment">// C ## [C, B, A]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈，即获取并删除第一个元素</span></span><br><span class="line">System.out.println(stack.pop() + <span class="string">" ## "</span> + stack);    <span class="comment">// C ## [B, A]</span></span><br></pre></td></tr></table></figure>

<h2 id="3-二叉树的中序遍历-94"><a href="#3-二叉树的中序遍历-94" class="headerlink" title="3. 二叉树的中序遍历 [94]"></a>3. 二叉树的中序遍历 [94]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1. 题目描述"></a>3.1. 题目描述</h3><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>


<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="3-2-题目分析"><a href="#3-2-题目分析" class="headerlink" title="3.2. 题目分析"></a>3.2. 题目分析</h3><p>分析参考 <a href="https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html" target="_blank" rel="noopener">这里</a>.</p>
<p>中序遍历使用两种方法：递归和迭代。</p>
<h3 id="3-3-方法一：递归"><a href="#3-3-方法一：递归" class="headerlink" title="3.3. 方法一：递归"></a>3.3. 方法一：递归</h3><p>时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-方法二：栈"><a href="#3-4-方法二：栈" class="headerlink" title="3.4. 方法二：栈"></a>3.4. 方法二：栈</h3><p>时间：O(n)，遍历每个节点；空间：O(h)，压栈消耗，h 是二叉树的高度。</p>
<p>利用栈模拟递归。递归压栈过程，就是保存现场，保存当前的变量。在方法一中，当前有用的变量就是 node，所以我们用栈把每一次的 node 保存起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 程序中尽量避免使用Stack类，太古老，性能差，使用ArrayDeque代替</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 节点不为空就一直压栈</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="comment">// 考虑左子树</span></span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点为空，就出栈</span></span><br><span class="line">        curr = stack.pop();</span><br><span class="line">        res.add(curr.val);</span><br><span class="line">        <span class="comment">// 考虑右子树</span></span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二叉树的前序遍历-144"><a href="#4-二叉树的前序遍历-144" class="headerlink" title="4. 二叉树的前序遍历 [144]"></a>4. 二叉树的前序遍历 [144]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p>
<h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1. 题目描述"></a>4.1. 题目描述</h3><p>给定一个二叉树，返回它的 前序 遍历。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>


<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="4-2-题目分析"><a href="#4-2-题目分析" class="headerlink" title="4.2. 题目分析"></a>4.2. 题目分析</h3><p>中序遍历的迭代法也使用栈实现。</p>
<h3 id="4-3-方法一：递归"><a href="#4-3-方法一：递归" class="headerlink" title="4.3. 方法一：递归"></a>4.3. 方法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    res.add(node.val);</span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-方法二：栈"><a href="#4-4-方法二：栈" class="headerlink" title="4.4. 方法二：栈"></a>4.4. 方法二：栈</h3><p>与中序遍历的迭代方法相比，前序遍历只需要将访问的位置改到根节点处即可，其他代码不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 在此处访问节点</span></span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.poll();</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-二叉树的后序遍历-145"><a href="#5-二叉树的后序遍历-145" class="headerlink" title="5. 二叉树的后序遍历 [145]"></a>5. 二叉树的后序遍历 [145]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p>
<h3 id="5-1-题目描述"><a href="#5-1-题目描述" class="headerlink" title="5.1. 题目描述"></a>5.1. 题目描述</h3><p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>


<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="5-2-方法一：递归"><a href="#5-2-方法一：递归" class="headerlink" title="5.2. 方法一：递归"></a>5.2. 方法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-方法二：栈"><a href="#5-3-方法二：栈" class="headerlink" title="5.3. 方法二：栈"></a>5.3. 方法二：栈</h3><p>相比于前序、中序的栈解法，后序遍历的栈解法会难一些。</p>
<p>原因在于，当遍历完某个根节点的左子树，回到根节点时，中序、先序可以把当前根节点从栈中弹出，然后转到右子树。举例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>当遍历完 2,4,5 时，回到 1 之后就可以把 1 弹出，然后通过 1 到达右子树继续遍历。</p>
<p>而对于后序遍历，当我们到达 1 时，并不能立即把 1 弹出，因为遍历完右子树，还需要将根节点加入到 res 中。</p>
<p>因此，我们就需要判断是从左子树到的根节点，还是从右子树到的根节点。</p>
<p>如果是从左子树到的根节点，此时应该转到右子树。如果从右子树到的根节点，那么就可以弹出当前节点，并存储到 res 中。</p>
<p>当然，如果从左子树到的根节点，此时右子树为 null, 也需要把根节点弹出，并加入到 res 中。</p>
<p>基于上述分析，我们可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="comment">// 记录上一个遍历的节点</span></span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前根节点</span></span><br><span class="line">        TreeNode temp = stack.peek();</span><br><span class="line">        <span class="comment">// 是否变到右子树</span></span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span> &amp;&amp; temp.right != pre)&#123;</span><br><span class="line">            curr = temp.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="comment">// 记录上一个遍历的节点</span></span><br><span class="line">            pre = temp;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-二叉树的层序遍历-102"><a href="#6-二叉树的层序遍历-102" class="headerlink" title="6. 二叉树的层序遍历 [102]"></a>6. 二叉树的层序遍历 [102]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></p>
<h3 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1. 题目描述"></a>6.1. 题目描述</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">  / \</span><br><span class="line"> 9  20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="6-2-方法一：递归（DFS）"><a href="#6-2-方法一：递归（DFS）" class="headerlink" title="6.2. 方法一：递归（DFS）"></a>6.2. 方法一：递归（DFS）</h3><p>由于本题对于层序遍历的结果要求为 <code>List&lt;List&lt;Integer&gt;&gt;</code>, 要把每一层的元素放在一个单独的列表中，因此在递归时需要传入当前层数，如果是新的一层，创建一个新的 <code>List</code> , 存储这一层的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> res;&#125;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.size() == level)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    res.get(level).add(node.val);</span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-方法二：队列（BFS）"><a href="#6-3-方法二：队列（BFS）" class="headerlink" title="6.3. 方法二：队列（BFS）"></a>6.3. 方法二：队列（BFS）</h3><p>依旧是本题对于返回结果的要求，每一层需要单独处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 当前层列表</span></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前队列中的元素个数，即就是当前层的节点数</span></span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">        <span class="comment">// levelNum 必须在外面定义，因为 queue 的大小在不停的变化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">            <span class="comment">// 移除队列第一个元素</span></span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;queue.add(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;queue.add(node.right);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-二叉树的层次遍历-II-107"><a href="#7-二叉树的层次遍历-II-107" class="headerlink" title="7. 二叉树的层次遍历 II [107]"></a>7. 二叉树的层次遍历 II [107]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></p>
<h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1. 题目描述"></a>7.1. 题目描述</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">  / \</span><br><span class="line"> 9  20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>

<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="7-2-方法一：递归"><a href="#7-2-方法一：递归" class="headerlink" title="7.2. 方法一：递归"></a>7.2. 方法一：递归</h3><p>本题的结果是上一题结果的反序，只需要在上一题添加列表时，在表头插入，以此得到反序序列即可。如下代码，改变三处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用链表存储，在表头插入效率更高</span></span><br><span class="line">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> res;&#125;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.size() == level)&#123;</span><br><span class="line">        <span class="comment">// 在链表表头插入，得到反序序列</span></span><br><span class="line">        res.addFirst(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入当前值，注意下标</span></span><br><span class="line">    res.get(res.size() - level - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        helper(node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-方法二：队列"><a href="#7-3-方法二：队列" class="headerlink" title="7.3. 方法二：队列"></a>7.3. 方法二：队列</h3><p>与上一题区别：使用链表存储，插入时从表头插入，得到反序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// 使用链表，在表头插入效率更高</span></span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;queue.add(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;queue.add(node.right);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在表头插入，得到反序结果</span></span><br><span class="line">        res.addFirst(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-二叉树的最大深度-104"><a href="#8-二叉树的最大深度-104" class="headerlink" title="8. 二叉树的最大深度 [104]"></a>8. 二叉树的最大深度 [104]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></p>
<h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1.. 题目描述"></a>8.1.. 题目描述</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>返回它的最大深度 3 。</p>
<h3 id="8-2-方法一：递归（DFS）"><a href="#8-2-方法一：递归（DFS）" class="headerlink" title="8.2. 方法一：递归（DFS）"></a>8.2. 方法一：递归（DFS）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-方法二：层次遍历（BFS）"><a href="#8-3-方法二：层次遍历（BFS）" class="headerlink" title="8.3. 方法二：层次遍历（BFS）"></a>8.3. 方法二：层次遍历（BFS）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;queue.add(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123; queue.add(node.right);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-相同的树-100"><a href="#9-相同的树-100" class="headerlink" title="9. 相同的树 [100]"></a>9. 相同的树 [100]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1. 题目描述"></a>9.1. 题目描述</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="9-2-代码"><a href="#9-2-代码" class="headerlink" title="9.2. 代码"></a>9.2. 代码</h3><p>思路：对两颗树同时进行遍历比较，这里使用的是中序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span> &amp;&amp; p.val == q.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-对称二叉树-101"><a href="#10-对称二叉树-101" class="headerlink" title="10. 对称二叉树 [101]"></a>10. 对称二叉树 [101]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></p>
<h3 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1. 题目描述"></a>10.1. 题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3</code></pre><p>进阶：</p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h3 id="10-2-方法一：递归"><a href="#10-2-方法一：递归" class="headerlink" title="10.2. 方法一：递归"></a>10.2. 方法一：递归</h3><p>不是简单的比较左右就行，注意这道题是镜像对称的。这里的递归是基于先序遍历的，先看根节点，再判断左右节点，再判断左右节点的子节点是否为镜像对称。</p>
<p>其实就是类似于 DFS 的先序遍历。不同之处是对于 left 子树是正常的先序遍历 根节点 -&gt; 左子树 -&gt; 右子树 的顺序，对于 right 子树的话是 根节点 -&gt; 右子树 -&gt; 左子树 的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p.val == q.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-方法二：迭代（栈）"><a href="#10-3-方法二：迭代（栈）" class="headerlink" title="10.3. 方法二：迭代（栈）"></a>10.3. 方法二：迭代（栈）</h3><p>参考：<a href="https://leetcode.wang/leetcode-101-Symmetric-Tree.html#解法二-dfs-栈" target="_blank" rel="noopener">这里</a>.</p>
<p>把方法一的先序遍历，使用栈将递归改为迭代。使用两个栈分别存储左右字数的序列，出栈时比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; leftStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; rightStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode leftCur = root.left;</span><br><span class="line">    TreeNode rightCur = root.right;</span><br><span class="line">    <span class="keyword">while</span> (leftCur != <span class="keyword">null</span> || rightCur != <span class="keyword">null</span> || !leftStack.isEmpty() || !rightStack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (leftCur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftStack.push(leftCur);</span><br><span class="line">            <span class="comment">// 考虑左子树</span></span><br><span class="line">            leftCur = leftCur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightCur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            rightStack.push(rightCur);</span><br><span class="line">            <span class="comment">// 考虑右子树</span></span><br><span class="line">            rightCur = rightCur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度不同，就返回</span></span><br><span class="line">        <span class="keyword">if</span>(leftStack.size() != rightStack.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        leftCur = leftStack.poll();</span><br><span class="line">        rightCur = rightStack.poll();</span><br><span class="line">        <span class="keyword">if</span>(leftCur.val != rightCur.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑右子树</span></span><br><span class="line">        leftCur = leftCur.right;</span><br><span class="line">        <span class="comment">// 考虑左子树</span></span><br><span class="line">        rightCur = rightCur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-二叉树的锯齿形层次遍历-103"><a href="#11-二叉树的锯齿形层次遍历-103" class="headerlink" title="11. 二叉树的锯齿形层次遍历 [103]"></a>11. 二叉树的锯齿形层次遍历 [103]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></p>
<h3 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1. 题目描述"></a>11.1. 题目描述</h3><p><img src="/pictures/image-20200819111819257.png" alt="image-20200819111819257"></p>
<h3 id="11-2-代码"><a href="#11-2-代码" class="headerlink" title="11.2. 代码"></a>11.2. 代码</h3><p>在 [102] 题的基础上，改变在当前层中加入元素的顺序即可完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 当前层列表</span></span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            <span class="comment">// 在当前层列表中加入元素（只需要改变这里）</span></span><br><span class="line">            <span class="keyword">if</span>(depth % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                level.add(node.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                level.add(<span class="number">0</span>, node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;queue.add(node.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;queue.add(node.right);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过本题加深了对层次遍历迭代解法的理解，代码中通过队列进行层次遍历，即整个遍历的顺序都是在队列的帮助下实现的，其中的 res、level 等都是为了输出结果的形式而定义的。本题依旧是层次遍历，只是在添加结果时，不同的层添加结果的顺序不同。</p>
<h2 id="12-从前序与中序遍历序列构造二叉树-105"><a href="#12-从前序与中序遍历序列构造二叉树-105" class="headerlink" title="12. 从前序与中序遍历序列构造二叉树 [105]"></a>12. 从前序与中序遍历序列构造二叉树 [105]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></p>
<h3 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1. 题目描述"></a>12.1. 题目描述</h3><p><img src="/pictures/image-20200821111825878.png" alt="image-20200821111825878"></p>
<h3 id="12-2-方法一：递归"><a href="#12-2-方法一：递归" class="headerlink" title="12.2. 方法一：递归"></a>12.2. 方法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> iStart, <span class="keyword">int</span> iEnd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pStart 表示先序的第一位索引</span></span><br><span class="line">    <span class="comment">// pEnd 表示先序的最后一位索引</span></span><br><span class="line">    <span class="comment">// 如果输入的前序序列为空，返回 null</span></span><br><span class="line">    <span class="keyword">if</span>(pEnd &lt; pStart)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = preorder[pStart];</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找root，即分隔点</span></span><br><span class="line">    <span class="keyword">int</span> point = iStart;</span><br><span class="line">    <span class="keyword">for</span>(; point &lt;= iEnd; point++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[point] == root)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树长度</span></span><br><span class="line">    <span class="keyword">int</span> leftLen = point - iStart;</span><br><span class="line"></span><br><span class="line">    node.left = helper(preorder, pStart + <span class="number">1</span>, pStart + leftLen, inorder, iStart, point - <span class="number">1</span>);</span><br><span class="line">    node.right = helper(preorder, pStart + leftLen + <span class="number">1</span>, pEnd, inorder, point + <span class="number">1</span>, iEnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(N^2)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，在中序遍历中找到根结点在中序遍历中的位置，是与 N 相关的，这里不计算递归方法占用的时间。</li>
<li>空间复杂度：O(1)，这里不计算递归方法占用的空间。</li>
</ul>
<h3 id="12-3-方法二：使用-HashMap-对递归进行优化"><a href="#12-3-方法二：使用-HashMap-对递归进行优化" class="headerlink" title="12.3. 方法二：使用 HashMap 对递归进行优化"></a>12.3. 方法二：使用 HashMap 对递归进行优化</h3><p>参考 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">这里</a>.</p>
<p>上一方法中每执行一次 helper 都要在中序中寻找根节点，这里使用 HashMap 存储中序序列的索引与节点值，找根节点只需要 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper2(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> iStart, <span class="keyword">int</span> iEnd, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pEnd &lt; pStart)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = preorder[pStart];</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用map找分隔点</span></span><br><span class="line">    <span class="keyword">int</span> point = map.get(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftLen = point - iStart;</span><br><span class="line"></span><br><span class="line">    node.left = helper2(preorder, pStart + <span class="number">1</span>, pStart + leftLen, inorder, iStart, point - <span class="number">1</span>, map);</span><br><span class="line">    node.right = helper2(preorder, pStart + leftLen + <span class="number">1</span>, pEnd, inorder, point + <span class="number">1</span>, iEnd, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，这里不计算递归方法占用的时间。</li>
<li>空间复杂度：O(N)，这里忽略递归方法占用的空间，因为是对数级别的，比 N 小。</li>
</ul>
<h2 id="13-验证二叉搜索树-98"><a href="#13-验证二叉搜索树-98" class="headerlink" title="13. 验证二叉搜索树 [98]"></a>13. 验证二叉搜索树 [98]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p>
<h3 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1. 题目描述"></a>13.1. 题目描述</h3><p><img src="/pictures/image-20200831101224071.png" alt="image-20200831101224071"></p>
<h3 id="13-1-方法一：递归"><a href="#13-1-方法一：递归" class="headerlink" title="13.1. 方法一：递归"></a>13.1. 方法一：递归</h3><p>可以很简单的用递归写出来。想法是，左子树是合法二分查找树，右子树是合法二分查找树，并且根节点大于左孩子，小于右孩子，那么当前树就是合法二分查找树。</p>
<p>注意：判断是否是二叉搜索树，不能只是简单的判断根节点和左右节点的大小关系。而是需要判断左子树和右子树上的所有节点都满足大小关系，并且左子树和右子树也都是二分查找树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.right == <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断左子树 和 左子树与根节点的关系</span></span><br><span class="line">    <span class="keyword">if</span> (isValidBST(root.left)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取左子树的最大值</span></span><br><span class="line">            <span class="keyword">int</span> maxLeft = getMaxOfBST(root.left);</span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= maxLeft) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断右子树 和 右子树与根节点的关系</span></span><br><span class="line">    <span class="keyword">if</span> (isValidBST(root.right)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取右子树最小值</span></span><br><span class="line">            <span class="keyword">int</span> minRight = getMinOfBST(root.right);</span><br><span class="line">            <span class="keyword">if</span> (root.val &gt;= minRight) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取搜索二叉树的最大值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxOfBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = root.val;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        max = root.right.val;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取搜索二叉树最小值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinOfBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = root.val;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = root.left.val;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-3-方法二：另一种递归（推荐）"><a href="#13-3-方法二：另一种递归（推荐）" class="headerlink" title="13.3. 方法二：另一种递归（推荐）"></a>13.3. 方法二：另一种递归（推荐）</h3><p>参考 <a href="https://leetcode.wang/leetCode-98-Validate-Binary-Search-Tree.html" target="_blank" rel="noopener">这里</a> 的解法二，把代码写的简洁了一些。这种递归代码更为简洁，推荐。</p>
<p>解法一中，我们是判断根节点是否合法，找到了左子树中最大的数，右子树中最小的数。 由左子树和右子树决定当前根节点是否合法。</p>
<p>但如果正常的来讲，明明先有的根节点，按理说根节点是任何数都行，而不是由左子树和右子树限定。相反，根节点反而决定了左孩子和右孩子的合法取值范围。</p>
<p>所以，我们可以从根节点进行 DFS，然后计算每个节点应该的取值范围，如果当前节点不符合就返回 false。</p>
<p>也就是说，本题使用先序遍历，判断根节点是否在范围之内，这个范围根据上一层根节点来限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点值均为 Int 型，故最大值设为 long</span></span><br><span class="line">    <span class="keyword">long</span> max = (<span class="keyword">long</span>) Integer.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> min = (<span class="keyword">long</span>) Integer.MIN_VALUE - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> getAns(root, max, min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getAns</span><span class="params">(TreeNode root, <span class="keyword">long</span> max, <span class="keyword">long</span> min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断根节点是否在限定范围内</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断左右子树，同时更新左右子树的限定范围</span></span><br><span class="line">    <span class="keyword">return</span> getAns(root.left, min, root.val) &amp;&amp; getAns(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-4-方法三：迭代（中序遍历的栈解法）"><a href="#13-4-方法三：迭代（中序遍历的栈解法）" class="headerlink" title="13.4. 方法三：迭代（中序遍历的栈解法）"></a>13.4. 方法三：迭代（中序遍历的栈解法）</h3><p>这种解法基于：二叉搜索树中序遍历后，会得到有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBTS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈（这里出栈的值会添加到中序序列后）</span></span><br><span class="line">        curr = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= curr.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-恢复二叉搜索树-99"><a href="#14-恢复二叉搜索树-99" class="headerlink" title="14. 恢复二叉搜索树 [99]"></a>14. 恢复二叉搜索树 [99]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></p>
<h3 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1. 题目描述"></a>14.1. 题目描述</h3><p><img src="/pictures/image-20200831105056785.png" alt="image-20200831105056785"></p>
<h3 id="14-2-方法一：迭代（栈的中序遍历）"><a href="#14-2-方法一：迭代（栈的中序遍历）" class="headerlink" title="14.2. 方法一：迭代（栈的中序遍历）"></a>14.2. 方法一：迭代（栈的中序遍历）</h3><p>参考 <a href="https://leetcode.wang/leetcode-99-Recover-Binary-Search-Tree.html" target="_blank" rel="noopener">这里</a> 的解法二，代码稍微做了一些简化。</p>
<p>对上一题 [98] 的第三种解法进行修改实现本题。</p>
<p>我们判断是否是一个合法的二分查找树是使用到了中序遍历。原因就是二分查找树的一个性质，左孩子小于根节点，根节点小于右孩子。所以做一次中序遍历，产生的序列就是从小到大排列的有序序列。</p>
<p>回到这道题，题目交换了两个数字，其实就是在有序序列中交换了两个数字。而我们只需要把它还原。</p>
<p>交换的位置的话就是两种情况。</p>
<ul>
<li><p>相邻的两个数字交换</p>
<p>[ 1 2 3 4 5 ] 中 2 和 3 进行交换，[ 1 3 2 4 5 ]，这样的话只产生 <strong>一组</strong> 逆序的数字（正常情况是从小到大排序，交换后产生了从大到小），3 2。</p>
<p>我们只需要遍历数组，找到后，把这一组的两个数字进行交换即可。</p>
</li>
<li><p>不相邻的两个数字交换</p>
<p>[ 1 2 3 4 5 ] 中 2 和 5 进行交换，[ 1 5 3 4 2 ]，这样的话其实就是产生了 <strong>两组</strong> 逆序的数字对。5 3 和 4 2。</p>
<p>所以我们只需要遍历数组，然后找到这两组逆序对，然后把第一组前一个数字和第二组后一个数字进行交换即完成了还原。</p>
</li>
</ul>
<p>所以在中序遍历中，只需要利用一个 pre 节点和当前节点比较，如果 pre 节点的值大于当前节点的值，那么就是我们要找的逆序的数字。分别用两个指针 first 和 second 保存即可。如果找到第二组逆序的数字，我们就把 second 更新为当前节点。最后把 first 和 second 两个的 <strong>数字</strong> 交换即可。</p>
<p>注意：本题逆序出现的两种情况和节点的交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>, first = <span class="keyword">null</span>, second = <span class="keyword">null</span>;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= cur.val) &#123;</span><br><span class="line">            <span class="comment">// 第一次遇到逆序对</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果相邻的数字交换，只会出现一次逆序，因此这里 second 也要赋值</span></span><br><span class="line">                first = pre;</span><br><span class="line">                second = cur;</span><br><span class="line">                <span class="comment">// 第二次遇到逆序对</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">int</span> tmp = first.val;</span><br><span class="line">    first.val = second.val;</span><br><span class="line">    second.val = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-将有序数组转换为二叉搜索树-108"><a href="#15-将有序数组转换为二叉搜索树-108" class="headerlink" title="15. 将有序数组转换为二叉搜索树 [108]"></a>15. 将有序数组转换为二叉搜索树 [108]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></p>
<h3 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1. 题目描述"></a>15.1. 题目描述</h3><p><img src="/pictures/image-20200901091510832.png" alt="image-20200901091510832"></p>
<h3 id="15-2-递归"><a href="#15-2-递归" class="headerlink" title="15.2. 递归"></a>15.2. 递归</h3><p>题目要求平衡二叉树，那么根节点就是数组的中点。找到了数组的中点，作为根节点，进入递归即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = end - start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + len / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = helper(nums, start , mid - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-有序链表转换二叉搜索树-109"><a href="#16-有序链表转换二叉搜索树-109" class="headerlink" title="16.  有序链表转换二叉搜索树 [109]"></a>16.  有序链表转换二叉搜索树 [109]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></p>
<h3 id="16-1-题目描述"><a href="#16-1-题目描述" class="headerlink" title="16.1. 题目描述"></a>16.1. 题目描述</h3><p><img src="/pictures/image-20200902100344960.png" alt="image-20200902100344960"></p>
<h3 id="16-2-方法一：将链表转为-ArrayList"><a href="#16-2-方法一：将链表转为-ArrayList" class="headerlink" title="16.2. 方法一：将链表转为 ArrayList"></a>16.2. 方法一：将链表转为 ArrayList</h3><p>本题就是把上一题 [108] 的数组换成了链表，如果使用上一题的思路，链表不支持随机访问，找中点时时间复杂度很高。所以，我们可以把链表先转为 ArrayList，再使用上一题的思路。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(list, <span class="number">0</span>, list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(list.get(mid));</span><br><span class="line">    root.left = helper(list, start, mid);</span><br><span class="line">    root.right = helper(list, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时复：O(n)</p>
<p>空复：O(n)</p>
<h3 id="16-3-方法二：中序遍历思路"><a href="#16-3-方法二：中序遍历思路" class="headerlink" title="16.3. 方法二：中序遍历思路"></a>16.3. 方法二：中序遍历思路</h3><p>参考 <a href="https://leetcode.wang/leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree.html" target="_blank" rel="noopener">这里</a>。</p>
<p>我们知道升序数组其实就是二叉搜索树的中序遍历。那么，我们可以按照这个顺序去为每个节点赋值。</p>
<p>如何实现呢？套用中序遍历的递归过程，将 start 和 end 作为递归参数，当 start ==  end 时，返回 null。</p>
<p>我们先看一下中序遍历的递归算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">    helper(node.left, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    helper(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历中是将 node.val 进行保存，本题我们是给当前节点进行赋值，为了依次赋值，我们需要一个 cur 指针指向所给定的数列，每赋一个值就后移一位：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        end++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper2(<span class="number">0</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper2</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 遍历左子树并且将根节点返回</span></span><br><span class="line">    TreeNode left = helper2(start, mid);</span><br><span class="line">    <span class="comment">// 遍历当前节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(cur.val);</span><br><span class="line">    root.left = left;</span><br><span class="line">    <span class="comment">// 指针后移，进行下一次赋值</span></span><br><span class="line">    cur = cur.next;</span><br><span class="line">    <span class="comment">// 遍历右子树并将根节点返回</span></span><br><span class="line">    TreeNode right = helper2(mid + <span class="number">1</span>, end);</span><br><span class="line">    root.right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时复：O(n)</p>
<p>空复：O(log(n))，递归压栈消耗。</p>
<h2 id="17-平衡二叉树-110"><a href="#17-平衡二叉树-110" class="headerlink" title="17. 平衡二叉树 [110]"></a>17. 平衡二叉树 [110]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p>
<h3 id="17-1-题目描述"><a href="#17-1-题目描述" class="headerlink" title="17.1. 题目描述"></a>17.1. 题目描述</h3><p><img src="/pictures/image-20200901093602332.png" alt="image-20200901093602332"></p>
<h3 id="17-2-方法一：递归"><a href="#17-2-方法一：递归" class="headerlink" title="17.2. 方法一：递归"></a>17.2. 方法一：递归</h3><p>参考 <a href="https://leetcode.wang/leetcode-110-Balanced-Binary-Tree.html" target="_blank" rel="noopener">这里</a>.</p>
<p>参考平衡二叉树的定义：</p>
<blockquote>
<p>它是一颗空树或它的左右子树的高度差绝对值不超过1，并且左右子树均为平衡二叉树。</p>
</blockquote>
<p>直接按照定义来递归求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> left = getHeight(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = getHeight(root.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时复：O(n^2)，n 为二叉树节点个数。isBalanced 需要遍历二叉树中的所有节点，时复为 O(n)，求高度 getHeight，一般情况下为 O(log n)，对于最坏情况，二叉树形成链式结构，需要 O(n)，此时时间复杂度为 O(n^2)。</p>
<p>空复：O(n)，空间复杂度主要取决于递归调用的层数，递归调用不会超过 n。</p>
<h3 id="17-3-方法二：递归的优化"><a href="#17-3-方法二：递归的优化" class="headerlink" title="17.3. 方法二：递归的优化"></a>17.3. 方法二：递归的优化</h3><p>参考 <a href="https://leetcode.wang/leetcode-110-Balanced-Binary-Tree.html" target="_blank" rel="noopener">这里</a> 的解法二。</p>
<p>在方法一中，可以发现，子树的高度重复算了很多次。在求左子树高度时，使用递归求解它的左右子树高度；在判断左子树是否为平衡二叉树时，又使用递归求解了它的左右子树高度。</p>
<p>方法一的另一个问题是：在 getHeight 方法中，求得左右子树高度时，就可以判断当前是否是平衡二叉树了。</p>
<p>综上，只需要求一次高度，并且在求左右子树高度时，就可以判断当前是否是平衡二叉树。</p>
<p>考虑到 <code>getTreeDepth</code> 函数返回的是<code>int</code>值，同时高度不可能为负数，那么如果求高度过程中我们发现了当前不是平衡二叉树，就返回<code>-1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight2(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = getHeight2(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = getHeight2(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时复：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n) 。</p>
<p>空间复杂度：O(n)，其中 n<em>n</em> 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p>
<h2 id="18-从中序与后序遍历序列构造二叉树-106"><a href="#18-从中序与后序遍历序列构造二叉树-106" class="headerlink" title="18. 从中序与后序遍历序列构造二叉树 [106]"></a>18. 从中序与后序遍历序列构造二叉树 [106]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></p>
<h3 id="18-1-题目描述"><a href="#18-1-题目描述" class="headerlink" title="18.1. 题目描述"></a>18.1. 题目描述</h3><p><img src="/pictures/image-20200902104235073.png" alt="image-20200902104235073"></p>
<h3 id="18-2-代码"><a href="#18-2-代码" class="headerlink" title="18.2. 代码"></a>18.2. 代码</h3><p>递归，注意使用 map 优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = inorder.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(inorder, <span class="number">0</span>, len, postorder, <span class="number">0</span>, len, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> iStart, <span class="keyword">int</span> iEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iStart == iEnd)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(postorder[pEnd - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rootIndex = map.get(postorder[pEnd - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftLen = rootIndex - iStart;</span><br><span class="line">    root.left = helper(inorder, iStart, rootIndex , postorder, pStart, pStart + leftLen, map);</span><br><span class="line">    root.right = helper(inorder, rootIndex + <span class="number">1</span>, iEnd, postorder, pStart + leftLen, pEnd - <span class="number">1</span>, map);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-二叉树展开为链表-114"><a href="#19-二叉树展开为链表-114" class="headerlink" title="19. 二叉树展开为链表 [114]"></a>19. 二叉树展开为链表 [114]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></p>
<h3 id="19-1-题目描述"><a href="#19-1-题目描述" class="headerlink" title="19.1. 题目描述"></a>19.1. 题目描述</h3><p><img src="/pictures/image-20200903095901434.png" alt="image-20200903095901434"></p>
<h3 id="19-2-代码"><a href="#19-2-代码" class="headerlink" title="19.2. 代码"></a>19.2. 代码</h3><p>参考 <a href="https://leetcode.wang/leetcode-114-Flatten-Binary-Tree-to-Linked-List.html" target="_blank" rel="noopener">这里</a> 的解法一。</p>
<p>这道题难点在于：解法一的思路想不到…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找左子树最右边节点</span></span><br><span class="line">            TreeNode pre = root.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将原来的右子树接到左子树的最右边</span></span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            <span class="comment">// 将左子树茶润到右子树的地方</span></span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 考虑下一个节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-填充每个节点的下一个右侧节点指针-116"><a href="#20-填充每个节点的下一个右侧节点指针-116" class="headerlink" title="20. 填充每个节点的下一个右侧节点指针 [116]"></a>20. 填充每个节点的下一个右侧节点指针 [116]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></p>
<h3 id="20-1-题目描述"><a href="#20-1-题目描述" class="headerlink" title="20.1. 题目描述"></a>20.1. 题目描述</h3><p><img src="/pictures/image-20200907095746263.png" alt="image-20200907095746263"></p>
<p><img src="/pictures/image-20200907095838051.png" alt="image-20200907095838051"></p>
<h3 id="20-2-解法一：层次遍历"><a href="#20-2-解法一：层次遍历" class="headerlink" title="20.2. 解法一：层次遍历"></a>20.2. 解法一：层次遍历</h3><p>参考 <a href="https://leetcode.wang/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node.html" target="_blank" rel="noopener">这里</a>.</p>
<p>但是这种解法不符合空间复杂度的要求，层次遍历需要 O(n) 空复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 移除队列第一个元素</span></span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3-解法二：迭代"><a href="#20-3-解法二：迭代" class="headerlink" title="20.3. 解法二：迭代"></a>20.3. 解法二：迭代</h3><p>参考 <a href="https://leetcode.wang/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node.html" target="_blank" rel="noopener">这里</a>.</p>
<p>基本思路：因为只能使用常数级别的空复，所以在遍历当前层时，就把下一层的 next 指针指好。定义三个节点，cur 当前访问节点，pre 当前节点的左侧节点，start 当前层的开始节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    Node pre = root;</span><br><span class="line">    Node cur = <span class="keyword">null</span>;</span><br><span class="line">    Node start = pre;</span><br><span class="line">    <span class="keyword">while</span> (pre.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历到了最右边节点，要将 pre 和 cur 更新到下一层，并且记录 start</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 只需要把 pre 的左孩子的 next 指向右孩子（即更新下一层第一个节点的next）</span></span><br><span class="line">            pre.left.next = pre.right;</span><br><span class="line"></span><br><span class="line">            pre = start.left;</span><br><span class="line">            cur = start.right;</span><br><span class="line">            start = pre;</span><br><span class="line">            <span class="comment">// 将下一层的 next 连起来，同时 pre next 后移</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把 pre 的左孩子的 next 指向右孩子</span></span><br><span class="line">            pre.left.next = pre.right;</span><br><span class="line">            <span class="comment">// 把 pre 的右孩子的 next 指向 cur 的左孩子</span></span><br><span class="line">            pre.right.next = cur.left;</span><br><span class="line"></span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-4-解法三：（推荐）"><a href="#20-4-解法三：（推荐）" class="headerlink" title="20.4. 解法三：（推荐）"></a>20.4. 解法三：（推荐）</h3><p>参考 <a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html" target="_blank" rel="noopener">这里</a> ，这是 [117] 题的解法，同样适用于本题，而且好理解。</p>
<p>基本思路：利用层次遍历的思路，同时使用上一层已经存好的 next 指针，在依次访问当前层元素时，把下一层的 next 指针指好。每一层的开始节点利用 dummy 节点，即 dummy 节点的 next 指针指向每一层的开始节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">        Node tail = dummy;</span><br><span class="line">        <span class="comment">// 遍历当前层</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tail.next = cur.left;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tail.next = cur.right;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新到下一层</span></span><br><span class="line">        cur = dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-填充每个节点的下一个右侧节点指针-II-117"><a href="#21-填充每个节点的下一个右侧节点指针-II-117" class="headerlink" title="21. 填充每个节点的下一个右侧节点指针 II [117]"></a>21. 填充每个节点的下一个右侧节点指针 II [117]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></p>
<h3 id="21-1-题目描述"><a href="#21-1-题目描述" class="headerlink" title="21.1. 题目描述"></a>21.1. 题目描述</h3><p><img src="../pictures/image-20200908091720713.png" alt="image-20200908091720713"></p>
<h3 id="21-2-方法一：层次遍历"><a href="#21-2-方法一：层次遍历" class="headerlink" title="21.2. 方法一：层次遍历"></a>21.2. 方法一：层次遍历</h3><p>同上一题的层次遍历。依旧是空复不符合要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 移除队列第一个元素</span></span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-3-方法二"><a href="#21-3-方法二" class="headerlink" title="21.3. 方法二"></a>21.3. 方法二</h3><p>参考 <a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html" target="_blank" rel="noopener">这里</a> 的解法三。</p>
<p>利用层次遍历的思路，同时使用上一层已经存好的 next 指针，在依次访问当前层元素时，把下一层的 next 指针指好。</p>
<p>每一层的开始节点使用 dummy 节点，dummy 节点的 next 指针指向每一层的开始节点。</p>
<p>这种解法同样适用于上一题 [116]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">        Node tail = dummy;</span><br><span class="line">        <span class="comment">// 遍历当前层</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tail.next = cur.left;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tail.next = cur.right;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新到下一层</span></span><br><span class="line">        cur = dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-参考引用"><a href="#22-参考引用" class="headerlink" title="22. 参考引用"></a>22. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/二叉树" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html</a></li>
<li><a href="https://leetcode.wang/leetcode-102-Binary-Tree-Level-Order-Traversal.html" target="_blank" rel="noopener">https://leetcode.wang/leetcode-102-Binary-Tree-Level-Order-Traversal.html</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/</a></li>
<li><a href="https://leetcode.wang/leetcode-99-Recover-Binary-Search-Tree.html" target="_blank" rel="noopener">https://leetcode.wang/leetcode-99-Recover-Binary-Search-Tree.html</a></li>
<li><a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html" target="_blank" rel="noopener">https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找总结</title>
    <url>/2020/06/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文介绍了二分查找，主要总结了三种二分查找的框架，分别是：基本的二分查找、查找左侧边界、查找右侧边界。同时，解决了部分LeetCode上二分查找相关的题目，这部分会持续更新~</p>
<h2 id="1-什么是二分查找？"><a href="#1-什么是二分查找？" class="headerlink" title="1. 什么是二分查找？"></a>1. 什么是二分查找？</h2><p><a href="https://zh.wikipedia.org/wiki/二分搜尋演算法" target="_blank" rel="noopener">维基定义</a>：在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）[1]、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p>二分查找算法在情况下的复杂度是对数时间，进行O(log n)次比较操作。二分查找算法使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。</p>
<a id="more"></a>

<h2 id="2-基本的二分查找：二分查找-704"><a href="#2-基本的二分查找：二分查找-704" class="headerlink" title="2. 基本的二分查找：二分查找 [704]"></a>2. 基本的二分查找：二分查找 [704]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p>
<h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1. 题目描述"></a>2.1. 题目描述</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h3 id="2-2-题目分析"><a href="#2-2-题目分析" class="headerlink" title="2.2. 题目分析"></a>2.2. 题目分析</h3><p>基本二分查找。</p>
<h3 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3. 代码"></a>2.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-在排序数组中查找元素的第一个和最后一个位置-34"><a href="#3-在排序数组中查找元素的第一个和最后一个位置-34" class="headerlink" title="3. 在排序数组中查找元素的第一个和最后一个位置 [34]"></a>3. 在排序数组中查找元素的第一个和最后一个位置 [34]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1. 题目描述"></a>3.1. 题目描述</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-题目分析"><a href="#3-2-题目分析" class="headerlink" title="3.2. 题目分析"></a>3.2. 题目分析</h3><p>本题求给出有序序列（有重复元素）的target左侧、右侧边界，这需要在基本的二分查找代码上做一些修改。</p>
<h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3. 代码"></a>3.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    res[<span class="number">0</span>] = leftBound(nums, target);</span><br><span class="line">    res[<span class="number">1</span>] = rightBound(nums, target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找左侧边界</span></span><br><span class="line"><span class="comment">     * 用 left 保存找到的左侧边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 不返回，收缩右侧边界，限制左侧边界left的取值范围</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找右侧边界</span></span><br><span class="line"><span class="comment">     * 用 right 保存找到的右侧边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 改变一：收缩左侧边界，限制右侧边界right的取值范围</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变二：检查right的越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二分查找总结"><a href="#4-二分查找总结" class="headerlink" title="4. 二分查找总结"></a>4. 二分查找总结</h2><p>可以发现，二分查找的思路很简单，但是对于 mid 是加一还是减一，while 中是 &lt;= 还是 = 是比较容易混的。上面两题中，我们都把搜索区间定义为左右为闭，这样便于统一记忆。当然，也有代码定义为左闭右开，left 和 right的更新又是另一种套路了，这里不做讨论。下面，基于上面两题的做法，对二分查找三种不同用法做出总结：</p>
<h3 id="4-1-基本的二分查找"><a href="#4-1-基本的二分查找" class="headerlink" title="4.1. 基本的二分查找"></a>4.1. 基本的二分查找</h3><p>基本的二分查找框架，即序列元素不重复，查找 target，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 找到target，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-查找左侧边界"><a href="#4-2-查找左侧边界" class="headerlink" title="4.2. 查找左侧边界"></a>4.2. 查找左侧边界</h3><p>序列元素可能重复，查找 target 左边界，在基本代码的基础上，做了三处修改，代码如下：</p>
<p>代码理解：在查找左边界时，使用 left 存找到的左边界，如果 <code>nums[mid] &lt; target</code> ，left 向后移一位，其他情况下 left 均不动，则最终 left 的取值只能有三种情况：1.第一个等于 target 的元素；2. 大于 target 的元素（因为序列中没有 target）；3. left 越界（因为序列中的所有元素均小于 target）。这也是为什么使用 left 存储左边界并最终返回的原因。right 存能取到的左边界的最大值，不断的收缩 left 的取值范围，直到 <code>left &gt; right</code> 结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 修改一：不返回，收缩右侧边界，限制左侧边界left的取值范围</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改二：检查left的越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left == nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改三：返回left</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-查找右侧边界"><a href="#4-3-查找右侧边界" class="headerlink" title="4.3. 查找右侧边界"></a>4.3. 查找右侧边界</h3><p>序列元素可能重复，查找 target 右边界，在基本代码的基础上，做了三处修改，代码如下：</p>
<p>代码理解：在查找右边界时，用 right 存储找到的右边界。当 <code>nums[mid] &gt; target</code> 时，更新 right 的值，right 前移一位，其他情况下 right 值均不变。因此，最终 while 循环结束后，right 的取值有三种：1. 最后一个等于 target 的元素，即右边界；2. 小于target 的元素（因为序列中没有 target 元素）；3. target 越界（因为序列中所有元素均大于 target）。用 left 存储右边界能取到的最小值，while 中不断更新 left 值，缩小右边界的取值范围，直到 <code>left &gt; right</code> 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 修改一：不返回，收缩左侧边界，限制右侧边界left的取值范围</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改二：检查right的越界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改三：返回right</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用二分查找的题目列表"><a href="#5-使用二分查找的题目列表" class="headerlink" title="5. 使用二分查找的题目列表"></a>5. 使用二分查找的题目列表</h2><p>本文中使用二分查找解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">704</td>
<td align="center"><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">二分查找</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">81</td>
<td align="center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 II</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">74</td>
<td align="center"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="6-搜索插入的位置-35"><a href="#6-搜索插入的位置-35" class="headerlink" title="6. 搜索插入的位置 [35]"></a>6. 搜索插入的位置 [35]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></p>
<h3 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1. 题目描述"></a>6.1. 题目描述</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>


<p>示例 4:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="6-2-题目分析"><a href="#6-2-题目分析" class="headerlink" title="6.2. 题目分析"></a>6.2. 题目分析</h3><p>基本的二分查找框架，返回 left 即题目要求的返回值。</p>
<h3 id="6-3-代码"><a href="#6-3-代码" class="headerlink" title="6.3. 代码"></a>6.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-搜索旋转排序数组-33"><a href="#7-搜索旋转排序数组-33" class="headerlink" title="7. 搜索旋转排序数组 [33]"></a>7. 搜索旋转排序数组 [33]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p>
<h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1. 题目描述"></a>7.1. 题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="7-2-题目分析"><a href="#7-2-题目分析" class="headerlink" title="7.2. 题目分析"></a>7.2. 题目分析</h3><p>本题分析参考：<a href="https://leetcode.wang/leetCode-33-Search-in-Rotated-Sorted-Array.html#解法三" target="_blank" rel="noopener">这里</a>.</p>
<p>可以发现，数组从任意位置分成两个序列后，至少有一半是有序的。</p>
<p>基于这个事实，当 mid 把数组分成两段后，可以先找到哪一段是有序的（比较两端端点即可），然后看 target 在不在这一段，如果在，丢弃另一段；如果不在，丢弃这一段。</p>
<p>为什么必须先找到有序的一端，然后找 target？因为如果想要在一段无序序列中找 target，无法实现。只能先在有序序列中找，以此来缩小搜索范围。</p>
<h3 id="7-3-代码"><a href="#7-3-代码" class="headerlink" title="7.3. 代码"></a>7.3. 代码</h3><p>注意下面对于 <code>nums[left] &lt;= nums[mid]</code> 的分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左半段有序</span></span><br><span class="line">        <span class="comment">// 等于的情况出现在：left = mid 时，即left和mid重合，此时只剩下两个元素</span></span><br><span class="line">        <span class="comment">// 这个等号不能去掉，因为mid求值时取整，两个元素时mid只会和left重合</span></span><br><span class="line">        <span class="comment">// 如果去掉等号，计算right = mid - 1时，right会直接越界</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt;= nums[mid])&#123;</span><br><span class="line">            <span class="comment">// target在左半段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// target在右半段</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 右半段有序</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// target 在右半段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// target 在左半段</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-参考-81-代码"><a href="#7-4-参考-81-代码" class="headerlink" title="7.4. 参考 [81] 代码"></a>7.4. 参考 [81] 代码</h3><p>也可以在 <code>nums[left] &lt;= nums[mid]</code> 时不用考虑那么多，采用和下题一样的思路，更简单。多加一个判断，当<code>nums[left] == nums[mid]</code> 时，直接跳过 left。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左半段有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt; nums[mid])&#123;</span><br><span class="line">            <span class="comment">// target在左半段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target在右半段</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left 和 mid 重合，直接跳过left</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[mid])&#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 右半段有序</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// target 在右半段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target 在左半段</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-搜索旋转排序数组-II-81"><a href="#8-搜索旋转排序数组-II-81" class="headerlink" title="8. 搜索旋转排序数组 II [81]"></a>8. 搜索旋转排序数组 II [81]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></p>
<h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1. 题目描述"></a>8.1. 题目描述</h3><p><img src="/pictures/image-20200815105842768.png" alt="image-20200815105842768"></p>
<h3 id="8-2-题目分析"><a href="#8-2-题目分析" class="headerlink" title="8.2. 题目分析"></a>8.2. 题目分析</h3><p>分析参考：<a href="https://leetcode.wang/leetCode-81-Search-in-Rotated-Sorted-ArrayII.html" target="_blank" rel="noopener">这里</a>.</p>
<p>如果使用 [33] 题的解法一，如果不加修改，直接放到 leetcode 上跑，发现 nums = [ 1, 3, 1, 1, 1 ] ，target = 3，返回了 false，当然是不对的了。原因就出现在了，我们在判断哪段有序的时候，当 nums [ left ] &lt;= nums [ mid ] 是认为左半段有序。而由于这道题出现了重复数字，此时的 nums [ left ] = 1, nums [ mid ] = 1，但此时左半段 [ 1, 3, 1 ] 并不是有序的，所以造成我们的算法错误。</p>
<p>所以 nums[left] == nums[mid] 需要我们单独考虑了。操作也很简单，参考<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/28218/My-8ms-C%2B%2B-solution-(o(logn)-on-average-o(n)-worst-case" target="_blank" rel="noopener">这里</a>，当相等的时候，我们只需要让 left++ 就够了。</p>
<p>改后的代码也适用于 [33] 题。</p>
<h3 id="8-3-代码"><a href="#8-3-代码" class="headerlink" title="8.3. 代码"></a>8.3. 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左半段有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt; nums[mid])&#123;</span><br><span class="line">            <span class="comment">// target在左半段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target在右半段</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 相等，left++</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[mid])&#123;</span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右半段有序</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// target 在右半段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// target 在左半段</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-搜索二维矩阵-74"><a href="#9-搜索二维矩阵-74" class="headerlink" title="9. 搜索二维矩阵 [74]"></a>9. 搜索二维矩阵 [74]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1. 题目描述"></a>9.1. 题目描述</h3><p><img src="/pictures/image-20200822101717491.png" alt="image-20200822101717491"></p>
<h3 id="9-2-代码"><a href="#9-2-代码" class="headerlink" title="9.2. 代码"></a>9.2. 代码</h3><p>有序序列搜索，直接二分。这里需要加一个 mid 下标和矩阵下标的转换即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = m * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = mid / n;</span><br><span class="line">        <span class="keyword">int</span> j = mid % n;</span><br><span class="line">        <span class="keyword">int</span> value = matrix[i][j];</span><br><span class="line">        <span class="keyword">if</span>(target == value)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; value)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-参考引用"><a href="#10-参考引用" class="headerlink" title="10. 参考引用"></a>10. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/二分搜尋演算法" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie</a></li>
<li><a href="https://leetcode.wang/leetCode-81-Search-in-Rotated-Sorted-ArrayII.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-81-Search-in-Rotated-Sorted-ArrayII.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap实现原理及其重要方法</title>
    <url>/2020/04/05/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要介绍了 HashMap 的底层实现结构、存储结构以及JDK1.8中相关的优化。同时，也分析了一些HashMap的重要方法，比如哈希桶索引位置、查询、新增、扩容。另外涉及几个细节性的问题，比如加载因子、HashMap与HashTable的区别等等。</p>
<a id="more"></a>

<h2 id="1-部分源码分析"><a href="#1-部分源码分析" class="headerlink" title="1. 部分源码分析"></a>1. 部分源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//HashMap初始化长度 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;		<span class="comment">//HashMap 最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;		<span class="comment">//默认的加载因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;				<span class="comment">//转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;			<span class="comment">//转换链表的临界值，当链表长度小于此值时，会将红黑树结构转换为链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;			<span class="comment">//最小树容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;				<span class="comment">//用来定位数组索引位置							</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;				<span class="comment">//链表的下一个node</span></span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;	<span class="comment">// Node[] table的初始化长度length(默认值是16)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;			<span class="comment">// HashMap中实际存在的键值对数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;		<span class="comment">// 记录HashMap内部结构发生变化的次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> threshold;				<span class="comment">// HashMap所能容纳的最大数据量的Node(键值对)个数</span></span><br><span class="line">    							<span class="comment">// threshold = length * Load factor </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;		<span class="comment">// 负载因子(默认值是0.75)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Hash 算法，共三步</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">        <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="comment">    // 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class="line"><span class="comment">    static int indexFor(int h, int length) &#123;  </span></span><br><span class="line"><span class="comment">    	//第三步 取模运算</span></span><br><span class="line"><span class="comment">     	return h &amp; (length-1);  </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>



<h2 id="2-HashMap-底层是如何实现的？JDK1-8如何优化？"><a href="#2-HashMap-底层是如何实现的？JDK1-8如何优化？" class="headerlink" title="2. HashMap 底层是如何实现的？JDK1.8如何优化？"></a>2. HashMap 底层是如何实现的？JDK1.8如何优化？</h2><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<img src="/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png" alt="img" style="zoom: 67%;" />

<p>JDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。Node 源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">"julia"</span>,<span class="string">"jiang"</span>);</span><br></pre></td></tr></table></figure>

<p>系统将调用 <code>&quot;julia&quot;</code> 这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（具体见哈希桶数组索引位置分析）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<h2 id="3-什么是加载因子？加载因子为什么是0-75？"><a href="#3-什么是加载因子？加载因子为什么是0-75？" class="headerlink" title="3. 什么是加载因子？加载因子为什么是0.75？"></a>3. 什么是加载因子？加载因子为什么是0.75？</h2><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p>
<p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p>
<p>这其实是出于容量和性能之间平衡的结果：</p>
<ol>
<li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li>
<li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li>
</ol>
<p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p>
<h2 id="4-HashMap源码中有哪些重要方法？"><a href="#4-HashMap源码中有哪些重要方法？" class="headerlink" title="4. HashMap源码中有哪些重要方法？"></a>4. HashMap源码中有哪些重要方法？</h2><h3 id="4-1-确定哈希桶数组索引位置"><a href="#4-1-确定哈希桶数组索引位置" class="headerlink" title="4.1 确定哈希桶数组索引位置"></a>4.1 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<img src="/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png" alt="img" style="zoom:80%;" />

<h3 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2 查询"></a>4.2 查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//非空判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断第一个元素是否是要查询的元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//下一个节点非空判断</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果第一个节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//非树结构，循环节点判断</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;   <span class="comment">//hash相等，并且 key相等，则返回此节点</span></span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p>
<h3 id="4-3-新增"><a href="#4-3-新增" class="headerlink" title="4.3 新增"></a>4.3 新增</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对 key 进行哈希操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//哈希表为空则创建表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//根据 key 的哈希值计算出要插入的数组索引i</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果 tab[i] 为 null，则直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//如果key相等，直接覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果 key 不存在，判断是否为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树直接插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//为链表结构，循环准备插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//下一个元素为空时</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表长度大于 8 时转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//key 已经存在直接覆盖 value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//超过最大容量，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增方法的执行流程如下：</p>
<p><img src="/pictures/58e67eae921e4b431782c07444af824e_r.jpg" alt="preview"></p>
<h3 id="4-4-扩容"><a href="#4-4-扩容" class="headerlink" title="4.4 扩容"></a>4.4 扩容</h3><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">参考博文</a></p>
<h4 id="JDK1-7-的扩容"><a href="#JDK1-7-的扩容" class="headerlink" title="JDK1.7 的扩容"></a>JDK1.7 的扩容</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>  </span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">   Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">   <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">       Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">               e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">               newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">               e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">           &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line"><span class="comment">// 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//第三步 取模运算</span></span><br><span class="line"> 	<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定哈希桶数组索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。下面举个例子说明下扩容过程。</p>
<p>这里我们假设 <code>hashCode()</code> 的哈希算法就是简单的 key % (数组长度)。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。</p>
<p>接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg" alt="preview"></p>
<h4 id="JDK1-8-在扩容方面的优化"><a href="#JDK1-8-在扩容方面的优化" class="headerlink" title="JDK1.8 在扩容方面的优化"></a>JDK1.8 在扩容方面的优化</h4><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg" alt="preview"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png" alt="img"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png" alt="img"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<h4 id="JDK1-8-中扩容源码"><a href="#JDK1-8-中扩容源码" class="headerlink" title="JDK1.8 中扩容源码"></a>JDK1.8 中扩容源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//扩容前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//扩容前数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">//预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//超过最大值就不可以扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容容量为当前容量的两倍，但不能超过MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前数组没有数据，前数组大小为0，新数组容量设置为初始阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//初始阈值为0，则使用默认的初始化容器</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新容量等于0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//开始赋值，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//原数据不为空，将原数据赋值到table中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据容量循环数组，赋值非空元素到新table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是红黑树存储</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">//链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将原索引+oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-HashMap-多线程操作导致死循环问题"><a href="#6-HashMap-多线程操作导致死循环问题" class="headerlink" title="6. HashMap 多线程操作导致死循环问题"></a>6. HashMap 多线程操作导致死循环问题</h2><p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">详细分析</a></p>
<p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<h2 id="7-HashMap-和-HashTable的区别"><a href="#7-HashMap-和-HashTable的区别" class="headerlink" title="7. HashMap 和 HashTable的区别"></a>7. HashMap 和 HashTable的区别</h2><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p>HashMap 中带有初始化容量的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);	 <span class="comment">// 保证HashMap总是使用2的幂作为哈希表大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于 HashMap 的知识点参考 <a href="https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-2Java集合?id=_226-hashmap-和-hashset区别" target="_blank" rel="noopener">这里</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>String的特点以及方法</title>
    <url>/2020/04/04/String%E7%9A%84%E7%89%B9%E7%82%B9%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要从源码出发，介绍了 String 的一些特点和方法。包括了 String 的底层实现，源码中的几个重要方法实现，String 使用 final 修饰的原因，String 与 StringBuilder、StringBuffered 的区别，String 在 JVM 中的存储，intern() 方法，不可变性，+ 的重载以及编译器使用 StringBuilder 的优化。</p>
<a id="more"></a>

<h2 id="1-String-如何实现"><a href="#1-String-如何实现" class="headerlink" title="1. String 如何实现"></a>1. String 如何实现</h2><p>以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. 用于储存字符串的值*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string 缓存字符串的Hash Code*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    .....</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
<h2 id="2-String-源码中的几个重要方法"><a href="#2-String-源码中的几个重要方法" class="headerlink" title="2. String 源码中的几个重要方法"></a>2. String 源码中的几个重要方法</h2><h3 id="2-1-多构造方法"><a href="#2-1-多构造方法" class="headerlink" title="2.1 多构造方法"></a>2.1 多构造方法</h3><p>如下选出源码中 String 比较重要的几个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// char[] 为参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StringBuffer 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StringBuilder 为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-equals-比较两个字符串是否相等"><a href="#2-2-equals-比较两个字符串是否相等" class="headerlink" title="2.2 equals() 比较两个字符串是否相等"></a>2.2 equals() 比较两个字符串是否相等</h3><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Object 的 equals 方法以及与 == de 区别更详细解释请参考</a></p>
<p>Object 的 equals() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 的 equals() 方法重写了 Object 的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时先判断对比的值是否为 String 类型，如果不是直接返回false，如果是继续判断，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对象引用相同，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断对比的值是否为String类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="comment">//把两个字符串转为 char[] 数组对比</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p>
<p><strong>equals() 和 == 的区别：</strong></p>
<ol>
<li>== 对于基本数据类型来说，是比较<strong>值</strong>是否相等的；对于引用类型来说，是用于比较<strong>引用地址</strong>是否相等的</li>
<li>从 Object 的 equals() 方法源码来看，对于 Object 而言，equals() 方法其实就是 ==, 而 String 重写了 equals() 方法，用于比较两个字符串的值是否相等。</li>
</ol>
<h3 id="2-3-compareTo-比较两个字符串"><a href="#2-3-compareTo-比较两个字符串" class="headerlink" title="2.3 compareTo() 比较两个字符串"></a>2.3 compareTo() 比较两个字符串</h3><p>用于两个字符串的字典序比较，返回 int 类型的值，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p>
<p><strong>equals() 和 compareTo() 方法的区别：</strong></p>
<ol>
<li>equals() 可以接收一个Object类型的参数，而compareTo() 只接受String</li>
<li>equals 返回值为 boolean, compareTo 返回 int</li>
</ol>
<h3 id="2-4-其他重要方法"><a href="#2-4-其他重要方法" class="headerlink" title="2.4 其他重要方法"></a>2.4 其他重要方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">indexOf()：查询字符串首次出现的下标位置</span><br><span class="line">lastIndexOf()：查询字符串最后出现的下标位置</span><br><span class="line">contains()：查询字符串中是否包含另一个字符串</span><br><span class="line">toLowerCase()：把字符串全部转换成小写</span><br><span class="line">toUpperCase()：把字符串全部转换成大写</span><br><span class="line">length()：查询字符串的长度</span><br><span class="line">trim()：去掉字符串首尾空格</span><br><span class="line">replace()：替换字符串中的某些字符</span><br><span class="line">split()：把字符串分割并返回字符串数组</span><br><span class="line">join()：把字符串数组转为字符串</span><br></pre></td></tr></table></figure>

<h2 id="3-为什么-String-类型用-final-修饰？"><a href="#3-为什么-String-类型用-final-修饰？" class="headerlink" title="3. 为什么 String 类型用 final 修饰？"></a>3. 为什么 String 类型用 final 修饰？</h2><p>从 String 类的源码来看，String 是被 final 修饰的不可继承类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>那这样设计有什么好处呢？</p>
<p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时，不需要考虑谁会修改它的值；如果是可变的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上有一定的损失。</p>
<p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是<strong>安全</strong>。当你在调用其他方法时，比如在调用一些系统级操作指令之前，可能会有一系列校验，如果是可变的话，可能在你校验之后，它的内部值又被改变了，这样可能引起严重的系统崩溃问题，这是迫使 String 类设计为不可变类的一个重要原因。</p>
<p>总结来说，使用 final 修饰的第一个好处是<strong>安全</strong>，第二个好处是<strong>高效</strong>。我们以 JVM 中的字符串常量池为例，有如下两个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure>

<p>只有字符串是不可变时，我们才能实现字符串常量池，它可以为我们缓存字符串，提高程序运行效率。</p>
<p><img src="../pictures/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200405164821-1586080520904.png" alt="微信截图_20200405164821"></p>
<p>试想如果 String 是可变的，那当 s1 的值修改之后，s2 的值也会跟着改变，这样就和我们预期的结果不符合，因此也就没有办法实现字符串常量池的功能了。</p>
<h2 id="4-String-和-StringBuilder、StringBuffer-的区别"><a href="#4-String-和-StringBuilder、StringBuffer-的区别" class="headerlink" title="4. String 和 StringBuilder、StringBuffer 的区别"></a>4. String 和 StringBuilder、StringBuffer 的区别</h2><h3 id="（1）-可变性"><a href="#（1）-可变性" class="headerlink" title="（1） 可变性"></a>（1） 可变性</h3><p>上文提到，String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<p>但StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，所以这两种对象都是可变的。AbstractStringBuilder 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="（2）线程安全性"><a href="#（2）线程安全性" class="headerlink" title="（2）线程安全性"></a>（2）线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁 synchronized，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer 截取部分源码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StringBuilder 截取部分源码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）性能"><a href="#（3）性能" class="headerlink" title="（3）性能"></a>（3）性能</h3><p>因为 String 类型是不可变的，所以每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 性能更高一些，但却线程不安全的风险，因而我们可以再非并发操作的环境下使用 StringBuilder 操作字符串。</p>
<h3 id="（4）对于三者使用的总结"><a href="#（4）对于三者使用的总结" class="headerlink" title="（4）对于三者使用的总结"></a>（4）对于三者使用的总结</h3><pre><code>- 操作少量的数据: 适用 String
- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</code></pre><h2 id="5-String-在-JVM（Java虚拟机）中是如何存储的？"><a href="#5-String-在-JVM（Java虚拟机）中是如何存储的？" class="headerlink" title="5. String 在 JVM（Java虚拟机）中是如何存储的？"></a>5. String 在 JVM（Java虚拟机）中是如何存储的？</h2><p>String常见的创建方式有两种，直接赋值的方式<code>Strings1 = &quot;Java&quot;;</code>和<code>Strings2 = new String(&quot;Java&quot;);</code>的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量 s1 会先去<strong>字符串常量池</strong>中找字符串“Java”，如果有相同的字符则直接返回<strong>常量句柄</strong>（一个唯一的整数，作为对象的身份id, 区分不同的对象和同类中的不同实例），如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 s2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中，它们在 JVM 中的存储位置如下图所示：</p>
<p><img src="../pictures/image-20200405194407416.png" alt="image-20200405194407416"></p>
<p>代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Strings1 = newString(<span class="string">"Java"</span>);</span><br><span class="line">Strings2 = s1.intern();</span><br><span class="line">Strings3 = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="6-String-的-intern-方法有什么含义"><a href="#6-String-的-intern-方法有什么含义" class="headerlink" title="6. String 的 intern 方法有什么含义?"></a>6. String 的 intern 方法有什么含义?</h2><p>public String <strong>intern</strong>() 返回字符串对象的规范化表示形式，返回值是一个字符串，内容与此字符串相等，但它保证来自字符串池中。</p>
<p>一个初始为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果字符串池中已经包含一个等于此 String 对象的字符串（是否等于由 String 的 equals 方法来确定），则返回池中的字符串；否则将此 String 对象添加到池中，并且返回此 String 对象的引用。所有的字面值字符串和字符串赋值常量表达式都是内部的。</p>
<p>如下例子中，变量 str1 会先去字符串常量池中找字符串 “ab”, 如果有相同的字符串则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 str2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中。</p>
<p>字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如 str3 str4）则不会进入字符串池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1 == str2);           <span class="comment">//false 引用地址不同</span></span><br><span class="line">System.out.println(str1.equals(str2));      <span class="comment">//true 字符串值相同</span></span><br><span class="line">System.out.println(str1 == str2.intern());  <span class="comment">//true</span></span><br><span class="line">String str3 = <span class="string">"a"</span>;</span><br><span class="line">String str4 = <span class="string">"b"</span>;</span><br><span class="line">System.out.println(str3 + str4 == str1);    <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">"a"</span> + <span class="string">"b"</span> == str1);      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>前文中说明了 equals 和 == 的区别，对于 String 而言，== 判断的是引用地址，那么什么时候会出现引用地址相同的情况呢？现在来看，如果给变量赋值的是静态字符串，就会在字符串中找相同字符串，如果有返回引用，这时候就存在相同的引用地址；而 new String 构造的字符串用 == 判断一定是 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str5 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str2 == str5);           <span class="comment">//false</span></span><br><span class="line">String str6 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str1 ==str6);            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="7-String-的不可变"><a href="#7-String-的不可变" class="headerlink" title="7. String 的不可变"></a>7. String 的不可变</h2><p>String 对象是不可变的。从 JDK 文档可以发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象来包含修改后的字符串内容，而最初的 String 对象纹丝未动。</p>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String q = <span class="string">"howdy"</span>;</span><br><span class="line">    System.out.println(q); <span class="comment">// howdy </span></span><br><span class="line">    String qq = upcase(q);</span><br><span class="line">    System.out.println(qq); <span class="comment">// HOWDY </span></span><br><span class="line">    System.out.println(q); <span class="comment">// howdy </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当把 <code>q</code>传递给<code>upcase()</code>方法时，实际传递的是引用的一个拷贝。每当 String 对象作为方法的参数时，都会复制一份引用，而该引用所指的对象一直在物理位置上没有任何变化。</p>
<p>回到 upcase() 的定义，传入其中的引用有了名字 s, 只有 upcase() 方法运行时局部引用 s 才存在。一旦 upcase() 结束，s 就消失了。其返回值也就指向了一个新的对象，而 q 仍然在原来的位置。</p>
<h2 id="8-的重载与-StringBuilder"><a href="#8-的重载与-StringBuilder" class="headerlink" title="8. + 的重载与 StringBuilder"></a>8. + 的重载与 StringBuilder</h2><p>String 对象是不可变的，你可以给一个 String 对象添加任意多的别名，因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，这样也就不会影响到其他引用。</p>
<p>不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子：操作符 + 可以连接 String。当使用 + 操作符时，编译器会做一定的优化，例如在下面的代码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String mango = <span class="string">"mango"</span>; </span><br><span class="line">String s = <span class="string">"abc"</span> + mango + <span class="string">"def"</span> + <span class="number">47</span>;</span><br></pre></td></tr></table></figure>

<p>编译器会自动引入<code>java.lang.StringBuilder</code>类（虽然源代码中并没有使用 StringBuilder 类，但因为其高效，编译器会使用它），先创建一个 StringBuilder 对象，对每个字符串调用一次 append 方法，共4次，最后调用 toString() 方法，存为 s。</p>
<p>现在你可能觉得可以随意使用 String 对象，反正编译器会为你做性能优化。在这之前让我们深入看看编译器会为我们优化到什么程度。下面例子中采用两种方式生成 String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitherStringBuilder</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">implicit</span><span class="params">(String[] fields)</span> </span>&#123; </span><br><span class="line">        String result = <span class="string">""</span>; </span><br><span class="line">        <span class="keyword">for</span>(String field : fields) &#123; </span><br><span class="line">            result += field;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">explicit</span><span class="params">(String[] fields)</span> </span>&#123; </span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line">        <span class="keyword">for</span>(String field : fields) &#123; </span><br><span class="line">            result.append(field); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方式中，StringBuilder 是在循环体内部创建的，这意味着每进行一次循环，就会创建一个 StringBuilder 对象。第二种显示定义 StringBuilder 只生成一个 StringBuilder 对象。因此如果使用循环，且可能存在性能问题，那么最好自己创建一个 StringBuilder 对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
