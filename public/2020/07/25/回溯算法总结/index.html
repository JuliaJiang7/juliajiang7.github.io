<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.juliajiang.top","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文主要介绍了回溯法的定义、回溯法的代码框架，以及回溯法的典型问题全排列问题、N皇后问题等。另外，还介绍了LeetCode中使用回溯法的部分题目，这部分内容会持续更新。 1. 什么是回溯法？维基定义 : （英语：backtracking）是暴力搜索法中的一种。 对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯算法总结">
<meta property="og:url" content="https://www.juliajiang.top/2020/07/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Julia Jiang&#39;s Blog">
<meta property="og:description" content="本文主要介绍了回溯法的定义、回溯法的代码框架，以及回溯法的典型问题全排列问题、N皇后问题等。另外，还介绍了LeetCode中使用回溯法的部分题目，这部分内容会持续更新。 1. 什么是回溯法？维基定义 : （英语：backtracking）是暴力搜索法中的一种。 对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.juliajiang.top/pictures/1.jpg">
<meta property="og:image" content="https://www.juliajiang.top/pictures/2.jpg">
<meta property="og:image" content="https://www.juliajiang.top/pictures/3.jpg">
<meta property="og:image" content="https://www.juliajiang.top/pictures/8-queens.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/%E5%85%A8%E6%8E%92%E5%88%972.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/image-20200725154024914.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/image-20200824094845802.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/image-20200824101740024.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/image-20200827104857215.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/image-20200828102111964.png">
<meta property="og:image" content="https://www.juliajiang.top/pictures/image-20200903093332125.png">
<meta property="article:published_time" content="2020-07-25T00:55:05.000Z">
<meta property="article:modified_time" content="2020-09-03T01:38:03.799Z">
<meta property="article:author" content="Julia Jiang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="回溯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.juliajiang.top/pictures/1.jpg">

<link rel="canonical" href="https://www.juliajiang.top/2020/07/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>回溯算法总结 | Julia Jiang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Julia Jiang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Java, Algorithm, NLP</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.juliajiang.top/2020/07/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="Julia Jiang">
      <meta itemprop="description" content="If a thing is worth doing, it's worth doing well">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Julia Jiang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          回溯算法总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-25 08:55:05" itemprop="dateCreated datePublished" datetime="2020-07-25T08:55:05+08:00">2020-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 09:38:03" itemprop="dateModified" datetime="2020-09-03T09:38:03+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>22 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要介绍了回溯法的定义、回溯法的代码框架，以及回溯法的典型问题全排列问题、N皇后问题等。另外，还介绍了LeetCode中使用回溯法的部分题目，这部分内容会持续更新。</p>
<h2 id="1-什么是回溯法？"><a href="#1-什么是回溯法？" class="headerlink" title="1. 什么是回溯法？"></a>1. 什么是回溯法？</h2><p><strong><a href="https://zh.wikipedia.org/wiki/回溯法" target="_blank" rel="noopener">维基定义</a></strong> : （英语：backtracking）是<a href="https://zh.wikipedia.org/wiki/暴力搜尋法" target="_blank" rel="noopener">暴力搜索法</a>中的一种。</p>
<p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，<strong><a href="https://zh.wikipedia.org/wiki/八皇后问题" target="_blank" rel="noopener">八皇后问题</a></strong>展示了回溯法的用例。</p>
<a id="more"></a>

<p>回溯法采用<a href="https://zh.wikipedia.org/wiki/试错" target="_blank" rel="noopener">试错</a>的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<p>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。而回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。</p>
<h2 id="2-回溯法框架"><a href="#2-回溯法框架" class="headerlink" title="2. 回溯法框架"></a>2. 回溯法框架</h2><p>上文主要是 Wikipedia 对于回溯法的介绍，这一节，将参考 <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">这里</a> 给出一个回溯算法的框架。</p>
<p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p>
<ol>
<li>路径：也就是已经做出的选择</li>
<li>选择列表：也就是你当前可以做的选择</li>
<li>结束条件：也就是到达决策树底层，无法再做选择的条件</li>
</ol>
<p>如果现在不理解这三个词语没关系，下一节我们将以全排列问题为例，进行详细介绍。下面给出回溯法的框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</strong></p>
<h2 id="3-以全排列问题（无重复数字）为例-46"><a href="#3-以全排列问题（无重复数字）为例-46" class="headerlink" title="3. 以全排列问题（无重复数字）为例 [46]"></a>3. 以全排列问题（无重复数字）为例 [46]</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-问题分析"><a href="#3-2-问题分析" class="headerlink" title="3.2 问题分析"></a>3.2 问题分析</h3><p>我们知道，对于 n 个不重复的数，全排列共有 n! 个。如果使用穷举法，我们一般会：</p>
<p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p>
<p>其实这就是回溯算法，可以转化为下面的回溯树：</p>
<img src="/pictures/1.jpg" alt="img" style="zoom: 33%;" />

<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p>
<p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p>
<img src="/pictures/2.jpg" alt="img" style="zoom:33%;" />

<p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p>
<p><strong>现在可以解答开头的几个名词：</strong><code>[2]</code> <strong>就是「路径」，记录你已经做过的选择；<code>[1,3]</code>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p>
<p>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p>
<img src="/pictures/3.jpg" alt="img" style="zoom:33%;" />

<p><strong>框架中定义的 <code>backtrace</code>  函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p>
<p>在回溯法中，<strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。因此，框架中的核心代码详细化如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录路径（已做出的选择）</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 满足结束条件（到达决策树底层，无法再做选择的条件）</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length == track.size())&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span>(track.contains(num))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(num);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们并没有显示记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表。</p>
<p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p>
<p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p>
<p>明白了全排列问题，就可以直接套回溯算法框架了。</p>
<h3 id="3-4-另一种方法"><a href="#3-4-另一种方法" class="headerlink" title="3.4 另一种方法"></a>3.4 另一种方法</h3><p>上文中没有显示记录「选择列表」，通过用路径的 <code>contains</code> 方法来判断是否选择。这里我们 <strong>“以空间换时间”</strong> 的思想，使用一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)  的时间复杂度判断这个数是否被选择过。（参考 <a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">这里</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute2(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 标记数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    backtrace2(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> used 标记数组，used[i]=true时，表示已被选择</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrace2</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == len)&#123;</span><br><span class="line">        res2.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        backtrace2(nums, track, used);</span><br><span class="line"></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-N皇后问题-51"><a href="#4-N皇后问题-51" class="headerlink" title="4. N皇后问题 [51]"></a>4. N皇后问题 [51]</h2><h3 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></p>
<p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p>
<p><img src="/pictures/8-queens.png" alt="img"></p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  // 解法 1</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // 解法 2</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<h3 id="4-2-问题分析"><a href="#4-2-问题分析" class="headerlink" title="4.2 问题分析"></a>4.2 问题分析</h3><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p>
<h3 id="4-3-代码"><a href="#4-3-代码" class="headerlink" title="4.3 代码"></a>4.3 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化棋盘 board 为二维字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : board)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Arrays.fill(chars, <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径：board中小于row的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">     * 可选择列表: 第row行的所有列都是放置 Q 的选择</span></span><br><span class="line"><span class="comment">     * 结束条件: row超过board的最后一行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前放置第几行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.length) &#123;</span><br><span class="line">        res.add(charToString(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = board[row].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">//排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">//进入下一层决策树</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以在 board[row][col] 放置皇后</span></span><br><span class="line"><span class="comment">     * 不需要检查 这一行，因为每一行只放一个皇后就到下一行</span></span><br><span class="line"><span class="comment">     * 不需要检查 左下、右下斜线，因为下面还没放元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = board.length;</span><br><span class="line">    <span class="comment">//检查这一列是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : board)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上斜线上是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; rows; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上斜线上是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">charToString</span><span class="params">(<span class="keyword">char</span>[][] array)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : array) &#123;</span><br><span class="line">        result.add(String.valueOf(chars));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝。</p>
<h2 id="5-回溯法总结"><a href="#5-回溯法总结" class="headerlink" title="5. 回溯法总结"></a>5. 回溯法总结</h2><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>写</strong> <strong><code>backtrack</code></strong> <strong>函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p>
<p>下面几节记录了一些平时遇到的，可以使用回溯解决的经典例题，会持续更新~</p>
<h2 id="6-使用回溯法的题目列表"><a href="#6-使用回溯法的题目列表" class="headerlink" title="6. 使用回溯法的题目列表"></a>6. 使用回溯法的题目列表</h2><p>本文中使用回溯法解决的 LeetCode 题目列表如下，持续更新中~</p>
<table>
<thead>
<tr>
<th align="center">#</th>
<th align="center">Title</th>
<th align="center">Remark</th>
</tr>
</thead>
<tbody><tr>
<td align="center">46</td>
<td align="center"><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center"><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">70</td>
<td align="center"><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">79</td>
<td align="center"><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">78</td>
<td align="center"><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></td>
<td align="center">Medium</td>
</tr>
<tr>
<td align="center">90</td>
<td align="center"><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">子集 II</a></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">93</td>
<td align="center"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">97</td>
<td align="center"><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">交错字符串</a></td>
<td align="center">Hard</td>
</tr>
<tr>
<td align="center">113</td>
<td align="center"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="7-例题：全排列问题（有重复数字）-47"><a href="#7-例题：全排列问题（有重复数字）-47" class="headerlink" title="7. 例题：全排列问题（有重复数字）[47]"></a>7. 例题：全排列问题（有重复数字）[47]</h2><h3 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="7-2-题目分析"><a href="#7-2-题目分析" class="headerlink" title="7.2 题目分析"></a>7.2 题目分析</h3><p>这道题与上面 46 题不同，给出的序列是包含重复数字的，所以，46题的第一种方法使用track的contain来判断是否选择在这里不使用。而第二种方法，标记数组是可行的，但直接使用 used 数组判断，最终得到的全排列结果可能会有重复，如下图所示：（图片来自：<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">这里</a>）</p>
<img src="/pictures/全排列2.png" alt="全排列2" style="zoom: 33%;" />

<p>如上所示，绿色框中的序列都是重复的，不属于结果集。为什么会出现这种情况呢？</p>
<p>观察发现，在决策树中，同一父节点下的子节点中，选中两个相同的数字时，必然出现重复的全排列结果。那么如何避免这种情况呢？</p>
<p>对给出的序列进行排序，这样相同的数字都会放在一起。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">	做选择</span><br><span class="line">	backtrack(路径, 选择列表)</span><br><span class="line">	撤销选择</span><br></pre></td></tr></table></figure>

<p>在框架的核心代码中，撤销选择处撤销的数字，就是下一个遍历节点的左侧兄弟节点，保存这个数组为 pre，如下图所示，当遍历到nums[i] 处时，如果 pre == nums[i]，则说明需要剪枝。</p>
<img src="/pictures/image-20200725154024914.png" alt="image-20200725154024914" style="zoom:67%;" />

<h3 id="7-3-代码"><a href="#7-3-代码" class="headerlink" title="7.3 代码"></a>7.3 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序；相同的数字放在一起，重复的剪枝方便</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">    backtrack(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// 满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(track.size() == len)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为数组中没有的数</span></span><br><span class="line">    <span class="keyword">int</span> pre = nums[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] || pre == nums[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 记录刚被撤销的数字</span></span><br><span class="line">        pre = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h3><p>还是按照回溯法的框架来解决，但是剪枝的部分一开始想不到。</p>
<h2 id="8-例题：组合总和-39"><a href="#8-例题：组合总和-39" class="headerlink" title="8. 例题：组合总和 [39]"></a>8. 例题：组合总和 [39]</h2><h3 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= candidates.length &lt;= 30</span><br><span class="line">1 &lt;= candidates[i] &lt;= 200</span><br><span class="line">candidate 中的每个元素都是独一无二的。</span><br><span class="line">1 &lt;= target &lt;= 500</span><br></pre></td></tr></table></figure>

<h3 id="8-2-题目分析"><a href="#8-2-题目分析" class="headerlink" title="8.2 题目分析"></a>8.2 题目分析</h3><p>这道题依旧可以使用回溯法进行暴力穷举。有几点需要注意：</p>
<ol>
<li>选择列表candidates可以重复选择，即选择列表自始至终都不变，是candidates</li>
<li>candidate 中的每个元素都是独一无二的</li>
<li>解集不能包含重复的组合，即最终的结果不能重复</li>
</ol>
<p>鉴于最终结果不可以重复，我们可以剪掉会重复的枝，即将选择列表排序，路径的下一个节点选择从当前节点开始遍历（由于candidate 中的每个元素不重复，所以start从 i 开始就可以解决结果重复的问题）。另外，这道题改用减法更好理解。</p>
<h3 id="8-3-代码"><a href="#8-3-代码" class="headerlink" title="8.3 代码"></a>8.3 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化添加的代码1：先对数组排序，可以提前终止判断</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, track, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> residue 剩余</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 下一次从 start 开始判断是否添加到路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> residue, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(residue == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 从 start 开始，剪掉小于 candidates[i] 的枝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span>(residue - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(candidates[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        <span class="comment">// residue-candidates[i] 为下一轮剩余</span></span><br><span class="line">        <span class="comment">// i 为下一轮的 start值，原因：为了避免重复，选择的数字只能大于等于candidates[i]</span></span><br><span class="line">        backtrack(candidates, track, residue-candidates[i], i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-例题：组合总和-2-40"><a href="#9-例题：组合总和-2-40" class="headerlink" title="9. 例题：组合总和 2 [40]"></a>9. 例题：组合总和 2 [40]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></p>
<h3 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="9-2-题目分析"><a href="#9-2-题目分析" class="headerlink" title="9.2 题目分析"></a>9.2 题目分析</h3><p>本题与上一题的区别有两个：</p>
<ol>
<li>candidates 中的每个数字在每个组合中只能使用一次</li>
<li>candidates 中有重复数字</li>
</ol>
<p>思路如下：</p>
<ol>
<li>要保证每个数字用一次，先对序列排序， 且 start 从 i+1 开始</li>
<li>要保证结果不重复，第一步是不够的，因为 candidates 中有重复数字。这个问题和上文的 <strong>全排列问题（有重复数字）</strong> 类似，使用 pre 标记刚撤销的数字，与当前值比较后进行剪枝。</li>
</ol>
<h3 id="9-3-代码"><a href="#9-3-代码" class="headerlink" title="9.3 代码"></a>9.3 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, track, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 记录路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> residue 剩余</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 下一次从 start 开始判断是否添加到路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> residue, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(residue == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pre = candidates[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="comment">// candidates排序之后，如果第一个不满足，后面的肯定不满足，直接break</span></span><br><span class="line">        <span class="keyword">if</span>(residue - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前值和上一个撤销的值相同，会重复，continue</span></span><br><span class="line">        <span class="keyword">if</span>(candidates[i] == pre)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        track.add(candidates[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        <span class="comment">// start 从 i+1 开始</span></span><br><span class="line">        backtrack(candidates, track, residue-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        pre = candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-例题：组合-70"><a href="#10-例题：组合-70" class="headerlink" title="10. 例题：组合 [70]"></a>10. 例题：组合 [70]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></p>
<h3 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h3><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="10-2-题目分析"><a href="#10-2-题目分析" class="headerlink" title="10.2 题目分析"></a>10.2 题目分析</h3><p>这种数字组合的题目是典型的回溯法问题，先选一个数字，进入递归继续选，如果满足条件则加入结果中，然后回溯到上一步，继续递归。</p>
<h3 id="10-3-代码"><a href="#10-3-代码" class="headerlink" title="10.3 代码"></a>10.3 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解法一：回溯法</span></span><br><span class="line"><span class="comment">     * 回溯的常规解法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(track, n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果满足条件</span></span><br><span class="line">    <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为避免重复，i 从 start 开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(i);</span><br><span class="line">        backtrack(track, n, k, i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-优化"><a href="#10-4-优化" class="headerlink" title="10.4 优化"></a>10.4 优化</h3><p>参考 <a href="https://leetcode.wang/leetCode-77-Combinations.html" target="_blank" rel="noopener">这里</a> 对上面代码进行优化。将 for 循环改为 <code>for(int i = start; i &lt;= (n-k)+1 + track.size(); i++)</code>, 其中，<code>(n-k)+1</code>  表示要在 n 中找到 k 个数字组合，start 必须从 (n-k)+1 处开始；<code>(n-k)+1 + track.size()</code>  表示当前 i 取到的最大数字。原因如下：</p>
<p>我们发现，如果 n = 5, k = 3,  那么 start 最大取到3，因为如果 start = 4，最终结果只能得到到 (4,5), 结果的个数必定小于k，不满足条件。</p>
<p>如果 n = 5, k = 3, start = 1, 当 i = 2, track.size() = 1时，i 最大取到 (5-3)+1 + 1 = 4，否则，如果 i 取到 5，结果只能为 (1,5), 数字个数肯定不满足条件。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack2</span><span class="params">(LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (n-k)+1 表示要在n中找到k个数字组合，start必须从(n-k)+1处开始</span></span><br><span class="line">    <span class="comment">// 即如果n=5,k=3, 那么start最大取到3，因为如果当start=4时，组合中数字的个数不足</span></span><br><span class="line">    <span class="comment">// (n-k)+1 + track.size() 表示当前i取到的最大数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= (n-k)+<span class="number">1</span> + track.size(); i++)&#123;</span><br><span class="line">        track.add(i);</span><br><span class="line">        backtrack(track, n, k, i+<span class="number">1</span>);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然只改了一句代码，但速度快了很多。</p>
<h2 id="11-单词搜索-79"><a href="#11-单词搜索-79" class="headerlink" title="11. 单词搜索 [79]"></a>11. 单词搜索 [79]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></p>
<h3 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1. 题目描述"></a>11.1. 题目描述</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">"ABCCED"</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 word = <span class="string">"SEE"</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 word = <span class="string">"ABCB"</span>, 返回 <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>board 和 word 中只包含大写和小写英文字母。</li>
<li>1 &lt;= board.length &lt;= 200</li>
<li>1 &lt;= board[i].length &lt;= 200</li>
<li>1 &lt;= word.length &lt;= 10^3</li>
</ul>
<h3 id="11-2-题目分析"><a href="#11-2-题目分析" class="headerlink" title="11.2. 题目分析"></a>11.2. 题目分析</h3><p>基本思路：找第一个匹配的字符，然后在其上下左右的四个字符中找与第二个字符匹配的字符，找到后，以次类推。上下左右字符需要首先判断是否越界、是否已经访问过。</p>
<p>但是，在做题的过程中，完全忽略了这是标准的回溯思想，参考之前的博客：<a href="https://juliajiang7.github.io/2020/07/25/回溯算法总结/#more" target="_blank" rel="noopener">回溯算法</a>.</p>
<p>回溯法采用试错的思想，尝试分步解决一个问题。在本题中，匹配下一个字符时就有上下左右四种选择。当它发现现有的分布答辩不能得到有效的正确答案时，将取消上一步或者上几步的计算，再通过其他分步尝试得到问题答案。</p>
<p>在做题中有一个很大问题：忽略了回溯，即选择一条路走完发现不能匹配时，就返回了false，没有取消这一步操作。这一点要注意。</p>
<p>另外，这一题使用框架不太好写，还是基于回溯思想（DFS），按照正常的思路来写。</p>
<h3 id="11-3-代码"><a href="#11-3-代码" class="headerlink" title="11.3. 代码"></a>11.3. 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="comment">// 找到第一个字母</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 判断从 board[i][j] 出发，后面能否全部匹配</span></span><br><span class="line">                <span class="keyword">if</span>(isValid(i, j, word, <span class="number">0</span>, board, visited))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 board[i][j] 匹配 word[k] 时，后面是否可以全部匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> visited 当前已访问的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> k, <span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(k == word.length() - <span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="comment">// 上面</span></span><br><span class="line">    <span class="keyword">boolean</span> left = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i - <span class="number">1</span>][j] &amp;&amp; board[i - <span class="number">1</span>][j] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i - <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        left = isValid(i - <span class="number">1</span>, j, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left)&#123;<span class="keyword">return</span> left;&#125;</span><br><span class="line">    <span class="comment">// 下面</span></span><br><span class="line">    <span class="keyword">boolean</span> right = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; row &amp;&amp; !visited[i + <span class="number">1</span>][j] &amp;&amp; board[i + <span class="number">1</span>][j] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i + <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        right = isValid(i + <span class="number">1</span>, j, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right)&#123;<span class="keyword">return</span> right;&#125;</span><br><span class="line">    <span class="comment">// 左边</span></span><br><span class="line">    <span class="keyword">boolean</span> up = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[i][j - <span class="number">1</span>] &amp;&amp; board[i][j - <span class="number">1</span>] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i][j - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        up = isValid(i, j - <span class="number">1</span>, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(up)&#123;<span class="keyword">return</span> up;&#125;</span><br><span class="line">    <span class="comment">// 右边</span></span><br><span class="line">    <span class="keyword">boolean</span> down = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; col &amp;&amp; !visited[i][j + <span class="number">1</span>] &amp;&amp; board[i][j + <span class="number">1</span>] == word.charAt(k + <span class="number">1</span>))&#123;</span><br><span class="line">        visited[i][j + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        down = isValid(i, j + <span class="number">1</span>, word, k + <span class="number">1</span>, board, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(down)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="comment">// 如果上下左右都没有匹配，则取消这一步，回溯</span></span><br><span class="line">    visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-子集-78"><a href="#12-子集-78" class="headerlink" title="12. 子集 [78]"></a>12. 子集 [78]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p>
<h3 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1. 题目描述"></a>12.1. 题目描述</h3><p><img src="/pictures/image-20200824094845802.png" alt="image-20200824094845802"></p>
<h3 id="12-1-方法一：迭代"><a href="#12-1-方法一：迭代" class="headerlink" title="12.1. 方法一：迭代"></a>12.1. 方法一：迭代</h3><p>利用数学归纳的思想：假设现在知道了规模更小的子问题，如何推导出当前问题的结果呢？即知道了 [1,2] 的子集，如何求 [1,2,3] 的子集。</p>
<p>可以发现，[1,2,3] 的子集包括两部分：第一部分是已知的 [1,2] 的子集；另一部分是给每一个 [1,2] 子集加上 3。发现这个规律后，即可写出下面的迭代代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = res.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="comment">// 注意：这里需要 new 一个对象，不可以直接赋值</span></span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> LinkedList&lt;&gt;(res.get(i));</span><br><span class="line">            cur.add(num);</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：迭代次数是 N，每次迭代都遍历 res，res 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。所以，总的时间复杂度是 O(N * 2 ^ N)。</p>
<p>空间复杂度：如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p>
<h3 id="12-2-方法二：回溯算法"><a href="#12-2-方法二：回溯算法" class="headerlink" title="12.2. 方法二：回溯算法"></a>12.2. 方法二：回溯算法</h3><p>参考 <a href="https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA" target="_blank" rel="noopener">这里</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        backtrack(nums, track, start + <span class="number">1</span>);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-子集-II-90"><a href="#13-子集-II-90" class="headerlink" title="13. 子集 II [90]"></a>13. 子集 II [90]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></p>
<h3 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1. 题目描述"></a>13.1. 题目描述</h3><p><img src="/pictures/image-20200824101740024.png" alt="image-20200824101740024"></p>
<h3 id="13-2-代码"><a href="#13-2-代码" class="headerlink" title="13.2. 代码"></a>13.2. 代码</h3><p>有了上一题的基础，回溯法稍作修改即可。</p>
<p>为了方便的剪枝，要对序列进行排序，排序之后所有相同的数字都会放在一起。为了避免结果中出现相同的子集，兄弟节点中不能出现相同的数字，即在 <code>track.add</code> 之前，需要先判断，是否和已经加入的兄弟节点值相同（如果是第一个加入的子节点，不需要判断）。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(nums, track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == start || nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            backtrack(nums, track, i + <span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-复原IP地址-93"><a href="#14-复原IP地址-93" class="headerlink" title="14. 复原IP地址 [93]"></a>14. 复原IP地址 [93]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></p>
<h3 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1. 题目描述"></a>14.1. 题目描述</h3><p><img src="/pictures/image-20200827104857215.png" alt="image-20200827104857215"></p>
<h3 id="14-2-解法一：暴力破解（迭代）"><a href="#14-2-解法一：暴力破解（迭代）" class="headerlink" title="14.2. 解法一：暴力破解（迭代）"></a>14.2. 解法一：暴力破解（迭代）</h3><p>参考 <a href="https://leetcode.wang/leetCode-93-Restore-IP-Addresses.html" target="_blank" rel="noopener">这里</a>.</p>
<p>要求划分为四部分，我们直接利用三个指针将字符串强行分为4部分，遍历所有的划分，然后选取合法的解。这种解法没有超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">// i &lt; 4 保证第一部分不超过3位数</span></span><br><span class="line">    <span class="comment">// i &lt; len - 2 保证剩余的字符串还能分成3部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + <span class="number">4</span> &amp;&amp; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; j + <span class="number">4</span> &amp;&amp; k &lt; len; k++) &#123;</span><br><span class="line">                <span class="comment">// 保存四部分字符串</span></span><br><span class="line">                String s1 = s.substring(<span class="number">0</span>, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, len);</span><br><span class="line">                <span class="comment">// 判断是否合法</span></span><br><span class="line">                <span class="keyword">if</span> (isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4)) &#123;</span><br><span class="line">                    res.add(s1 + <span class="string">"."</span> + s2 + <span class="string">"."</span> + s3 + <span class="string">"."</span> + s4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &gt; <span class="number">3</span> || s.length() == <span class="number">0</span> || (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>) || Integer.parseInt(s) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：如果不考虑我们调用的内部函数，Integer.parseInt，s.substring，那么就是 O（1）。因为每一层循环最多遍历 4 次。考虑的话每次调用的时间复杂度是 O（n），常数次调用，所以是 O（n）。</p>
<p>空间复杂度：O（1）。</p>
<h3 id="14-3-解法二：回溯"><a href="#14-3-解法二：回溯" class="headerlink" title="14.3. 解法二：回溯"></a>14.3. 解法二：回溯</h3><p>字符串划分问题，需要划分为4部分。直接使用回溯的思想，第一部分可能是 1 位数，然后进入递归；也可能是2位数，然后进入递归；也可能是三位数，然后进入递归。即每一次循环有三种选择。</p>
<p>本题虽然使用了回溯的思想，但前面总结的框架不能直接使用，下面代码是它的变形，而且本题的难点在于需要考虑的情况比较多，剪枝条件也比较多。具体剪枝的分析参考 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">这里</a> .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(s, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 字符串开始部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 已经划分部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res   保存所有的解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 当前已经加入了几部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, <span class="keyword">int</span> start, StringBuilder track, List&lt;String&gt; res, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果剩余长度大于剩下部分都取3位数的长度，剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() - start &gt; <span class="number">3</span> * (<span class="number">4</span> - count)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前刚好到达末尾</span></span><br><span class="line">    <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">        <span class="comment">// 当前刚好是4部分，将结果加入，否则剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">            res.add(track.substring(<span class="number">0</span>, track.length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前到达末尾，但不是4部分，剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前超过末尾，剪枝</span></span><br><span class="line">    <span class="comment">// 当前未到达末尾，但有4部分，剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; s.length() || count == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存当前的解</span></span><br><span class="line">    StringBuilder before = <span class="keyword">new</span> StringBuilder(track);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择：加入一位数</span></span><br><span class="line">    track.append(s.charAt(start) + <span class="string">""</span> + <span class="string">'.'</span>);</span><br><span class="line">    backtrack(s, start + <span class="number">1</span>, track, res, count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开头是0，直接结束，即选择2或3位数之前可进行剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做出选择：加入2位数</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 撤销选择：恢复为之前的解</span></span><br><span class="line">        track = <span class="keyword">new</span> StringBuilder(before);</span><br><span class="line">        track.append(s.substring(start, start + <span class="number">2</span>) + <span class="string">""</span> + <span class="string">'.'</span>);</span><br><span class="line">        backtrack(s, start + <span class="number">2</span>, track, res, count + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做出选择：加入3位数</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">2</span> &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 撤销选择：恢复为之前的解</span></span><br><span class="line">        track = <span class="keyword">new</span> StringBuilder(before);</span><br><span class="line">        <span class="comment">// 当选择3位数时，要判断数字大小</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(s.substring(start, start + <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= num &amp;&amp; num &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">            track.append(s.substring(start, start + <span class="number">3</span>) + <span class="string">""</span> + <span class="string">'.'</span>);</span><br><span class="line">            backtrack(s, start + <span class="number">3</span>, track, res, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-交错字符串-97"><a href="#15-交错字符串-97" class="headerlink" title="15. 交错字符串 [97]"></a>15. 交错字符串 [97]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></p>
<h3 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1. 题目描述"></a>15.1. 题目描述</h3><p><img src="/pictures/image-20200828102111964.png" alt="image-20200828102111964"></p>
<h3 id="15-2-方法一：回溯法"><a href="#15-2-方法一：回溯法" class="headerlink" title="15.2. 方法一：回溯法"></a>15.2. 方法一：回溯法</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>感觉要用回溯解决，但是不知道怎么回溯，如何递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backtrack(s1, s2, s3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(String s1, String s2, String s3, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i，j,k 全部到达末尾就返回true</span></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length() &amp;&amp; j == s2.length() &amp;&amp; k == s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i 到达末尾，直接移动 j 和 k 不停比较</span></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.charAt(j) != s3.charAt(k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j 到达末尾，直接移动 i 和 k 不停比较</span></span><br><span class="line">    <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s3.charAt(k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 i 和 k 指向的字符是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(i) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="comment">// 后移 i 和 k 继续判断，如果成功直接返回true</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack(s1, s2, s3, i + <span class="number">1</span>, j, k + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动 i 和 k 失败，尝试移动 j 和 k</span></span><br><span class="line">    <span class="keyword">if</span> (s2.charAt(j) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrack(s1, s2, s3, i, j + <span class="number">1</span>, k + <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动 i 和 j 都失败，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3-方法二：回溯法的优化（备忘录）"><a href="#15-3-方法二：回溯法的优化（备忘录）" class="headerlink" title="15.3. 方法二：回溯法的优化（备忘录）"></a>15.3. 方法二：回溯法的优化（备忘录）</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>由于递归的分支，所以会造成很多重复情况的判断，所以我们用 memoization 技术，把求出的结果用 hashmap 保存起来，第二次过来的时候直接返回结果以免再次进入递归。</p>
<p>hashmap key 的话用字符串 i + “@” + j ，之所以中间加 “@”，是为了防止 i = 1 和 j = 22。以及 i = 12，j = 2。这样的两种情况产生的就都是 122。加上 “@” 可以区分开来。</p>
<p>原文中：map 的 value 取值有三个，用 1 表示 true，0 表示 false，-1 代表还未赋值。</p>
<p>但其实这里并不会用到三个值，因为一旦遇到的 i 和 j 满足要求，直接返回 true 即可，不需要再存入 map 中。因此，这里定义的 memo 就是一个不满足要求的 i 和 j 组合，只要 memo中含有 i 和 j 的组合，则直接返回 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// memo 的 key 是：i + "@" + j，用@隔开是为了防止i=1,j=22时，可能出现两种组合情况：(1,22),(12,2)</span></span><br><span class="line">    <span class="comment">// memo 的 value 取值：-1 表示为赋值；0 表示false；1 表示true</span></span><br><span class="line">    <span class="comment">// value 其实用不到三个值，因为一旦当前的 i 和 j 符合要求，直接返回 true 即可。因此 memo 中只需要存不满足情况的 i 和 j 即可</span></span><br><span class="line">    Map&lt;String, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> backtrack2(s1, s2, s3, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack2</span><span class="params">(String s1, String s2, String s3, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, Map&lt;String, Integer&gt; memo)</span> </span>&#123;</span><br><span class="line">    String key = i + <span class="string">"@"</span> + j;</span><br><span class="line">    <span class="keyword">if</span> (memo.containsKey(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == s1.length() &amp;&amp; j == s2.length() &amp;&amp; k == s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == s1.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.charAt(j) != s3.charAt(k)) &#123;</span><br><span class="line">                memo.put(key, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == s2.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s3.charAt(k)) &#123;</span><br><span class="line">                memo.put(key, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(i) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrack2(s1, s2, s3, i + <span class="number">1</span>, j, k + <span class="number">1</span>, memo)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s2.charAt(j) == s3.charAt(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtrack2(s1, s2, s3, i, j + <span class="number">1</span>, k + <span class="number">1</span>, memo))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo.put(key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-方法三：动态规划"><a href="#15-4-方法三：动态规划" class="headerlink" title="15.4. 方法三：动态规划"></a>15.4. 方法三：动态规划</h3><p>参考：<a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">这里</a></p>
<p>dp 数组定义：定义一个 boolean 二维数组 dp [ i ] [ j ] 来表示 s1[ 0, i ) 和 s2 [ 0, j ） 组合后能否构成 s3 [ 0, i + j )，注意不包括右边界，主要是为了考虑开始的时候如果只取 s1，那么 s2 就是空串，这样的话 dp [ i ] [ 0 ] 就能表示 s2 取空串。</p>
<p>注意，<code>dp[0][0]</code> 表示 s1 和 s2 都取空串，组成一个空串，则值为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> &amp;&amp; s2.length() == <span class="number">0</span> &amp;&amp; s3.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">    <span class="comment">// dp[i][j] = true 表示：s1[0..i) 和 s2[0..j) 组合后能构成 s3[0..i+j)</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>))</span><br><span class="line">                || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-路径总和-II-113"><a href="#16-路径总和-II-113" class="headerlink" title="16. 路径总和 II [113]"></a>16. 路径总和 II [113]</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></p>
<h3 id="16-1-题目描述"><a href="#16-1-题目描述" class="headerlink" title="16.1. 题目描述"></a>16.1. 题目描述</h3><p><img src="/pictures/image-20200903093332125.png" alt="image-20200903093332125"></p>
<h3 id="16-2-代码"><a href="#16-2-代码" class="headerlink" title="16.2. 代码"></a>16.2. 代码</h3><p>典型的回溯思路：采用试错的思想，尝试分步去解决问题，在分步解决问题的过程中，当通过尝试发现现有的分布答案不能得到有效的正确答案时，取消上一步甚至是上几步的计算，再通过其他的分布尝试寻找问题的答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    track.add(root.val);</span><br><span class="line">    backtrack(root, sum, track, root.val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, LinkedList&lt;Integer&gt; track, <span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 做出选择：左子树</span></span><br><span class="line">        track.add(root.left.val);</span><br><span class="line">        backtrack(root.left, sum, track, tmp + root.left.val);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        track.add(root.right.val);</span><br><span class="line">        backtrack(root.right, sum, track, tmp + root.right.val);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-参考引用"><a href="#17-参考引用" class="headerlink" title="17. 参考引用"></a>17. 参考引用</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></li>
<li><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></li>
<li><a href="https://leetcode.wang/leetCode-77-Combinations.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-77-Combinations.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qT6WgR6Qwn7ayZkI3AineA</a></li>
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/</a></li>
<li><a href="https://leetcode.wang/leetCode-97-Interleaving-String.html" target="_blank" rel="noopener">https://leetcode.wang/leetCode-97-Interleaving-String.html</a></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Julia Jiang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://www.juliajiang.top/2020/07/25/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="回溯算法总结">https://www.juliajiang.top/2020/07/25/回溯算法总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
              <a href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag"># 回溯</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/23/JSON%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E6%8D%A2/" rel="prev" title="JSON与Java对象的转换">
      <i class="fa fa-chevron-left"></i> JSON与Java对象的转换
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/" rel="next" title="动态规划总结">
      动态规划总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么是回溯法？"><span class="nav-text">1. 什么是回溯法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-回溯法框架"><span class="nav-text">2. 回溯法框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-以全排列问题（无重复数字）为例-46"><span class="nav-text">3. 以全排列问题（无重复数字）为例 [46]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-题目描述"><span class="nav-text">3.1 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-问题分析"><span class="nav-text">3.2 问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-代码"><span class="nav-text">3.3 代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-另一种方法"><span class="nav-text">3.4 另一种方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-N皇后问题-51"><span class="nav-text">4. N皇后问题 [51]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-题目描述"><span class="nav-text">4.1 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-问题分析"><span class="nav-text">4.2 问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-代码"><span class="nav-text">4.3 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-回溯法总结"><span class="nav-text">5. 回溯法总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-使用回溯法的题目列表"><span class="nav-text">6. 使用回溯法的题目列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-例题：全排列问题（有重复数字）-47"><span class="nav-text">7. 例题：全排列问题（有重复数字）[47]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-题目描述"><span class="nav-text">7.1 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-题目分析"><span class="nav-text">7.2 题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-代码"><span class="nav-text">7.3 代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-小结"><span class="nav-text">7.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-例题：组合总和-39"><span class="nav-text">8. 例题：组合总和 [39]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-题目描述"><span class="nav-text">8.1 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-题目分析"><span class="nav-text">8.2 题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-代码"><span class="nav-text">8.3 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-例题：组合总和-2-40"><span class="nav-text">9. 例题：组合总和 2 [40]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-题目描述"><span class="nav-text">9.1 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-题目分析"><span class="nav-text">9.2 题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-代码"><span class="nav-text">9.3 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-例题：组合-70"><span class="nav-text">10. 例题：组合 [70]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-题目描述"><span class="nav-text">10.1 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-题目分析"><span class="nav-text">10.2 题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-代码"><span class="nav-text">10.3 代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-优化"><span class="nav-text">10.4 优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-单词搜索-79"><span class="nav-text">11. 单词搜索 [79]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-题目描述"><span class="nav-text">11.1. 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-题目分析"><span class="nav-text">11.2. 题目分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-代码"><span class="nav-text">11.3. 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-子集-78"><span class="nav-text">12. 子集 [78]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-题目描述"><span class="nav-text">12.1. 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-方法一：迭代"><span class="nav-text">12.1. 方法一：迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-方法二：回溯算法"><span class="nav-text">12.2. 方法二：回溯算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-子集-II-90"><span class="nav-text">13. 子集 II [90]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-题目描述"><span class="nav-text">13.1. 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-代码"><span class="nav-text">13.2. 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-复原IP地址-93"><span class="nav-text">14. 复原IP地址 [93]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-题目描述"><span class="nav-text">14.1. 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-解法一：暴力破解（迭代）"><span class="nav-text">14.2. 解法一：暴力破解（迭代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-解法二：回溯"><span class="nav-text">14.3. 解法二：回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-交错字符串-97"><span class="nav-text">15. 交错字符串 [97]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-题目描述"><span class="nav-text">15.1. 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-方法一：回溯法"><span class="nav-text">15.2. 方法一：回溯法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-方法二：回溯法的优化（备忘录）"><span class="nav-text">15.3. 方法二：回溯法的优化（备忘录）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-方法三：动态规划"><span class="nav-text">15.4. 方法三：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-路径总和-II-113"><span class="nav-text">16. 路径总和 II [113]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1-题目描述"><span class="nav-text">16.1. 题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-代码"><span class="nav-text">16.2. 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-参考引用"><span class="nav-text">17. 参考引用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Julia Jiang"
      src="/images/icon.jpg">
  <p class="site-author-name" itemprop="name">Julia Jiang</p>
  <div class="site-description" itemprop="description">If a thing is worth doing, it's worth doing well</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JuliaJiang7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JuliaJiang7" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/julia.jiang.fan@gmail.com" title="E-Mail → julia.jiang.fan@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Julia_F" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Julia_F" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/FanJiang77" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;FanJiang77" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/juliajiangf" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;juliajiangf" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yamon.top/" title="http:&#x2F;&#x2F;yamon.top&#x2F;" rel="noopener" target="_blank">yamon</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Julia Jiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">143k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:10</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
