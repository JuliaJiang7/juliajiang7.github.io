{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/pictures/08786FDF.png","path":"pictures/08786FDF.png","modified":0,"renderable":0},{"_id":"source/pictures/CgpOIF5rDYmAPR1lAABl-qSxBYs115.png","path":"pictures/CgpOIF5rDYmAPR1lAABl-qSxBYs115.png","modified":0,"renderable":0},{"_id":"source/pictures/CgpOIF5rDYmATP43AAB3coc0R64799.png","path":"pictures/CgpOIF5rDYmATP43AAB3coc0R64799.png","modified":0,"renderable":0},{"_id":"source/pictures/Cgq2xl5rDYmAXoWFAAArXO_oe8c713.png","path":"pictures/Cgq2xl5rDYmAXoWFAAArXO_oe8c713.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200405194407416.png","path":"pictures/image-20200405194407416.png","modified":0,"renderable":0},{"_id":"source/pictures/微信截图_20200405164325.png","path":"pictures/微信截图_20200405164325.png","modified":0,"renderable":0},{"_id":"source/pictures/微信截图_20200405164537.png","path":"pictures/微信截图_20200405164537.png","modified":0,"renderable":0},{"_id":"source/pictures/微信截图_20200405164821-1586080506840.png","path":"pictures/微信截图_20200405164821-1586080506840.png","modified":0,"renderable":0},{"_id":"source/pictures/微信截图_20200405164821.png","path":"pictures/微信截图_20200405164821.png","modified":0,"renderable":0},{"_id":"source/pictures/微信截图_20200405164821-1586080520904.png","path":"pictures/微信截图_20200405164821-1586080520904.png","modified":0,"renderable":0},{"_id":"source/pictures/微信截图_20200405234951.png","path":"pictures/微信截图_20200405234951.png","modified":0,"renderable":0},{"_id":"source/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png","path":"pictures/b2cb057773e3d67976c535d6ef547d51_720w.png","modified":0,"renderable":0},{"_id":"source/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png","path":"pictures/544caeb82a329fa49cc99842818ed1ba_720w.png","modified":0,"renderable":0},{"_id":"source/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png","path":"pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png","modified":0,"renderable":0},{"_id":"source/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png","path":"pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png","modified":0,"renderable":0},{"_id":"source/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg","path":"pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg","modified":0,"renderable":0},{"_id":"source/pictures/icon.jpg","path":"pictures/icon.jpg","modified":0,"renderable":0},{"_id":"source/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg","path":"pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"source/pictures/58e67eae921e4b431782c07444af824e_r.jpg","path":"pictures/58e67eae921e4b431782c07444af824e_r.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/pictures/13px-Dark_Red_x.svg-1587911490598.png","path":"pictures/13px-Dark_Red_x.svg-1587911490598.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Green_check.svg-1587911490574.png","path":"pictures/13px-Green_check.svg-1587911490574.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Green_check.svg-1587911490720.png","path":"pictures/13px-Green_check.svg-1587911490720.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Dark_Red_x.svg-1587911490730.png","path":"pictures/13px-Dark_Red_x.svg-1587911490730.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Dark_Red_x.svg-1587911490852.png","path":"pictures/13px-Dark_Red_x.svg-1587911490852.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Green_check.svg.png","path":"pictures/13px-Green_check.svg.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Dark_Red_x.svg.png","path":"pictures/13px-Dark_Red_x.svg.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Green_check.svg-1587911491234.png","path":"pictures/13px-Green_check.svg-1587911491234.png","modified":0,"renderable":0},{"_id":"source/pictures/13px-Yellow_check.svg.png","path":"pictures/13px-Yellow_check.svg.png","modified":0,"renderable":0},{"_id":"source/pictures/280px-PrimaryKey_zht.svg.png","path":"pictures/280px-PrimaryKey_zht.svg.png","modified":0,"renderable":0},{"_id":"source/pictures/4b9c2ec85d900b1485fad362aabc2349a4d54ad3.svg","path":"pictures/4b9c2ec85d900b1485fad362aabc2349a4d54ad3.svg","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426223643952.png","path":"pictures/image-20200426223643952.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426223715720.png","path":"pictures/image-20200426223715720.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426224653184.png","path":"pictures/image-20200426224653184.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426224741598.png","path":"pictures/image-20200426224741598.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426225059906.png","path":"pictures/image-20200426225059906.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426225211203.png","path":"pictures/image-20200426225211203.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426225223170.png","path":"pictures/image-20200426225223170.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426225402284.png","path":"pictures/image-20200426225402284.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426230751958.png","path":"pictures/image-20200426230751958.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426230943516.png","path":"pictures/image-20200426230943516.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426231044849.png","path":"pictures/image-20200426231044849.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426231034553.png","path":"pictures/image-20200426231034553.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200427232114257.png","path":"pictures/image-20200427232114257.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200427232353749.png","path":"pictures/image-20200427232353749.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200427232447340.png","path":"pictures/image-20200427232447340.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200427232554631.png","path":"pictures/image-20200427232554631.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200427232650317.png","path":"pictures/image-20200427232650317.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200428231345713.png","path":"pictures/image-20200428231345713.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200428230552342.png","path":"pictures/image-20200428230552342.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200428232129091.png","path":"pictures/image-20200428232129091.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200428232253846.png","path":"pictures/image-20200428232253846.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200426223214696.png","path":"pictures/image-20200426223214696.png","modified":0,"renderable":0},{"_id":"source/pictures/20140725231726921","path":"pictures/20140725231726921","modified":0,"renderable":0},{"_id":"source/pictures/20140728110939595","path":"pictures/20140728110939595","modified":0,"renderable":0},{"_id":"source/pictures/20140729181940812","path":"pictures/20140729181940812","modified":0,"renderable":0},{"_id":"source/pictures/20140729182154066","path":"pictures/20140729182154066","modified":0,"renderable":0},{"_id":"source/pictures/8394323_1308075859Zfue.jpg","path":"pictures/8394323_1308075859Zfue.jpg","modified":0,"renderable":0},{"_id":"source/pictures/8394323_13080758591kyV.jpg","path":"pictures/8394323_13080758591kyV.jpg","modified":0,"renderable":0},{"_id":"source/pictures/8394323_13080758591kyV-1595069195969.jpg","path":"pictures/8394323_13080758591kyV-1595069195969.jpg","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050103.png","path":"pictures/bg2013050103.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050105.png","path":"pictures/bg2013050105.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050104.png","path":"pictures/bg2013050104.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050106.png","path":"pictures/bg2013050106.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050107-1594975043794.png","path":"pictures/bg2013050107-1594975043794.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050107.png","path":"pictures/bg2013050107.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050109.png","path":"pictures/bg2013050109.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050108.png","path":"pictures/bg2013050108.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050110.png","path":"pictures/bg2013050110.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050111.png","path":"pictures/bg2013050111.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050112.png","path":"pictures/bg2013050112.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050112-1594975805920.png","path":"pictures/bg2013050112-1594975805920.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050113.png","path":"pictures/bg2013050113.png","modified":0,"renderable":0},{"_id":"source/pictures/bg2013050114.png","path":"pictures/bg2013050114.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200514143731277-1595486755603.png","path":"pictures/image-20200514143731277-1595486755603.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200514143731277.png","path":"pictures/image-20200514143731277.png","modified":0,"renderable":0},{"_id":"source/pictures/image-20200721113245712.png","path":"pictures/image-20200721113245712.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1585400022024},{"_id":"source/404.html","hash":"34fddfbc8b832a589d442e5690e549040653e924","modified":1585475078366},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1585400022022},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1585400022036},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1585400022035},{"_id":"themes/next/_config.yml","hash":"51cca253f27546b4e32a04d31e2df2ff4e262860","modified":1595071278873},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1585400022025},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1585400022039},{"_id":"themes/next/package.json","hash":"bfa483bfcc88bd7601faf707d23b5e315bb39428","modified":1585400022143},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1585400022045},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1585400022042},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1585400022065},{"_id":"source/pictures/08786FDF.png","hash":"da1bfbf1105a1417d952402f2c75f61005e83367","modified":1586665621339},{"_id":"source/_posts/HashMap实现原理及其重要方法.md","hash":"47f7448c434fad06f7b8cc702681a203788a0dda","modified":1586744552224},{"_id":"source/_posts/hello-world.md","hash":"e32917c15a112c5d92ab95143d62d7e92876b998","modified":1586100518698},{"_id":"source/categories/index.md","hash":"edd1f24931443fb635da7554f25c9d4d8621a7e1","modified":1585474870837},{"_id":"source/pictures/CgpOIF5rDYmAPR1lAABl-qSxBYs115.png","hash":"3f27a0a4597ebd2ad6923a07b2a4a7217b4e722a","modified":1586617209639},{"_id":"source/_posts/String的特点以及方法.md","hash":"dd248e8a2a45644bf6601da5ebb00a3b7c83383b","modified":1586679707120},{"_id":"source/pictures/CgpOIF5rDYmATP43AAB3coc0R64799.png","hash":"ffdee18e263362103bdcf9cdcc490925a02ec404","modified":1586616630140},{"_id":"source/pictures/Cgq2xl5rDYmAXoWFAAArXO_oe8c713.png","hash":"e0497e15938d539b6b1850ddbd8b1aeccb724acf","modified":1586616832671},{"_id":"source/pictures/image-20200405194407416.png","hash":"1586f8d8afffd0c2defda7f2eacefc58c083af21","modified":1586087047468},{"_id":"source/pictures/微信截图_20200405164325.png","hash":"2434373813e3d3c0edab941d1992a3541499b8a1","modified":1586076214692},{"_id":"source/pictures/微信截图_20200405164537.png","hash":"aafe4fbe5866dd55281f4258c056455d4acb83f2","modified":1586076347904},{"_id":"source/pictures/微信截图_20200405164821-1586080506840.png","hash":"387c75d9cd846a3d5966f6cd2c823832b8b20fb7","modified":1586080506864},{"_id":"source/pictures/微信截图_20200405164821.png","hash":"387c75d9cd846a3d5966f6cd2c823832b8b20fb7","modified":1586076521235},{"_id":"source/pictures/微信截图_20200405164821-1586080520904.png","hash":"387c75d9cd846a3d5966f6cd2c823832b8b20fb7","modified":1586080520907},{"_id":"source/pictures/微信截图_20200405234951.png","hash":"22926ce81df0569292d85abe87974310934a4d55","modified":1586101850427},{"_id":"source/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png","hash":"f0c66ea4b87387c5d35d2e5cc126db0e59beebc5","modified":1586666983926},{"_id":"source/tags/index.md","hash":"260405b9d087344669c6ca7bd105def5f346dea6","modified":1585474815639},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1585400022046},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1585400022046},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1585400022047},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1585400022047},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1585400022048},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1585400022049},{"_id":"themes/next/languages/ar.yml","hash":"ab452dbf9b743ad09dd288e59e4cd05e39073da7","modified":1585400022066},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1585400022050},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1585400022067},{"_id":"themes/next/languages/de.yml","hash":"b0031b3138fa284b343b077f9f5ee0e74d99780b","modified":1585400022067},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1585400022049},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1585400022067},{"_id":"themes/next/languages/es.yml","hash":"3fde31f66a85dc6680c3fb465a33267c4131b3f2","modified":1585400022068},{"_id":"themes/next/languages/fr.yml","hash":"59ec6667044a490ae4f4fcfa63dbe44258295939","modified":1585400022069},{"_id":"themes/next/languages/fa.yml","hash":"fba239631e9f7f0f2ed57cdd68aaf1575287f239","modified":1585400022069},{"_id":"themes/next/languages/hu.yml","hash":"9563b8c8a7ced986907ce19d04752a1311fbd7c5","modified":1585400022070},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1585400022051},{"_id":"themes/next/languages/id.yml","hash":"a6d2b28eadca084fb431aae3b6b951a472283020","modified":1585400022070},{"_id":"themes/next/languages/it.yml","hash":"161c577cac26f02c9d2ccf2dc9821a426b0ce4db","modified":1585400022071},{"_id":"themes/next/languages/ja.yml","hash":"8f5ad466b8c41c111cba7de5b83f85ec9230be74","modified":1585400022072},{"_id":"themes/next/languages/ko.yml","hash":"9b213360a8124154b97bf7a98eae2c7882085586","modified":1585400022072},{"_id":"themes/next/languages/nl.yml","hash":"c67f1d49cf359d1ad1b0a8f2044ce0cba3bfd26d","modified":1585400022072},{"_id":"themes/next/languages/pt-BR.yml","hash":"2ef717b9fcd01e042b32668853f9b5ea9aaf3bdb","modified":1585400022073},{"_id":"themes/next/languages/pt.yml","hash":"5f18c0aeab170daabcc2c22b2febd7c8ba261f40","modified":1585400022074},{"_id":"themes/next/languages/ru.yml","hash":"f471f4c5a6c394ff22427a4225abfe33a7b4d70f","modified":1585400022075},{"_id":"themes/next/languages/tr.yml","hash":"a02bc85395aaa5af3eaabb072fc9e9c82165e097","modified":1585400022076},{"_id":"themes/next/languages/uk.yml","hash":"926717252a5ff257e25094910237100f488e486f","modified":1585400022076},{"_id":"themes/next/languages/vi.yml","hash":"6a9eab836e0a443465b98f2a5c93e6c46d641a9f","modified":1585400022077},{"_id":"themes/next/languages/zh-CN.yml","hash":"886add8f2528ce7134281d2a0bb81d0e4f18292c","modified":1585400022077},{"_id":"themes/next/languages/zh-TW.yml","hash":"b888df9d5aeb732c35b3edc311257f15702a9bb4","modified":1585400022078},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1585400022079},{"_id":"themes/next/languages/zh-HK.yml","hash":"37c18e916d84854caeaa440693be250c7f553e30","modified":1585400022078},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1585400022138},{"_id":"themes/next/layout/index.swig","hash":"a6deacb837a435243fb2cb6dfa20f6ac0b2e05e9","modified":1585400022138},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1585400022138},{"_id":"themes/next/layout/page.swig","hash":"c8d11a7317b8831a59eec7fce0d8489543c75078","modified":1585400022139},{"_id":"themes/next/layout/post.swig","hash":"4d5215eda9554843a13816f6ca6e42ca87374210","modified":1585400022139},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1585400022141},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1585400022193},{"_id":"source/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png","hash":"06e9dd0ef543f293834ba9530eb4bd6a77e7ec57","modified":1586667022305},{"_id":"source/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png","hash":"d00e6d851a6a0ff456541d5dcfdecf1a23ae37c5","modified":1586672795788},{"_id":"source/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png","hash":"6ecc82a616bf4a228d9d64db036c696dbbdb251a","modified":1586674393962},{"_id":"source/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg","hash":"680974721014c89b2e93b2bfd613fba7b07958e8","modified":1586666893889},{"_id":"source/pictures/icon.jpg","hash":"6da3fb027a364a7a842a8373918c75ea4c360771","modified":1586076154249},{"_id":"source/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg","hash":"abea0ba889725a7c96a76ea48450830ba3c17c43","modified":1586664499829},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1585400022052},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1585400022054},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1585400022055},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1585400022056},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1585400022060},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1585400022061},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1585400022062},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1585400022061},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1585400022063},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1585400022055},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c459531bba73a11ce84435d2c91f105ecd0e310a","modified":1585400022080},{"_id":"themes/next/layout/_macro/post.swig","hash":"60d4ab526812d93ad17e44e51ddaf5d7d4e06475","modified":1585400022080},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a76355d230792e924ea3beb3094bad4b51567419","modified":1585476182851},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1585400022081},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1585400022082},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1585400022063},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1585400022089},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1585400022093},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1585400022107},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1585400022106},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1585400022108},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ee857f646d0d5c39badc6be02241a65e4a4a719f","modified":1585400022111},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1585400022113},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1585400022114},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1585400022117},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1585400022128},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1585400022130},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1585400022131},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1585400022065},{"_id":"themes/next/scripts/events/index.js","hash":"7baf362743b3d30626066614d877891fc140c502","modified":1585400022144},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1585400022184},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1585400022064},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1585400022184},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1585400022185},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1585400022185},{"_id":"themes/next/scripts/filters/post.js","hash":"cf5b0db0a9271687f7a21bc581ae87addd8f0767","modified":1585400022186},{"_id":"themes/next/scripts/helpers/engine.js","hash":"6abda91b431c9b6f6cd2adfa665e694cfdb171be","modified":1585400022188},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1585400022189},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1585400022191},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1585400022192},{"_id":"themes/next/scripts/tags/button.js","hash":"178d3efb8d2c1aca606181894c352fc65c40c32a","modified":1585400022194},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1585400022194},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e11a738ee77c4304add79c964bdec3715c45653a","modified":1585400022195},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1585400022195},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1585400022196},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1585400022196},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1585400022197},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1585400022197},{"_id":"themes/next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1585400022198},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1585400022198},{"_id":"themes/next/source/css/_colors.styl","hash":"dbf0318df3b183f32b1f1c98621614e2fea72969","modified":1585400022199},{"_id":"themes/next/source/css/_mixins.styl","hash":"cf81a6731aa436e7bb8d9a743b01f62107e27dd3","modified":1585400022293},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1585400022311},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1585400022311},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1585400022312},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1585400022310},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1585400022314},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1585400022317},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1585400022317},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1585400022316},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1585400022349},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1585400022351},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1585400022350},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1585400022351},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1585400022351},{"_id":"themes/next/source/images/favicon.ico","hash":"83222202712d4542f60f7d26f6cb6534f7900016","modified":1585476384032},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1585400022351},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1585400022318},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1585400022318},{"_id":"themes/next/source/js/local-search.js","hash":"8f046860139f8dc7d1b445290a19e391800ff322","modified":1585400022361},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1585400022361},{"_id":"themes/next/source/js/next-boot.js","hash":"509c5b02446d4989a6ef3081cafeb9497cdde4e5","modified":1585400022363},{"_id":"themes/next/source/js/utils.js","hash":"212349738695f0c5dffcf26f6a3d33ce912e4ed4","modified":1585400022365},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1585400022367},{"_id":"source/pictures/58e67eae921e4b431782c07444af824e_r.jpg","hash":"5224f89fe8e92c5d1e890fb89911231d88825a72","modified":1586661394751},{"_id":"themes/next/source/js/algolia-search.js","hash":"f0cee802b4d48d5e78ba88d77d4257cb8a88dd6e","modified":1585400022355},{"_id":"themes/next/source/js/bookmark.js","hash":"2268bfcab8cf9019e590e2d356b08a3d4a0cf791","modified":1585400022355},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1585400022083},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"ca1b16202403515550f57b51dccb19afcb10ccf1","modified":1585400022083},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1585400022085},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1585400022085},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"11acd6b585eeb823358e642c7dde7d637fda706f","modified":1585400022088},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"6a3901962ad7e698640a288be627947de90de1f6","modified":1585400022088},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1585400022089},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1585400022093},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1585400022092},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1585400022104},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1585400022104},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1585400022104},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1585400022102},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"5fd5ba53962aefccb43b1d2b306a534add2373e1","modified":1585400022094},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"deffa919e72da6c2cdc2f32d403c809916bd36d1","modified":1585400022101},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1585400022102},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1585400022103},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"d1b9a43bdfaf2b151cce1a74d23e65c2e488e41b","modified":1585400022106},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1585400022112},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1585400022112},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1585400022108},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1585400022112},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1585400022113},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1585400022115},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1585400022117},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1585400022117},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1585400022121},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1585400022118},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1585400022122},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1585400022123},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1585400022127},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1585400022125},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1585400022127},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1585400022128},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1585400022129},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1585400022129},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1585400022131},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1585400022132},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1585400022130},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1585400022133},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"5b5618c2f6ad1d7971e6db257222fce89aa56565","modified":1585400022133},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1585400022134},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1585400022136},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1585400022135},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1585400022137},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1585400022136},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1585400022137},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1585400022146},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1585400022146},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1585400022147},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"d002c9eea7e7dd31b64a4172012d4294489974d5","modified":1585400022168},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"31a6c8fbdfa16112b0b099727437b9df7641d421","modified":1585400022169},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1585400022180},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"14917c0f9ac76b50296e64437316cba0966c61d1","modified":1585400022181},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1585400022181},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1585400022182},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1585400022183},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"7ff11f64f4315d06ba585928fc9a8bc3761894a5","modified":1585400022183},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1585400022306},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4c17c448d090a2468edc3fbd797770e7150a4054","modified":1585400022309},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d95c217139e964633655e5df857d64cd1e5e0fbe","modified":1586706404222},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"1a9741145938e2c754a808381350723cbebf43c5","modified":1585400022364},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1585400022308},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"40480ec86214b5da843549aa3cc2732ed3a718d6","modified":1585400022306},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1585400022376},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1585400022372},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1585400022372},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1585400022376},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1585400022389},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1585400022390},{"_id":"themes/next/source/js/schemes/muse.js","hash":"78c77614b9fe0d7d97aa08468c6cffbcbda96b75","modified":1585400022364},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1585400022377},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1585400022116},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1585400022228},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1585400022227},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"ca1da6314c123f1bf0a95feefb073f08bb8c256a","modified":1585400022252},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"a88d17d642c3ae3452e9eeb87b0d22d6d63dc0f6","modified":1585400022266},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"90be8ad82cd0707e2952fe2c815638a723d1cfbb","modified":1585400022268},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1585400022267},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1585400022277},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1585400022275},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1585400022276},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"7ed4733240206d1aa729c835e69a85f8f3c73cd6","modified":1585400022279},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1585400022240},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1585400022226},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"78406dfb644b0e516f697aead3ed5d545c5b8144","modified":1585400022251},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1585400022295},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"33a3afa51df3dfffc12dd98cc9fa329cd6ce00e1","modified":1585400022296},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1585400022292},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1585400022297},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"8bc26dee02d18ad15a704df366097e72f43c1bbb","modified":1585400022298},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f65e8f5be2a7cbb477524a0933460d99b75f80db","modified":1585400022295},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1585400022298},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"cf10a9f9e0d3919741525007799d34ff06a3ba4f","modified":1585400022299},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1585400022298},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1585400022299},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1585400022302},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1585400022302},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1585400022305},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"315eea625a90a19421b6d6413322ae40bb5ad4c6","modified":1585400022303},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"919068c7db32bfee26238e3a783efe14b3060d63","modified":1585400022304},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"c9df5ee78b46f4a2926e6e88fbe1ba1a9a75aecc","modified":1585400022304},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1585400022301},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1585400022300},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1585400022301},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1585400022379},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1585400022381},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1585400022387},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1585400022229},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1585400022229},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1585400022230},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"a22c639cdf1073c9d060af62233125991ddf4dd5","modified":1585400022231},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"66001b7624ca044f9c06e75036f0e6e4b091b094","modified":1585400022231},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1585400022232},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"9f0e94f3b39388393979f00dad4a0e833b7a62ae","modified":1585400022232},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"724ca213d15ae27158c2cddf9c26d3dba3582283","modified":1585400022233},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1585400022235},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"2bfe115c2fc68f4dfce4afc4a001a2db81edd83b","modified":1585400022234},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"44749e3f07a328d81a959708316494d3d737ab57","modified":1585400022235},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1585400022237},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1585400022238},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"81b2bbd6fb590101a089bc390ed4934f5c462215","modified":1585400022236},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1585400022239},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1585400022234},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"82a275ca74086a46b8e82d5ebf78c7a807cd9c8b","modified":1585400022237},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1585400022245},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1585400022239},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1585400022243},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1585400022243},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1585400022245},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1585400022248},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1585400022246},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1585400022247},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1585400022251},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"73c578914052e11392cd4364af9075b66832b793","modified":1585400022248},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1585400022249},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1585400022262},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1585400022256},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"0812ae7ecd1d8c60ec4290f506ec10881ed0fca8","modified":1585400022263},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1585400022260},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1585400022263},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"f7977cfacaca9db6fab4d154486ad57ec4b0fde9","modified":1585400022246},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1585400022244},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1585400022264},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1585400022263},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1585400022264},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1585400022265},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1585400022272},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1585400022265},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1585400022268},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1585400022273},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1585400022274},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1585400022247},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1585400022283},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1585400022283},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"8c318a485c56dbdcdb22fd00781484ecc151bf8a","modified":1585400022280},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1585400022287},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9d1f42d01f6e346b61f83cdd4f5fbd3bf8e44968","modified":1585400022284},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"798a81e94fc14c78173b6f2553b0892d90fcb29a","modified":1585400022285},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1585400022386},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1585400022284},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1585400022378},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1585400022385},{"_id":"public/search.xml","hash":"a9a5a949a7142494e1a70a219280a5bb6b9dd7ae","modified":1595487749450},{"_id":"public/404.html","hash":"0dc747b5802b5dc6cd87a53c7107116e9e525eab","modified":1595487749450},{"_id":"public/categories/index.html","hash":"659210f5423ea02151a044d99c90e22b2e5758ea","modified":1595487749450},{"_id":"public/tags/index.html","hash":"2229502088333d7fbc20d84e171798ef0e2ea0b9","modified":1595487749450},{"_id":"public/archives/index.html","hash":"564e89a6827d24dc6f27244ab379d941fd712a3a","modified":1595487749450},{"_id":"public/archives/2020/index.html","hash":"541d442a4bc9089453097d430fd5163582e158bd","modified":1595487749450},{"_id":"public/archives/2020/03/index.html","hash":"386c3883205e153978a0742235165f72115f8d18","modified":1595070814815},{"_id":"public/archives/2020/04/index.html","hash":"0c0a49f40fa666b1c8c1fd7ffd165976444881a9","modified":1595487749450},{"_id":"public/tags/HashMap/index.html","hash":"ecc5649de85d67c175831a4df15003bc96bb632b","modified":1595487749450},{"_id":"public/tags/Java/index.html","hash":"afd5653370cc3269fee4d82b8bb140718d4368ed","modified":1595487749450},{"_id":"public/tags/String/index.html","hash":"37fcf80e8a6035000a74d14e54b54d87480537a4","modified":1595487749450},{"_id":"public/categories/Java/index.html","hash":"d3c265f11b8dbb691e9f4ad917db70ba149e684a","modified":1595487749450},{"_id":"public/2020/04/05/HashMap实现原理及其重要方法/index.html","hash":"d85ba7ccc2ef13ed56e3a17da4834c8bf46072b6","modified":1595487749450},{"_id":"public/2020/04/04/String的特点以及方法/index.html","hash":"1370902f8101e31bc11837e8a0919b2c9bce3886","modified":1595487749450},{"_id":"public/2020/03/28/hello-world/index.html","hash":"b6bbda297ce2e69a6976378835d3411ea24ab64d","modified":1595071387838},{"_id":"public/index.html","hash":"c20c0fd31b6fd652c9278ebda3351fbccda4003a","modified":1595487749450},{"_id":"public/pictures/08786FDF.png","hash":"da1bfbf1105a1417d952402f2c75f61005e83367","modified":1586706828653},{"_id":"public/pictures/CgpOIF5rDYmATP43AAB3coc0R64799.png","hash":"ffdee18e263362103bdcf9cdcc490925a02ec404","modified":1586706828653},{"_id":"public/pictures/Cgq2xl5rDYmAXoWFAAArXO_oe8c713.png","hash":"e0497e15938d539b6b1850ddbd8b1aeccb724acf","modified":1586706828653},{"_id":"public/pictures/image-20200405194407416.png","hash":"1586f8d8afffd0c2defda7f2eacefc58c083af21","modified":1586706828653},{"_id":"public/pictures/微信截图_20200405164325.png","hash":"2434373813e3d3c0edab941d1992a3541499b8a1","modified":1586706828653},{"_id":"public/pictures/微信截图_20200405164537.png","hash":"aafe4fbe5866dd55281f4258c056455d4acb83f2","modified":1586706828653},{"_id":"public/pictures/微信截图_20200405164821-1586080506840.png","hash":"387c75d9cd846a3d5966f6cd2c823832b8b20fb7","modified":1586706828653},{"_id":"public/pictures/微信截图_20200405164821.png","hash":"387c75d9cd846a3d5966f6cd2c823832b8b20fb7","modified":1586706828653},{"_id":"public/pictures/微信截图_20200405164821-1586080520904.png","hash":"387c75d9cd846a3d5966f6cd2c823832b8b20fb7","modified":1586706828653},{"_id":"public/pictures/微信截图_20200405234951.png","hash":"22926ce81df0569292d85abe87974310934a4d55","modified":1586706828653},{"_id":"public/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png","hash":"f0c66ea4b87387c5d35d2e5cc126db0e59beebc5","modified":1586706828653},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1586706828653},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1586706828653},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1586706828653},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1586706828653},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1586706828653},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1586706828653},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1586706828653},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1586706828653},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1586706828653},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1586706828653},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1586706828653},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1586706828653},{"_id":"public/images/favicon.ico","hash":"83222202712d4542f60f7d26f6cb6534f7900016","modified":1586706828653},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1586706828653},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1586706828653},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1586706828653},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1586706828653},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1586706828653},{"_id":"public/pictures/CgpOIF5rDYmAPR1lAABl-qSxBYs115.png","hash":"3f27a0a4597ebd2ad6923a07b2a4a7217b4e722a","modified":1586706828653},{"_id":"public/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png","hash":"d00e6d851a6a0ff456541d5dcfdecf1a23ae37c5","modified":1586706828653},{"_id":"public/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png","hash":"6ecc82a616bf4a228d9d64db036c696dbbdb251a","modified":1586706828653},{"_id":"public/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg","hash":"680974721014c89b2e93b2bfd613fba7b07958e8","modified":1586706828653},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1586706828653},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1586706828653},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1586706828653},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1586706828653},{"_id":"public/js/utils.js","hash":"95c5d37aa06521675afcf8619cfc5dbba3d2e18a","modified":1586706828653},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1586706828653},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1586706828653},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1586706828653},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1586706828653},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1586706828653},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1586706828653},{"_id":"public/css/main.css","hash":"a94b060e15815bc7bc1b075194f653ab93111709","modified":1586706828653},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1586706828653},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1586706828653},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1586706828653},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1586706828653},{"_id":"public/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg","hash":"abea0ba889725a7c96a76ea48450830ba3c17c43","modified":1586706828653},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1586706828653},{"_id":"public/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png","hash":"06e9dd0ef543f293834ba9530eb4bd6a77e7ec57","modified":1586706828653},{"_id":"public/pictures/icon.jpg","hash":"6da3fb027a364a7a842a8373918c75ea4c360771","modified":1586706828653},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1586706828653},{"_id":"public/pictures/58e67eae921e4b431782c07444af824e_r.jpg","hash":"5224f89fe8e92c5d1e890fb89911231d88825a72","modified":1586706828653},{"_id":"source/pictures/13px-Dark_Red_x.svg-1587911490598.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1587911491182},{"_id":"source/pictures/13px-Green_check.svg-1587911490574.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1587911491177},{"_id":"source/pictures/13px-Green_check.svg-1587911490720.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1587911491228},{"_id":"source/pictures/13px-Dark_Red_x.svg-1587911490730.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1587911491233},{"_id":"source/pictures/13px-Dark_Red_x.svg-1587911490852.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1587911491238},{"_id":"source/pictures/13px-Green_check.svg.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1587911490942},{"_id":"source/pictures/13px-Dark_Red_x.svg.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1587911490978},{"_id":"source/pictures/13px-Green_check.svg-1587911491234.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1587911491288},{"_id":"source/pictures/13px-Yellow_check.svg.png","hash":"9ded6c97d470f15b15bd8fcb8efbe2b388e4d1cb","modified":1587911490517},{"_id":"source/pictures/280px-PrimaryKey_zht.svg.png","hash":"5e7b24d4f76e895edf95acd03d15b61eea3e0a32","modified":1587913427582},{"_id":"source/_posts/设计数据库的一些认识.md","hash":"ef791fd356f18af5e16549d7fcaf0a1eb9e8faf0","modified":1587909781879},{"_id":"source/pictures/4b9c2ec85d900b1485fad362aabc2349a4d54ad3.svg","hash":"1bc8dc6e50b62f17ac0f88735972cc04724a7cc0","modified":1588086432945},{"_id":"source/pictures/image-20200426223643952.png","hash":"66fb57cd572f6c27f95a5e27302c444531d57569","modified":1587911803972},{"_id":"source/pictures/image-20200426223715720.png","hash":"077e8a044464ba08e58e2cc6a6035eda426e6475","modified":1587911835746},{"_id":"source/pictures/image-20200426224653184.png","hash":"cb9c67069263437662d1a8765b691dd2fe0379c2","modified":1587912413199},{"_id":"source/pictures/image-20200426224741598.png","hash":"4f6603a30fa36100a3d3c7a88e91148cd61c63dd","modified":1587912461613},{"_id":"source/pictures/image-20200426225059906.png","hash":"996d7166bc0ddfde1a7a1ff2d46813eb5cd70aa7","modified":1587912659924},{"_id":"source/pictures/image-20200426225211203.png","hash":"d957fb454a1b08d29905e69d9dd5dd8b4576a0e1","modified":1587912731221},{"_id":"source/pictures/image-20200426225223170.png","hash":"394189505db9ecc4c976a1569a48f69e00db119e","modified":1587912743186},{"_id":"source/pictures/image-20200426225402284.png","hash":"9f2124d12cb452473b756aa2b1d58d2764f0c673","modified":1587912842296},{"_id":"source/pictures/image-20200426230751958.png","hash":"9705bcd5ab1245869bac682e7af051cab66287b6","modified":1587913671991},{"_id":"source/pictures/image-20200426230943516.png","hash":"80bdb88d250a83221c8f4c2c637fd6212eefe768","modified":1587913783534},{"_id":"source/pictures/image-20200426231044849.png","hash":"b04e478a1114950d3b8239b0e0c1d3f67b76ba93","modified":1587913844864},{"_id":"source/pictures/image-20200426231034553.png","hash":"6c6ca5fe211dc9d99cf02b7185e75328affe6434","modified":1587913834576},{"_id":"source/pictures/image-20200427232114257.png","hash":"2751946e99f0a325ad7fe42fbe104142ef763ad9","modified":1588000874272},{"_id":"source/pictures/image-20200427232353749.png","hash":"06936ec0a417b5c69ff14250c8d7a30856fa395b","modified":1588001033767},{"_id":"source/pictures/image-20200427232447340.png","hash":"1cd15f44b59f358877f29b5376d5c37c115c005e","modified":1588001087354},{"_id":"source/pictures/image-20200427232554631.png","hash":"b852423042322138e6edeaa5cff024e4d41ee94d","modified":1588001154664},{"_id":"source/pictures/image-20200427232650317.png","hash":"2b2a13c5fc9790659c881dfece5d99c686f8583a","modified":1588001210349},{"_id":"source/pictures/image-20200428231345713.png","hash":"afdc77941a5f12ac5c5d7a932b0d54d5bcd6c93e","modified":1588086825743},{"_id":"source/pictures/image-20200428230552342.png","hash":"9bd5dd8215cca539be3c246d09116ab440e9b6c9","modified":1588086352382},{"_id":"source/pictures/image-20200428232129091.png","hash":"625fec8947a8d52bf0e469a32dc5c79c2f5214a3","modified":1588087289150},{"_id":"source/pictures/image-20200428232253846.png","hash":"8572ecd407752520701fd12b76c83875545fd1d5","modified":1588087373893},{"_id":"source/pictures/image-20200426223214696.png","hash":"a15e47db17258699605763b660ca9726d98253b0","modified":1587911534757},{"_id":"public/2020/04/26/设计数据库的一些认识/index.html","hash":"579864467b560de8dab81a4ba352f746a3007358","modified":1589957536273},{"_id":"public/pictures/13px-Dark_Red_x.svg-1587911490598.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1589957536273},{"_id":"public/pictures/13px-Green_check.svg-1587911490574.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1589957536273},{"_id":"public/pictures/13px-Dark_Red_x.svg-1587911490730.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1589957536273},{"_id":"public/pictures/13px-Green_check.svg-1587911490720.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1589957536273},{"_id":"public/pictures/13px-Dark_Red_x.svg-1587911490852.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1589957536273},{"_id":"public/pictures/13px-Green_check.svg.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1589957536273},{"_id":"public/pictures/13px-Dark_Red_x.svg.png","hash":"6c0e1ae69d747b49467935d3719627d0e95315cf","modified":1589957536273},{"_id":"public/pictures/13px-Green_check.svg-1587911491234.png","hash":"c5cc5fa2ac79ad7004006cab68d2b48b6954a261","modified":1589957536273},{"_id":"public/pictures/13px-Yellow_check.svg.png","hash":"9ded6c97d470f15b15bd8fcb8efbe2b388e4d1cb","modified":1589957536273},{"_id":"public/pictures/280px-PrimaryKey_zht.svg.png","hash":"5e7b24d4f76e895edf95acd03d15b61eea3e0a32","modified":1589957536273},{"_id":"public/pictures/4b9c2ec85d900b1485fad362aabc2349a4d54ad3.svg","hash":"1bc8dc6e50b62f17ac0f88735972cc04724a7cc0","modified":1589957536273},{"_id":"public/pictures/image-20200426223643952.png","hash":"66fb57cd572f6c27f95a5e27302c444531d57569","modified":1589957536273},{"_id":"public/pictures/image-20200426223715720.png","hash":"077e8a044464ba08e58e2cc6a6035eda426e6475","modified":1589957536273},{"_id":"public/pictures/image-20200426224653184.png","hash":"cb9c67069263437662d1a8765b691dd2fe0379c2","modified":1589957536273},{"_id":"public/pictures/image-20200426224741598.png","hash":"4f6603a30fa36100a3d3c7a88e91148cd61c63dd","modified":1589957536273},{"_id":"public/pictures/image-20200426225059906.png","hash":"996d7166bc0ddfde1a7a1ff2d46813eb5cd70aa7","modified":1589957536273},{"_id":"public/pictures/image-20200426225211203.png","hash":"d957fb454a1b08d29905e69d9dd5dd8b4576a0e1","modified":1589957536273},{"_id":"public/pictures/image-20200426225223170.png","hash":"394189505db9ecc4c976a1569a48f69e00db119e","modified":1589957536273},{"_id":"public/pictures/image-20200426225402284.png","hash":"9f2124d12cb452473b756aa2b1d58d2764f0c673","modified":1589957536273},{"_id":"public/pictures/image-20200426230751958.png","hash":"9705bcd5ab1245869bac682e7af051cab66287b6","modified":1589957536273},{"_id":"public/pictures/image-20200426230943516.png","hash":"80bdb88d250a83221c8f4c2c637fd6212eefe768","modified":1589957536273},{"_id":"public/pictures/image-20200426231044849.png","hash":"b04e478a1114950d3b8239b0e0c1d3f67b76ba93","modified":1589957536273},{"_id":"public/pictures/image-20200426231034553.png","hash":"6c6ca5fe211dc9d99cf02b7185e75328affe6434","modified":1589957536273},{"_id":"public/pictures/image-20200427232114257.png","hash":"2751946e99f0a325ad7fe42fbe104142ef763ad9","modified":1589957536273},{"_id":"public/pictures/image-20200427232353749.png","hash":"06936ec0a417b5c69ff14250c8d7a30856fa395b","modified":1589957536273},{"_id":"public/pictures/image-20200427232447340.png","hash":"1cd15f44b59f358877f29b5376d5c37c115c005e","modified":1589957536273},{"_id":"public/pictures/image-20200427232554631.png","hash":"b852423042322138e6edeaa5cff024e4d41ee94d","modified":1589957536273},{"_id":"public/pictures/image-20200427232650317.png","hash":"2b2a13c5fc9790659c881dfece5d99c686f8583a","modified":1589957536273},{"_id":"public/pictures/image-20200428231345713.png","hash":"afdc77941a5f12ac5c5d7a932b0d54d5bcd6c93e","modified":1589957536273},{"_id":"public/pictures/image-20200428230552342.png","hash":"9bd5dd8215cca539be3c246d09116ab440e9b6c9","modified":1589957536273},{"_id":"public/pictures/image-20200428232129091.png","hash":"625fec8947a8d52bf0e469a32dc5c79c2f5214a3","modified":1589957536273},{"_id":"public/pictures/image-20200428232253846.png","hash":"8572ecd407752520701fd12b76c83875545fd1d5","modified":1589957536273},{"_id":"public/pictures/image-20200426223214696.png","hash":"a15e47db17258699605763b660ca9726d98253b0","modified":1589957536273},{"_id":"source/_posts/KMP算法.md","hash":"a41aefad9664052c05c8320b29116028df3dc438","modified":1595071376433},{"_id":"source/pictures/20140725231726921","hash":"bd66be8dcd8cdd87e032c37bfa00530dd27906c7","modified":1595055718592},{"_id":"source/pictures/20140728110939595","hash":"95231b12f400acc79dff9ed6a106edd285a52a08","modified":1595062853347},{"_id":"source/pictures/20140729181940812","hash":"d3ce7077dbefdf25c19972d2b553990f76014c9d","modified":1595063976243},{"_id":"source/pictures/20140729182154066","hash":"aa45de5d88acf924aee6247a06e1ce0b14b94d78","modified":1595063783984},{"_id":"source/pictures/8394323_1308075859Zfue.jpg","hash":"6a9bf06f64b67779f9156a5cfcba340e333773d8","modified":1595069096183},{"_id":"source/pictures/8394323_13080758591kyV.jpg","hash":"490a25772e3a93527c3ffb5fb9b71645e377ceb6","modified":1595069170101},{"_id":"source/pictures/8394323_13080758591kyV-1595069195969.jpg","hash":"490a25772e3a93527c3ffb5fb9b71645e377ceb6","modified":1595069195974},{"_id":"source/pictures/bg2013050103.png","hash":"2b717e623b919cbb201eddb40b32840d6f901aca","modified":1594974678630},{"_id":"source/pictures/bg2013050105.png","hash":"61af65ffa974557fcba929dfc9edb790f112db4e","modified":1594974761272},{"_id":"source/pictures/bg2013050104.png","hash":"83a552022e33adfc9c1218b6d2fe0bc34d710685","modified":1594974719204},{"_id":"source/pictures/bg2013050106.png","hash":"36d27adf1022d9b9260cd30fdbbcab6382cedfa0","modified":1594974875144},{"_id":"source/pictures/bg2013050107-1594975043794.png","hash":"5c9fed7e60504c6b3af6cfaa69a7d73412760eee","modified":1594975043870},{"_id":"source/pictures/bg2013050107.png","hash":"5c9fed7e60504c6b3af6cfaa69a7d73412760eee","modified":1594974895474},{"_id":"source/pictures/bg2013050109.png","hash":"253f9b51ff6fb0e139583f313d4d0461bffe6519","modified":1594975080871},{"_id":"source/pictures/bg2013050108.png","hash":"ef78b584d26d386c06d5dc2e442f8294c1ca2c83","modified":1594974949383},{"_id":"source/pictures/bg2013050110.png","hash":"a4be08d9bac94619e7d7691f200e7f4fafec2466","modified":1594975307475},{"_id":"source/pictures/bg2013050111.png","hash":"a413a5ce4df7a2488f63abbf6acd26d3dfa77b48","modified":1594975383351},{"_id":"source/pictures/bg2013050112.png","hash":"ce545744202d862617e5d61b3a2a341cac92d71d","modified":1594975451227},{"_id":"source/pictures/bg2013050112-1594975805920.png","hash":"ce545744202d862617e5d61b3a2a341cac92d71d","modified":1594975806031},{"_id":"source/pictures/bg2013050113.png","hash":"b155d4aba0de4a0e80cf4292bad0e39f74831ecd","modified":1594975472571},{"_id":"source/pictures/bg2013050114.png","hash":"de953eeb5e6d77f5f8261311f778643c178b1141","modified":1594975578821},{"_id":"public/categories/Algorithm/index.html","hash":"b42b673ae3c9d95671c1ef096801e6cce8ec1db7","modified":1595487749450},{"_id":"public/archives/2020/07/index.html","hash":"8612b5395a03f944c3b5015482228117bd71f90f","modified":1595487749450},{"_id":"public/tags/Algorithm/index.html","hash":"ecb03f6702439456c64abdc966667f9e56ef9bfe","modified":1595487749450},{"_id":"public/2020/07/17/KMP算法/index.html","hash":"5a3917fd655625f8a7e975ef02f275c9d8406087","modified":1595487749450},{"_id":"public/pictures/20140725231726921","hash":"bd66be8dcd8cdd87e032c37bfa00530dd27906c7","modified":1595070814815},{"_id":"public/pictures/20140729181940812","hash":"d3ce7077dbefdf25c19972d2b553990f76014c9d","modified":1595070814815},{"_id":"public/pictures/20140728110939595","hash":"95231b12f400acc79dff9ed6a106edd285a52a08","modified":1595070814815},{"_id":"public/pictures/8394323_13080758591kyV.jpg","hash":"490a25772e3a93527c3ffb5fb9b71645e377ceb6","modified":1595070814815},{"_id":"public/pictures/20140729182154066","hash":"aa45de5d88acf924aee6247a06e1ce0b14b94d78","modified":1595070814815},{"_id":"public/pictures/8394323_13080758591kyV-1595069195969.jpg","hash":"490a25772e3a93527c3ffb5fb9b71645e377ceb6","modified":1595070814815},{"_id":"public/pictures/8394323_1308075859Zfue.jpg","hash":"6a9bf06f64b67779f9156a5cfcba340e333773d8","modified":1595070814815},{"_id":"public/pictures/bg2013050103.png","hash":"2b717e623b919cbb201eddb40b32840d6f901aca","modified":1595070814815},{"_id":"public/pictures/bg2013050105.png","hash":"61af65ffa974557fcba929dfc9edb790f112db4e","modified":1595070814815},{"_id":"public/pictures/bg2013050107-1594975043794.png","hash":"5c9fed7e60504c6b3af6cfaa69a7d73412760eee","modified":1595070814815},{"_id":"public/pictures/bg2013050106.png","hash":"36d27adf1022d9b9260cd30fdbbcab6382cedfa0","modified":1595070814815},{"_id":"public/pictures/bg2013050107.png","hash":"5c9fed7e60504c6b3af6cfaa69a7d73412760eee","modified":1595070814815},{"_id":"public/pictures/bg2013050104.png","hash":"83a552022e33adfc9c1218b6d2fe0bc34d710685","modified":1595070814815},{"_id":"public/pictures/bg2013050108.png","hash":"ef78b584d26d386c06d5dc2e442f8294c1ca2c83","modified":1595070814815},{"_id":"public/pictures/bg2013050109.png","hash":"253f9b51ff6fb0e139583f313d4d0461bffe6519","modified":1595070814815},{"_id":"public/pictures/bg2013050111.png","hash":"a413a5ce4df7a2488f63abbf6acd26d3dfa77b48","modified":1595070814815},{"_id":"public/pictures/bg2013050112.png","hash":"ce545744202d862617e5d61b3a2a341cac92d71d","modified":1595070814815},{"_id":"public/pictures/bg2013050110.png","hash":"a4be08d9bac94619e7d7691f200e7f4fafec2466","modified":1595070814815},{"_id":"public/pictures/bg2013050112-1594975805920.png","hash":"ce545744202d862617e5d61b3a2a341cac92d71d","modified":1595070814815},{"_id":"public/pictures/bg2013050113.png","hash":"b155d4aba0de4a0e80cf4292bad0e39f74831ecd","modified":1595070814815},{"_id":"public/pictures/bg2013050114.png","hash":"de953eeb5e6d77f5f8261311f778643c178b1141","modified":1595070814815},{"_id":"source/_posts/什么是IoC.md","hash":"cfa42eb10a9f3777c00251a598f19572aa571e8d","modified":1595387849846},{"_id":"source/pictures/image-20200514143731277-1595486755603.png","hash":"7e5972ef65941e399096511ff6d6352f94520c5a","modified":1595486755615},{"_id":"source/pictures/image-20200514143731277.png","hash":"7e5972ef65941e399096511ff6d6352f94520c5a","modified":1595486248023},{"_id":"source/_posts/JSON与Java对象的转换.md","hash":"2106b45a09146dacdc3483120f4de802dac25cb1","modified":1595487641280},{"_id":"source/pictures/image-20200721113245712.png","hash":"7c6f5009dbfdfa0c19160a6d23ababb543310187","modified":1595302365812},{"_id":"public/2020/07/22/什么是IoC/index.html","hash":"25d0d892b7fac4bb08a05e5d55fda5790849317b","modified":1595487623281},{"_id":"public/tags/json/index.html","hash":"f1dad15191413f947816a7da071b6e1166fd7c26","modified":1595487749450},{"_id":"public/2020/07/23/JSON与Java对象的转换/index.html","hash":"8d23b598a26ae2f091a02fdcec7723f4bd6406ea","modified":1595487749450},{"_id":"public/pictures/image-20200514143731277-1595486755603.png","hash":"7e5972ef65941e399096511ff6d6352f94520c5a","modified":1595487623281},{"_id":"public/pictures/image-20200514143731277.png","hash":"7e5972ef65941e399096511ff6d6352f94520c5a","modified":1595487623281},{"_id":"public/pictures/image-20200721113245712.png","hash":"7c6f5009dbfdfa0c19160a6d23ababb543310187","modified":1595487623281}],"Category":[{"name":"Java","_id":"ck8x8a1g10005fwuq5udm0l9w"},{"name":"Algorithm","_id":"ckcrjzdm30001souq13d095n1"}],"Data":[],"Page":[{"_content":"+layout: false\n+---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>404</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"返回\"></script> \n    </body>\n</html>","source":"404.html","raw":"+layout: false\n+---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>404</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"返回\"></script> \n    </body>\n</html>","date":"2020-03-29T09:44:38.366Z","updated":"2020-03-29T09:44:38.366Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ck8x8a1b00000fwuq8yt07fx3","content":"+layout: false\n+---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>404</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"返回\"></script> \n    </body>\n</html>","site":{"data":{}},"length":20,"excerpt":"","more":"+layout: false\n+---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>404</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"返回\"></script> \n    </body>\n</html>"},{"title":"categories","date":"2020-03-29T09:40:35.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-03-29 17:40:35\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-03-29T09:41:10.837Z","path":"categories/index.html","layout":"page","_id":"ck8x8a1ft0002fwuq3uth2vyf","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tags","date":"2020-03-29T09:39:17.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-03-29 17:39:17\ntype: \"tags\"\ncomments: false\n---\n","updated":"2020-03-29T09:40:15.639Z","path":"tags/index.html","layout":"page","_id":"ck8x8a1fy0004fwuq44frf02q","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"HashMap实现原理及其重要方法","date":"2020-04-05T15:42:08.000Z","typora-copy-images-to":"..\\..\\juliajiang\\source\\pictures","_content":"\n本文主要介绍了 HashMap 的底层实现结构、存储结构以及JDK1.8中相关的优化。同时，也分析了一些HashMap的重要方法，比如哈希桶索引位置、查询、新增、扩容。另外涉及几个细节性的问题，比如加载因子、HashMap与HashTable的区别等等。\n\n<!--more-->\n\n## 1. 部分源码分析\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n    private static final long serialVersionUID = 362498820763181265L;\n    \n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //HashMap初始化长度 16\n\n    static final int MAXIMUM_CAPACITY = 1 << 30;\t\t//HashMap 最大长度\n\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\t\t//默认的加载因子\n\n    static final int TREEIFY_THRESHOLD = 8;\t\t\t\t//转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构\n\n    static final int UNTREEIFY_THRESHOLD = 6;\t\t\t//转换链表的临界值，当链表长度小于此值时，会将红黑树结构转换为链表\n\n    static final int MIN_TREEIFY_CAPACITY = 64;\t\t\t//最小树容量\n    \n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\t\t\t\t//用来定位数组索引位置\t\t\t\t\t\t\t\n        final K key;\n        V value;\n        Node<K,V> next;\t\t\t\t//链表的下一个node\n\t\t...\n    }\n    \n    transient Node<K,V>[] table;\t// Node[] table的初始化长度length(默认值是16)\n    \n    transient Set<Map.Entry<K,V>> entrySet;\n    \n    transient int size;\t\t\t// HashMap中实际存在的键值对数量\n    \n    transient int modCount;\t\t// 记录HashMap内部结构发生变化的次数\n    \n    int threshold;\t\t\t\t// HashMap所能容纳的最大数据量的Node(键值对)个数\n    \t\t\t\t\t\t\t// threshold = length * Load factor \n    \n    final float loadFactor;\t\t// 负载因子(默认值是0.75)\n    \n    // Hash 算法，共三步\n    static final int hash(Object key) {\n        int h;\n        // h = key.hashCode() 为第一步 取hashCode值\n        // h ^ (h >>> 16)  为第二步 高位参与运算\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n    \n    /*\n    // jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n    // 计算该对象应该保存在table数组的哪个索引处\n    static int indexFor(int h, int length) {  \n    \t//第三步 取模运算\n     \treturn h & (length-1);  \n\t}\n    */\n    \n    \n```\n\n\n\n## 2. HashMap 底层是如何实现的？JDK1.8如何优化？\n\n从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。\n\n<img src=\"/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\nJDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。\n\n这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？\n\n(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。Node 源码如下：\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;    //用来定位数组索引位置\n        final K key;\n        V value;\n        Node<K,V> next;   //链表的下一个node\n\n        Node(int hash, K key, V value, Node<K,V> next) { ... }\n        public final K getKey(){ ... }\n        public final V getValue() { ... }\n        public final String toString() { ... }\n        public final int hashCode() { ... }\n        public final V setValue(V newValue) { ... }\n        public final boolean equals(Object o) { ... }\n}\n```\n\n(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如如下代码：\n\n```java\n map.put(\"julia\",\"jiang\");\n```\n\n系统将调用 ``\"julia\"`` 这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（具体见哈希桶数组索引位置分析）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。\n\n## 3. 什么是加载因子？加载因子为什么是0.75？\n\n加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。\n\n那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？\n\n这其实是出于容量和性能之间平衡的结果：\n\n1. 当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；\n2. 而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。\n\n所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。\n\n## 4. HashMap源码中有哪些重要方法？\n\n### 4.1 确定哈希桶数组索引位置\n\n不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):\n\n```java\n方法一：\nstatic final int hash(Object key) {   //jdk1.8\n     int h;\n     // h = key.hashCode() 为第一步 取hashCode值\n     // h ^ (h >>> 16)  为第二步 高位参与运算\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n方法二：\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n     return h & (length-1);  //第三步 取模运算\n}\n```\n\n这里的Hash算法本质上就是三步：**取key的hashCode值、高位运算、取模运算**。\n\n对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。\n\n这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。\n\n下面举例说明下，n为table的长度。\n\n<img src=\"/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n### 4.2 查询\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    //对 key 进行哈希操作\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; \n    Node<K,V> first, e; \n    int n; \n    K k;\n    //非空判断\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        //判断第一个元素是否是要查询的元素\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //下一个节点非空判断\n        if ((e = first.next) != null) {\n            //如果第一个节点是树结构，则使用 getTreeNode 直接获取相应的数据\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            do { //非树结构，循环节点判断\n                if (e.hash == hash &&   //hash相等，并且 key相等，则返回此节点\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。\n\n### 4.3 新增\n\n```java\npublic V put(K key, V value) {\n    //对 key 进行哈希操作\n    return putVal(hash(key), key, value, false, true);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; \n    Node<K,V> p; \n    int n, i;\n    //哈希表为空则创建表\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //根据 key 的哈希值计算出要插入的数组索引i\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //如果 tab[i] 为 null，则直接插入\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; \n        K k;\n        //如果key相等，直接覆盖 value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        //如果 key 不存在，判断是否为红黑树\n        else if (p instanceof TreeNode)\n            //红黑树直接插入键值对\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            //为链表结构，循环准备插入\n            for (int binCount = 0; ; ++binCount) {\n                //下一个元素为空时\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    //链表长度大于 8 时转换为红黑树进行处理\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //key 已经存在直接覆盖 value\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    //超过最大容量，扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n新增方法的执行流程如下：\n\n![preview](/pictures/58e67eae921e4b431782c07444af824e_r.jpg)\n\n### 4.4 扩容\n\n[参考博文](https://zhuanlan.zhihu.com/p/21673805)\n\n#### JDK1.7 的扩容\n\n扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。\n\n我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。\n\n```java\n 1 void resize(int newCapacity) {   //传入新的容量\n 2     Entry[] oldTable = table;    //引用扩容前的Entry数组\n 3     int oldCapacity = oldTable.length;         \n 4     if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了\n 5         threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n 6         return;\n 7     }\n 8  \n 9     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组\n10     transfer(newTable);                         //！！将数据转移到新的Entry数组里\n11     table = newTable;                           //HashMap的table属性引用新的Entry数组\n12     threshold = (int)(newCapacity * loadFactor);//修改阈值\n13 }\n```\n\n这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。\n\n```java\nvoid transfer(Entry[] newTable) {\n   Entry[] src = table;                   //src引用了旧的Entry数组\n   int newCapacity = newTable.length;\n   for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组\n       Entry<K,V> e = src[j];             //取得旧Entry数组的每个元素\n       if (e != null) {\n           src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n           do {\n               Entry<K,V> next = e.next;\n               int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n               e.next = newTable[i]; //标记[1]\n               newTable[i] = e;      //将元素放在数组上\n               e = next;             //访问下一个Entry链上的元素\n           } while (e != null);\n       }\n   }\n}\n\n// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n// 计算该对象应该保存在table数组的哪个索引处\nstatic int indexFor(int h, int length) {  \n\t//第三步 取模运算\n \treturn h & (length-1);  \n}\n// 确定哈希桶数组索引位置\nstatic final int hash(Object key) {\n    int h;\n    // h = key.hashCode() 为第一步 取hashCode值\n    // h ^ (h >>> 16)  为第二步 高位参与运算\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\nnewTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。下面举个例子说明下扩容过程。\n\n这里我们假设 ``hashCode()`` 的哈希算法就是简单的 key % (数组长度)。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。\n\n接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。\n\n![preview](/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg)\n\n#### JDK1.8 在扩容方面的优化\n\n下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。\n\n![preview](/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg)\n\n元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：\n\n![img](/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png)\n\n因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：\n\n![img](/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png)\n\n这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。\n\n#### JDK1.8 中扩容源码\n\n```java\nfinal Node<K,V>[] resize() {\n    //扩容前数组\n    Node<K,V>[] oldTab = table;\n    //扩容前数组的大小和阈值\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    //预定义新数组的大小和阈值\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        //超过最大值就不可以扩容了\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //扩容容量为当前容量的两倍，但不能超过MAXIMUM_CAPACITY\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    //前数组没有数据，前数组大小为0，新数组容量设置为初始阈值\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    //初始阈值为0，则使用默认的初始化容器\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //如果新容量等于0\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //开始赋值，将新的容量赋值给 table\n    table = newTab;\n    //原数据不为空，将原数据赋值到table中\n    if (oldTab != null) {\n        //根据容量循环数组，赋值非空元素到新table\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                //如果链表只有一个，则进行直接赋值\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                //如果是红黑树存储\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    //链表复制，JDK 1.8 扩容优化部分\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        //原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        //原索引 + oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    //将原索引放到哈希桶中\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    //将原索引+oldCap 放到哈希桶中\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n## 6. HashMap 多线程操作导致死循环问题\n\n[详细分析](https://coolshell.cn/articles/9606.html)\n\n主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。\n\n## 7. HashMap 和 HashTable的区别\n\n1. **线程是否安全：** HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\n2. **效率：** 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；\n3. **对Null key 和Null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n4. **初始容量大小和每次扩充容量大小的不同 ：** ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。\n5. **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\nHashMap 中带有初始化容量的构造函数：\n\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\t // 保证HashMap总是使用2的幂作为哈希表大小\n}\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n更多关于 HashMap 的知识点参考 [这里](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-2Java集合?id=_226-hashmap-和-hashset区别)\n\n","source":"_posts/HashMap实现原理及其重要方法.md","raw":"---\ntitle: HashMap实现原理及其重要方法\ndate: 2020-04-05 23:42:08\ntags:\n  - HashMap\n  - Java\ncategories: Java\ntypora-copy-images-to: ..\\..\\juliajiang\\source\\pictures\n\n---\n\n本文主要介绍了 HashMap 的底层实现结构、存储结构以及JDK1.8中相关的优化。同时，也分析了一些HashMap的重要方法，比如哈希桶索引位置、查询、新增、扩容。另外涉及几个细节性的问题，比如加载因子、HashMap与HashTable的区别等等。\n\n<!--more-->\n\n## 1. 部分源码分析\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n    private static final long serialVersionUID = 362498820763181265L;\n    \n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //HashMap初始化长度 16\n\n    static final int MAXIMUM_CAPACITY = 1 << 30;\t\t//HashMap 最大长度\n\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\t\t//默认的加载因子\n\n    static final int TREEIFY_THRESHOLD = 8;\t\t\t\t//转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构\n\n    static final int UNTREEIFY_THRESHOLD = 6;\t\t\t//转换链表的临界值，当链表长度小于此值时，会将红黑树结构转换为链表\n\n    static final int MIN_TREEIFY_CAPACITY = 64;\t\t\t//最小树容量\n    \n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\t\t\t\t//用来定位数组索引位置\t\t\t\t\t\t\t\n        final K key;\n        V value;\n        Node<K,V> next;\t\t\t\t//链表的下一个node\n\t\t...\n    }\n    \n    transient Node<K,V>[] table;\t// Node[] table的初始化长度length(默认值是16)\n    \n    transient Set<Map.Entry<K,V>> entrySet;\n    \n    transient int size;\t\t\t// HashMap中实际存在的键值对数量\n    \n    transient int modCount;\t\t// 记录HashMap内部结构发生变化的次数\n    \n    int threshold;\t\t\t\t// HashMap所能容纳的最大数据量的Node(键值对)个数\n    \t\t\t\t\t\t\t// threshold = length * Load factor \n    \n    final float loadFactor;\t\t// 负载因子(默认值是0.75)\n    \n    // Hash 算法，共三步\n    static final int hash(Object key) {\n        int h;\n        // h = key.hashCode() 为第一步 取hashCode值\n        // h ^ (h >>> 16)  为第二步 高位参与运算\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n    \n    /*\n    // jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n    // 计算该对象应该保存在table数组的哪个索引处\n    static int indexFor(int h, int length) {  \n    \t//第三步 取模运算\n     \treturn h & (length-1);  \n\t}\n    */\n    \n    \n```\n\n\n\n## 2. HashMap 底层是如何实现的？JDK1.8如何优化？\n\n从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。\n\n<img src=\"/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\nJDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。\n\n这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？\n\n(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。Node 源码如下：\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;    //用来定位数组索引位置\n        final K key;\n        V value;\n        Node<K,V> next;   //链表的下一个node\n\n        Node(int hash, K key, V value, Node<K,V> next) { ... }\n        public final K getKey(){ ... }\n        public final V getValue() { ... }\n        public final String toString() { ... }\n        public final int hashCode() { ... }\n        public final V setValue(V newValue) { ... }\n        public final boolean equals(Object o) { ... }\n}\n```\n\n(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如如下代码：\n\n```java\n map.put(\"julia\",\"jiang\");\n```\n\n系统将调用 ``\"julia\"`` 这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（具体见哈希桶数组索引位置分析）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。\n\n## 3. 什么是加载因子？加载因子为什么是0.75？\n\n加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。\n\n那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？\n\n这其实是出于容量和性能之间平衡的结果：\n\n1. 当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；\n2. 而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。\n\n所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。\n\n## 4. HashMap源码中有哪些重要方法？\n\n### 4.1 确定哈希桶数组索引位置\n\n不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):\n\n```java\n方法一：\nstatic final int hash(Object key) {   //jdk1.8\n     int h;\n     // h = key.hashCode() 为第一步 取hashCode值\n     // h ^ (h >>> 16)  为第二步 高位参与运算\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n方法二：\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n     return h & (length-1);  //第三步 取模运算\n}\n```\n\n这里的Hash算法本质上就是三步：**取key的hashCode值、高位运算、取模运算**。\n\n对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。\n\n这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。\n\n下面举例说明下，n为table的长度。\n\n<img src=\"/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n### 4.2 查询\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    //对 key 进行哈希操作\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; \n    Node<K,V> first, e; \n    int n; \n    K k;\n    //非空判断\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        //判断第一个元素是否是要查询的元素\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //下一个节点非空判断\n        if ((e = first.next) != null) {\n            //如果第一个节点是树结构，则使用 getTreeNode 直接获取相应的数据\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            do { //非树结构，循环节点判断\n                if (e.hash == hash &&   //hash相等，并且 key相等，则返回此节点\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。\n\n### 4.3 新增\n\n```java\npublic V put(K key, V value) {\n    //对 key 进行哈希操作\n    return putVal(hash(key), key, value, false, true);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; \n    Node<K,V> p; \n    int n, i;\n    //哈希表为空则创建表\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //根据 key 的哈希值计算出要插入的数组索引i\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //如果 tab[i] 为 null，则直接插入\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; \n        K k;\n        //如果key相等，直接覆盖 value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        //如果 key 不存在，判断是否为红黑树\n        else if (p instanceof TreeNode)\n            //红黑树直接插入键值对\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            //为链表结构，循环准备插入\n            for (int binCount = 0; ; ++binCount) {\n                //下一个元素为空时\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    //链表长度大于 8 时转换为红黑树进行处理\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //key 已经存在直接覆盖 value\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    //超过最大容量，扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n新增方法的执行流程如下：\n\n![preview](/pictures/58e67eae921e4b431782c07444af824e_r.jpg)\n\n### 4.4 扩容\n\n[参考博文](https://zhuanlan.zhihu.com/p/21673805)\n\n#### JDK1.7 的扩容\n\n扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。\n\n我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。\n\n```java\n 1 void resize(int newCapacity) {   //传入新的容量\n 2     Entry[] oldTable = table;    //引用扩容前的Entry数组\n 3     int oldCapacity = oldTable.length;         \n 4     if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了\n 5         threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n 6         return;\n 7     }\n 8  \n 9     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组\n10     transfer(newTable);                         //！！将数据转移到新的Entry数组里\n11     table = newTable;                           //HashMap的table属性引用新的Entry数组\n12     threshold = (int)(newCapacity * loadFactor);//修改阈值\n13 }\n```\n\n这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。\n\n```java\nvoid transfer(Entry[] newTable) {\n   Entry[] src = table;                   //src引用了旧的Entry数组\n   int newCapacity = newTable.length;\n   for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组\n       Entry<K,V> e = src[j];             //取得旧Entry数组的每个元素\n       if (e != null) {\n           src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n           do {\n               Entry<K,V> next = e.next;\n               int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n               e.next = newTable[i]; //标记[1]\n               newTable[i] = e;      //将元素放在数组上\n               e = next;             //访问下一个Entry链上的元素\n           } while (e != null);\n       }\n   }\n}\n\n// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n// 计算该对象应该保存在table数组的哪个索引处\nstatic int indexFor(int h, int length) {  \n\t//第三步 取模运算\n \treturn h & (length-1);  \n}\n// 确定哈希桶数组索引位置\nstatic final int hash(Object key) {\n    int h;\n    // h = key.hashCode() 为第一步 取hashCode值\n    // h ^ (h >>> 16)  为第二步 高位参与运算\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\nnewTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。下面举个例子说明下扩容过程。\n\n这里我们假设 ``hashCode()`` 的哈希算法就是简单的 key % (数组长度)。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。\n\n接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。\n\n![preview](/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg)\n\n#### JDK1.8 在扩容方面的优化\n\n下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。\n\n![preview](/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg)\n\n元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：\n\n![img](/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png)\n\n因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：\n\n![img](/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png)\n\n这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。\n\n#### JDK1.8 中扩容源码\n\n```java\nfinal Node<K,V>[] resize() {\n    //扩容前数组\n    Node<K,V>[] oldTab = table;\n    //扩容前数组的大小和阈值\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    //预定义新数组的大小和阈值\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        //超过最大值就不可以扩容了\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //扩容容量为当前容量的两倍，但不能超过MAXIMUM_CAPACITY\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    //前数组没有数据，前数组大小为0，新数组容量设置为初始阈值\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    //初始阈值为0，则使用默认的初始化容器\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //如果新容量等于0\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //开始赋值，将新的容量赋值给 table\n    table = newTab;\n    //原数据不为空，将原数据赋值到table中\n    if (oldTab != null) {\n        //根据容量循环数组，赋值非空元素到新table\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                //如果链表只有一个，则进行直接赋值\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                //如果是红黑树存储\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    //链表复制，JDK 1.8 扩容优化部分\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        //原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        //原索引 + oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    //将原索引放到哈希桶中\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    //将原索引+oldCap 放到哈希桶中\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n## 6. HashMap 多线程操作导致死循环问题\n\n[详细分析](https://coolshell.cn/articles/9606.html)\n\n主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。\n\n## 7. HashMap 和 HashTable的区别\n\n1. **线程是否安全：** HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\n2. **效率：** 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；\n3. **对Null key 和Null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n4. **初始容量大小和每次扩充容量大小的不同 ：** ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。\n5. **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\nHashMap 中带有初始化容量的构造函数：\n\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\t // 保证HashMap总是使用2的幂作为哈希表大小\n}\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n更多关于 HashMap 的知识点参考 [这里](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-2Java集合?id=_226-hashmap-和-hashset区别)\n\n","slug":"HashMap实现原理及其重要方法","published":1,"updated":"2020-04-13T02:22:32.224Z","_id":"ck8x8a1fo0001fwuq3y1u7j0i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要介绍了 HashMap 的底层实现结构、存储结构以及JDK1.8中相关的优化。同时，也分析了一些HashMap的重要方法，比如哈希桶索引位置、查询、新增、扩容。另外涉及几个细节性的问题，比如加载因子、HashMap与HashTable的区别等等。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-部分源码分析\"><a href=\"#1-部分源码分析\" class=\"headerlink\" title=\"1. 部分源码分析\"></a>1. 部分源码分析</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">//HashMap初始化长度 16</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;\t\t<span class=\"comment\">//HashMap 最大长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;\t\t<span class=\"comment\">//默认的加载因子</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;\t\t\t\t<span class=\"comment\">//转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;\t\t\t<span class=\"comment\">//转换链表的临界值，当链表长度小于此值时，会将红黑树结构转换为链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;\t\t\t<span class=\"comment\">//最小树容量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;\t\t\t\t<span class=\"comment\">//用来定位数组索引位置\t\t\t\t\t\t\t</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;\t\t\t\t<span class=\"comment\">//链表的下一个node</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;\t<span class=\"comment\">// Node[] table的初始化长度length(默认值是16)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;\t\t\t<span class=\"comment\">// HashMap中实际存在的键值对数量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;\t\t<span class=\"comment\">// 记录HashMap内部结构发生变化的次数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> threshold;\t\t\t\t<span class=\"comment\">// HashMap所能容纳的最大数据量的Node(键值对)个数</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t<span class=\"comment\">// threshold = length * Load factor </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;\t\t<span class=\"comment\">// 负载因子(默认值是0.75)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Hash 算法，共三步</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"comment\">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class=\"line\">        <span class=\"comment\">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    // jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\"><span class=\"comment\">    // 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class=\"line\"><span class=\"comment\">    static int indexFor(int h, int length) &#123;  </span></span><br><span class=\"line\"><span class=\"comment\">    \t//第三步 取模运算</span></span><br><span class=\"line\"><span class=\"comment\">     \treturn h &amp; (length-1);  </span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-HashMap-底层是如何实现的？JDK1-8如何优化？\"><a href=\"#2-HashMap-底层是如何实现的？JDK1-8如何优化？\" class=\"headerlink\" title=\"2. HashMap 底层是如何实现的？JDK1.8如何优化？\"></a>2. HashMap 底层是如何实现的？JDK1.8如何优化？</h2><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>\n<img src=\"/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<p>JDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p>\n<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>\n<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。Node 源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;    <span class=\"comment\">//用来定位数组索引位置</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;   <span class=\"comment\">//链表的下一个node</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span></span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"julia\"</span>,<span class=\"string\">\"jiang\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>系统将调用 <code>&quot;julia&quot;</code> 这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（具体见哈希桶数组索引位置分析）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>\n<h2 id=\"3-什么是加载因子？加载因子为什么是0-75？\"><a href=\"#3-什么是加载因子？加载因子为什么是0-75？\" class=\"headerlink\" title=\"3. 什么是加载因子？加载因子为什么是0.75？\"></a>3. 什么是加载因子？加载因子为什么是0.75？</h2><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p>\n<p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p>\n<p>这其实是出于容量和性能之间平衡的结果：</p>\n<ol>\n<li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li>\n<li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li>\n</ol>\n<p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p>\n<h2 id=\"4-HashMap源码中有哪些重要方法？\"><a href=\"#4-HashMap源码中有哪些重要方法？\" class=\"headerlink\" title=\"4. HashMap源码中有哪些重要方法？\"></a>4. HashMap源码中有哪些重要方法？</h2><h3 id=\"4-1-确定哈希桶数组索引位置\"><a href=\"#4-1-确定哈希桶数组索引位置\" class=\"headerlink\" title=\"4.1 确定哈希桶数组索引位置\"></a>4.1 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;   <span class=\"comment\">//jdk1.8</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">     <span class=\"comment\">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class=\"line\">     <span class=\"comment\">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法二：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  <span class=\"comment\">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  <span class=\"comment\">//第三步 取模运算</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>\n<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>\n<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>\n<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>\n<p>下面举例说明下，n为table的长度。</p>\n<img src=\"/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n<h3 id=\"4-2-查询\"><a href=\"#4-2-查询\" class=\"headerlink\" title=\"4.2 查询\"></a>4.2 查询</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">//对 key 进行哈希操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; </span><br><span class=\"line\">    Node&lt;K,V&gt; first, e; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n; </span><br><span class=\"line\">    K k;</span><br><span class=\"line\">    <span class=\"comment\">//非空判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断第一个元素是否是要查询的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//下一个节点非空判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123; <span class=\"comment\">//非树结构，循环节点判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;   <span class=\"comment\">//hash相等，并且 key相等，则返回此节点</span></span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p>\n<h3 id=\"4-3-新增\"><a href=\"#4-3-新增\" class=\"headerlink\" title=\"4.3 新增\"></a>4.3 新增</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对 key 进行哈希操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; </span><br><span class=\"line\">    Node&lt;K,V&gt; p; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表为空则创建表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">//根据 key 的哈希值计算出要插入的数组索引i</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">//如果 tab[i] 为 null，则直接插入</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; </span><br><span class=\"line\">        K k;</span><br><span class=\"line\">        <span class=\"comment\">//如果key相等，直接覆盖 value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">//如果 key 不存在，判断是否为红黑树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">//红黑树直接插入键值对</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//为链表结构，循环准备插入</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//下一个元素为空时</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//链表长度大于 8 时转换为红黑树进行处理</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//key 已经存在直接覆盖 value</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">//超过最大容量，扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新增方法的执行流程如下：</p>\n<p><img src=\"/pictures/58e67eae921e4b431782c07444af824e_r.jpg\" alt=\"preview\"></p>\n<h3 id=\"4-4-扩容\"><a href=\"#4-4-扩容\" class=\"headerlink\" title=\"4.4 扩容\"></a>4.4 扩容</h3><p><a href=\"https://zhuanlan.zhihu.com/p/21673805\" target=\"_blank\" rel=\"noopener\">参考博文</a></p>\n<h4 id=\"JDK1-7-的扩容\"><a href=\"#JDK1-7-的扩容\" class=\"headerlink\" title=\"JDK1.7 的扩容\"></a>JDK1.7 的扩容</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>\n<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;   <span class=\"comment\">//传入新的容量</span></span><br><span class=\"line\"> <span class=\"number\">2</span>     Entry[] oldTable = table;    <span class=\"comment\">//引用扩容前的Entry数组</span></span><br><span class=\"line\"> <span class=\"number\">3</span>     <span class=\"keyword\">int</span> oldCapacity = oldTable.length;         </span><br><span class=\"line\"> <span class=\"number\">4</span>     <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class=\"comment\">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class=\"line\"> <span class=\"number\">5</span>         threshold = Integer.MAX_VALUE; <span class=\"comment\">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class=\"line\"> <span class=\"number\">6</span>         <span class=\"keyword\">return</span>;</span><br><span class=\"line\"> <span class=\"number\">7</span>     &#125;</span><br><span class=\"line\"> <span class=\"number\">8</span>  </span><br><span class=\"line\"> <span class=\"number\">9</span>     Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];  <span class=\"comment\">//初始化一个新的Entry数组</span></span><br><span class=\"line\"><span class=\"number\">10</span>     transfer(newTable);                         <span class=\"comment\">//！！将数据转移到新的Entry数组里</span></span><br><span class=\"line\"><span class=\"number\">11</span>     table = newTable;                           <span class=\"comment\">//HashMap的table属性引用新的Entry数组</span></span><br><span class=\"line\"><span class=\"number\">12</span>     threshold = (<span class=\"keyword\">int</span>)(newCapacity * loadFactor);<span class=\"comment\">//修改阈值</span></span><br><span class=\"line\"><span class=\"number\">13</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable)</span> </span>&#123;</span><br><span class=\"line\">   Entry[] src = table;                   <span class=\"comment\">//src引用了旧的Entry数组</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> newCapacity = newTable.length;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; j++) &#123; <span class=\"comment\">//遍历旧的Entry数组</span></span><br><span class=\"line\">       Entry&lt;K,V&gt; e = src[j];             <span class=\"comment\">//取得旧Entry数组的每个元素</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           src[j] = <span class=\"keyword\">null</span>;<span class=\"comment\">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class=\"line\">           <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">               Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity); <span class=\"comment\">//！！重新计算每个元素在数组中的位置</span></span><br><span class=\"line\">               e.next = newTable[i]; <span class=\"comment\">//标记[1]</span></span><br><span class=\"line\">               newTable[i] = e;      <span class=\"comment\">//将元素放在数组上</span></span><br><span class=\"line\">               e = next;             <span class=\"comment\">//访问下一个Entry链上的元素</span></span><br><span class=\"line\">           &#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\"><span class=\"comment\">// 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  </span><br><span class=\"line\">\t<span class=\"comment\">//第三步 取模运算</span></span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 确定哈希桶数组索引位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class=\"line\">    <span class=\"comment\">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。下面举个例子说明下扩容过程。</p>\n<p>这里我们假设 <code>hashCode()</code> 的哈希算法就是简单的 key % (数组长度)。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。</p>\n<p>接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>\n<p><img src=\"/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg\" alt=\"preview\"></p>\n<h4 id=\"JDK1-8-在扩容方面的优化\"><a href=\"#JDK1-8-在扩容方面的优化\" class=\"headerlink\" title=\"JDK1.8 在扩容方面的优化\"></a>JDK1.8 在扩容方面的优化</h4><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>\n<p><img src=\"/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg\" alt=\"preview\"></p>\n<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>\n<p><img src=\"/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png\" alt=\"img\"></p>\n<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>\n<p><img src=\"/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png\" alt=\"img\"></p>\n<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>\n<h4 id=\"JDK1-8-中扩容源码\"><a href=\"#JDK1-8-中扩容源码\" class=\"headerlink\" title=\"JDK1.8 中扩容源码\"></a>JDK1.8 中扩容源码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//扩容前数组</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"comment\">//扩容前数组的大小和阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"comment\">//预定义新数组的大小和阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//超过最大值就不可以扩容了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//扩容容量为当前容量的两倍，但不能超过MAXIMUM_CAPACITY</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//前数组没有数据，前数组大小为0，新数组容量设置为初始阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">//初始阈值为0，则使用默认的初始化容器</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果新容量等于0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    <span class=\"comment\">//开始赋值，将新的容量赋值给 table</span></span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"comment\">//原数据不为空，将原数据赋值到table中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据容量循环数组，赋值非空元素到新table</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">//如果链表只有一个，则进行直接赋值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">//如果是红黑树存储</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    <span class=\"comment\">//链表复制，JDK 1.8 扩容优化部分</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"comment\">//原索引</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">//原索引 + oldCap</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//将原索引放到哈希桶中</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//将原索引+oldCap 放到哈希桶中</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-HashMap-多线程操作导致死循环问题\"><a href=\"#6-HashMap-多线程操作导致死循环问题\" class=\"headerlink\" title=\"6. HashMap 多线程操作导致死循环问题\"></a>6. HashMap 多线程操作导致死循环问题</h2><p><a href=\"https://coolshell.cn/articles/9606.html\" target=\"_blank\" rel=\"noopener\">详细分析</a></p>\n<p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>\n<h2 id=\"7-HashMap-和-HashTable的区别\"><a href=\"#7-HashMap-和-HashTable的区别\" class=\"headerlink\" title=\"7. HashMap 和 HashTable的区别\"></a>7. HashMap 和 HashTable的区别</h2><ol>\n<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>\n<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>\n<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>\n<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</li>\n<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ol>\n<p>HashMap 中带有初始化容量的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);\t <span class=\"comment\">// 保证HashMap总是使用2的幂作为哈希表大小</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更多关于 HashMap 的知识点参考 <a href=\"https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-2Java集合?id=_226-hashmap-和-hashset区别\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n","site":{"data":{}},"length":12877,"excerpt":"<p>本文主要介绍了 HashMap 的底层实现结构、存储结构以及JDK1.8中相关的优化。同时，也分析了一些HashMap的重要方法，比如哈希桶索引位置、查询、新增、扩容。另外涉及几个细节性的问题，比如加载因子、HashMap与HashTable的区别等等。</p>","more":"<h2 id=\"1-部分源码分析\"><a href=\"#1-部分源码分析\" class=\"headerlink\" title=\"1. 部分源码分析\"></a>1. 部分源码分析</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">//HashMap初始化长度 16</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;\t\t<span class=\"comment\">//HashMap 最大长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;\t\t<span class=\"comment\">//默认的加载因子</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;\t\t\t\t<span class=\"comment\">//转换红黑树的临界值，当链表长度大于此值时，会把链表结构转换为红黑树结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;\t\t\t<span class=\"comment\">//转换链表的临界值，当链表长度小于此值时，会将红黑树结构转换为链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;\t\t\t<span class=\"comment\">//最小树容量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;\t\t\t\t<span class=\"comment\">//用来定位数组索引位置\t\t\t\t\t\t\t</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;\t\t\t\t<span class=\"comment\">//链表的下一个node</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;\t<span class=\"comment\">// Node[] table的初始化长度length(默认值是16)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;\t\t\t<span class=\"comment\">// HashMap中实际存在的键值对数量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;\t\t<span class=\"comment\">// 记录HashMap内部结构发生变化的次数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> threshold;\t\t\t\t<span class=\"comment\">// HashMap所能容纳的最大数据量的Node(键值对)个数</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t<span class=\"comment\">// threshold = length * Load factor </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;\t\t<span class=\"comment\">// 负载因子(默认值是0.75)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Hash 算法，共三步</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"comment\">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class=\"line\">        <span class=\"comment\">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    // jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\"><span class=\"comment\">    // 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class=\"line\"><span class=\"comment\">    static int indexFor(int h, int length) &#123;  </span></span><br><span class=\"line\"><span class=\"comment\">    \t//第三步 取模运算</span></span><br><span class=\"line\"><span class=\"comment\">     \treturn h &amp; (length-1);  </span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-HashMap-底层是如何实现的？JDK1-8如何优化？\"><a href=\"#2-HashMap-底层是如何实现的？JDK1-8如何优化？\" class=\"headerlink\" title=\"2. HashMap 底层是如何实现的？JDK1.8如何优化？\"></a>2. HashMap 底层是如何实现的？JDK1.8如何优化？</h2><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>\n<img src=\"/pictures/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<p>JDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p>\n<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>\n<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。Node 源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;    <span class=\"comment\">//用来定位数组索引位置</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;   <span class=\"comment\">//链表的下一个node</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span></span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"julia\"</span>,<span class=\"string\">\"jiang\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>系统将调用 <code>&quot;julia&quot;</code> 这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（具体见哈希桶数组索引位置分析）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>\n<h2 id=\"3-什么是加载因子？加载因子为什么是0-75？\"><a href=\"#3-什么是加载因子？加载因子为什么是0-75？\" class=\"headerlink\" title=\"3. 什么是加载因子？加载因子为什么是0.75？\"></a>3. 什么是加载因子？加载因子为什么是0.75？</h2><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p>\n<p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p>\n<p>这其实是出于容量和性能之间平衡的结果：</p>\n<ol>\n<li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li>\n<li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li>\n</ol>\n<p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p>\n<h2 id=\"4-HashMap源码中有哪些重要方法？\"><a href=\"#4-HashMap源码中有哪些重要方法？\" class=\"headerlink\" title=\"4. HashMap源码中有哪些重要方法？\"></a>4. HashMap源码中有哪些重要方法？</h2><h3 id=\"4-1-确定哈希桶数组索引位置\"><a href=\"#4-1-确定哈希桶数组索引位置\" class=\"headerlink\" title=\"4.1 确定哈希桶数组索引位置\"></a>4.1 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;   <span class=\"comment\">//jdk1.8</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">     <span class=\"comment\">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class=\"line\">     <span class=\"comment\">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法二：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  <span class=\"comment\">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  <span class=\"comment\">//第三步 取模运算</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>\n<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>\n<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>\n<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>\n<p>下面举例说明下，n为table的长度。</p>\n<img src=\"/pictures/8e8203c1b51be6446cda4026eaaccf19_720w.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n<h3 id=\"4-2-查询\"><a href=\"#4-2-查询\" class=\"headerlink\" title=\"4.2 查询\"></a>4.2 查询</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">//对 key 进行哈希操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; </span><br><span class=\"line\">    Node&lt;K,V&gt; first, e; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n; </span><br><span class=\"line\">    K k;</span><br><span class=\"line\">    <span class=\"comment\">//非空判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断第一个元素是否是要查询的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//下一个节点非空判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个节点是树结构，则使用 getTreeNode 直接获取相应的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123; <span class=\"comment\">//非树结构，循环节点判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;   <span class=\"comment\">//hash相等，并且 key相等，则返回此节点</span></span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从以上源码可以看出，当哈希冲突时我们需要通过判断 key 值是否相等，才能确认此元素是不是我们想要的元素。</p>\n<h3 id=\"4-3-新增\"><a href=\"#4-3-新增\" class=\"headerlink\" title=\"4.3 新增\"></a>4.3 新增</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对 key 进行哈希操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; </span><br><span class=\"line\">    Node&lt;K,V&gt; p; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表为空则创建表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">//根据 key 的哈希值计算出要插入的数组索引i</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">//如果 tab[i] 为 null，则直接插入</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; </span><br><span class=\"line\">        K k;</span><br><span class=\"line\">        <span class=\"comment\">//如果key相等，直接覆盖 value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">//如果 key 不存在，判断是否为红黑树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">//红黑树直接插入键值对</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//为链表结构，循环准备插入</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//下一个元素为空时</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//链表长度大于 8 时转换为红黑树进行处理</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//key 已经存在直接覆盖 value</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">//超过最大容量，扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新增方法的执行流程如下：</p>\n<p><img src=\"/pictures/58e67eae921e4b431782c07444af824e_r.jpg\" alt=\"preview\"></p>\n<h3 id=\"4-4-扩容\"><a href=\"#4-4-扩容\" class=\"headerlink\" title=\"4.4 扩容\"></a>4.4 扩容</h3><p><a href=\"https://zhuanlan.zhihu.com/p/21673805\" target=\"_blank\" rel=\"noopener\">参考博文</a></p>\n<h4 id=\"JDK1-7-的扩容\"><a href=\"#JDK1-7-的扩容\" class=\"headerlink\" title=\"JDK1.7 的扩容\"></a>JDK1.7 的扩容</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>\n<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;   <span class=\"comment\">//传入新的容量</span></span><br><span class=\"line\"> <span class=\"number\">2</span>     Entry[] oldTable = table;    <span class=\"comment\">//引用扩容前的Entry数组</span></span><br><span class=\"line\"> <span class=\"number\">3</span>     <span class=\"keyword\">int</span> oldCapacity = oldTable.length;         </span><br><span class=\"line\"> <span class=\"number\">4</span>     <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class=\"comment\">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class=\"line\"> <span class=\"number\">5</span>         threshold = Integer.MAX_VALUE; <span class=\"comment\">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class=\"line\"> <span class=\"number\">6</span>         <span class=\"keyword\">return</span>;</span><br><span class=\"line\"> <span class=\"number\">7</span>     &#125;</span><br><span class=\"line\"> <span class=\"number\">8</span>  </span><br><span class=\"line\"> <span class=\"number\">9</span>     Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];  <span class=\"comment\">//初始化一个新的Entry数组</span></span><br><span class=\"line\"><span class=\"number\">10</span>     transfer(newTable);                         <span class=\"comment\">//！！将数据转移到新的Entry数组里</span></span><br><span class=\"line\"><span class=\"number\">11</span>     table = newTable;                           <span class=\"comment\">//HashMap的table属性引用新的Entry数组</span></span><br><span class=\"line\"><span class=\"number\">12</span>     threshold = (<span class=\"keyword\">int</span>)(newCapacity * loadFactor);<span class=\"comment\">//修改阈值</span></span><br><span class=\"line\"><span class=\"number\">13</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable)</span> </span>&#123;</span><br><span class=\"line\">   Entry[] src = table;                   <span class=\"comment\">//src引用了旧的Entry数组</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> newCapacity = newTable.length;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; j++) &#123; <span class=\"comment\">//遍历旧的Entry数组</span></span><br><span class=\"line\">       Entry&lt;K,V&gt; e = src[j];             <span class=\"comment\">//取得旧Entry数组的每个元素</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           src[j] = <span class=\"keyword\">null</span>;<span class=\"comment\">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class=\"line\">           <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">               Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity); <span class=\"comment\">//！！重新计算每个元素在数组中的位置</span></span><br><span class=\"line\">               e.next = newTable[i]; <span class=\"comment\">//标记[1]</span></span><br><span class=\"line\">               newTable[i] = e;      <span class=\"comment\">//将元素放在数组上</span></span><br><span class=\"line\">               e = next;             <span class=\"comment\">//访问下一个Entry链上的元素</span></span><br><span class=\"line\">           &#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\"><span class=\"comment\">// 计算该对象应该保存在table数组的哪个索引处</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  </span><br><span class=\"line\">\t<span class=\"comment\">//第三步 取模运算</span></span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 确定哈希桶数组索引位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class=\"line\">    <span class=\"comment\">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。下面举个例子说明下扩容过程。</p>\n<p>这里我们假设 <code>hashCode()</code> 的哈希算法就是简单的 key % (数组长度)。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。</p>\n<p>接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>\n<p><img src=\"/pictures/e5aa99e811d1814e010afa7779b759d4_r.jpg\" alt=\"preview\"></p>\n<h4 id=\"JDK1-8-在扩容方面的优化\"><a href=\"#JDK1-8-在扩容方面的优化\" class=\"headerlink\" title=\"JDK1.8 在扩容方面的优化\"></a>JDK1.8 在扩容方面的优化</h4><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>\n<p><img src=\"/pictures/a285d9b2da279a18b052fe5eed69afe9_r.jpg\" alt=\"preview\"></p>\n<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>\n<p><img src=\"/pictures/b2cb057773e3d67976c535d6ef547d51_720w.png\" alt=\"img\"></p>\n<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>\n<p><img src=\"/pictures/544caeb82a329fa49cc99842818ed1ba_720w.png\" alt=\"img\"></p>\n<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>\n<h4 id=\"JDK1-8-中扩容源码\"><a href=\"#JDK1-8-中扩容源码\" class=\"headerlink\" title=\"JDK1.8 中扩容源码\"></a>JDK1.8 中扩容源码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//扩容前数组</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"comment\">//扩容前数组的大小和阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"comment\">//预定义新数组的大小和阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//超过最大值就不可以扩容了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//扩容容量为当前容量的两倍，但不能超过MAXIMUM_CAPACITY</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//前数组没有数据，前数组大小为0，新数组容量设置为初始阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">//初始阈值为0，则使用默认的初始化容器</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果新容量等于0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    <span class=\"comment\">//开始赋值，将新的容量赋值给 table</span></span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"comment\">//原数据不为空，将原数据赋值到table中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据容量循环数组，赋值非空元素到新table</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">//如果链表只有一个，则进行直接赋值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">//如果是红黑树存储</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    <span class=\"comment\">//链表复制，JDK 1.8 扩容优化部分</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"comment\">//原索引</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">//原索引 + oldCap</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//将原索引放到哈希桶中</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//将原索引+oldCap 放到哈希桶中</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-HashMap-多线程操作导致死循环问题\"><a href=\"#6-HashMap-多线程操作导致死循环问题\" class=\"headerlink\" title=\"6. HashMap 多线程操作导致死循环问题\"></a>6. HashMap 多线程操作导致死循环问题</h2><p><a href=\"https://coolshell.cn/articles/9606.html\" target=\"_blank\" rel=\"noopener\">详细分析</a></p>\n<p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>\n<h2 id=\"7-HashMap-和-HashTable的区别\"><a href=\"#7-HashMap-和-HashTable的区别\" class=\"headerlink\" title=\"7. HashMap 和 HashTable的区别\"></a>7. HashMap 和 HashTable的区别</h2><ol>\n<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>\n<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>\n<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>\n<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</li>\n<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ol>\n<p>HashMap 中带有初始化容量的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);\t <span class=\"comment\">// 保证HashMap总是使用2的幂作为哈希表大小</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更多关于 HashMap 的知识点参考 <a href=\"https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-2Java集合?id=_226-hashmap-和-hashset区别\" target=\"_blank\" rel=\"noopener\">这里</a></p>"},{"title":"String的特点以及方法","date":"2020-04-04T15:24:48.000Z","typora-copy-images-to":"..\\..\\juliajiang\\source\\pictures","_content":"\n本文主要从源码出发，介绍了 String 的一些特点和方法。包括了 String 的底层实现，源码中的几个重要方法实现，String 使用 final 修饰的原因，String 与 StringBuilder、StringBuffered 的区别，String 在 JVM 中的存储，intern() 方法，不可变性，+ 的重载以及编译器使用 StringBuilder 的优化。\n\n<!--more-->\n\n## 1. String 如何实现\n\n以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. 用于储存字符串的值*/\n    private final char value[];\n\n    /** Cache the hash code for the string 缓存字符串的Hash Code*/\n    private int hash; // Default to 0\n    .....\n```\n\n在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`\n\n## 2. String 源码中的几个重要方法\n\n### 2.1 多构造方法\n\n如下选出源码中 String 比较重要的几个构造方法：\n\n``` java\n// String 为参数的构造方法\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n// char[] 为参数构造方法\npublic String(char value[]) {\n    this.value = Arrays.copyOf(value, value.length);\n}\n// StringBuffer 为参数的构造方法\npublic String(StringBuffer buffer) {\n    synchronized(buffer) {\n        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());\n    }\n}\n// StringBuilder 为参数的构造方法\npublic String(StringBuilder builder) {\n    this.value = Arrays.copyOf(builder.getValue(), builder.length());\n}\n```\n\n### 2.2 equals() 比较两个字符串是否相等\n\n[Object 的 equals 方法以及与 == de 区别更详细解释请参考](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\nObject 的 equals() 方法源码如下：\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\nString 的 equals() 方法重写了 Object 的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时先判断对比的值是否为 String 类型，如果不是直接返回false，如果是继续判断，具体源码如下：\n\n```java\npublic boolean equals(Object anObject) {\n    //对象引用相同，直接返回\n    if (this == anObject) {\n        return true;\n    }\n    //判断对比的值是否为String类型\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            //把两个字符串转为 char[] 数组对比\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。\n\n**equals() 和 == 的区别：**\n\n1. == 对于基本数据类型来说，是比较**值**是否相等的；对于引用类型来说，是用于比较**引用地址**是否相等的\n2. 从 Object 的 equals() 方法源码来看，对于 Object 而言，equals() 方法其实就是 ==, 而 String 重写了 equals() 方法，用于比较两个字符串的值是否相等。\n\n### 2.3 compareTo() 比较两个字符串\n\n用于两个字符串的字典序比较，返回 int 类型的值，源码如下：\n\n```java\npublic int compareTo(String anotherString) {\n    int len1 = value.length;\n    int len2 = anotherString.value.length;\n    int lim = Math.min(len1, len2);\n    char v1[] = value;\n    char v2[] = anotherString.value;\n\n    int k = 0;\n    while (k < lim) {\n        char c1 = v1[k];\n        char c2 = v2[k];\n        if (c1 != c2) {\n            return c1 - c2;\n        }\n        k++;\n    }\n    return len1 - len2;\n}\n```\n\n还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。\n\n**equals() 和 compareTo() 方法的区别：**\n\n1. equals() 可以接收一个Object类型的参数，而compareTo() 只接受String\n2. equals 返回值为 boolean, compareTo 返回 int\n\n### 2.4 其他重要方法\n\n```bash\nindexOf()：查询字符串首次出现的下标位置\nlastIndexOf()：查询字符串最后出现的下标位置\ncontains()：查询字符串中是否包含另一个字符串\ntoLowerCase()：把字符串全部转换成小写\ntoUpperCase()：把字符串全部转换成大写\nlength()：查询字符串的长度\ntrim()：去掉字符串首尾空格\nreplace()：替换字符串中的某些字符\nsplit()：把字符串分割并返回字符串数组\njoin()：把字符串数组转为字符串\n```\n\n## 3. 为什么 String 类型用 final 修饰？\n\n从 String 类的源码来看，String 是被 final 修饰的不可继承类，源码如下：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    ...\n```\n\n那这样设计有什么好处呢？\n\nJava 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时，不需要考虑谁会修改它的值；如果是可变的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上有一定的损失。\n\nJames Gosling 还说迫使 String 类设计成不可变的另一个原因是**安全**。当你在调用其他方法时，比如在调用一些系统级操作指令之前，可能会有一系列校验，如果是可变的话，可能在你校验之后，它的内部值又被改变了，这样可能引起严重的系统崩溃问题，这是迫使 String 类设计为不可变类的一个重要原因。\n\n总结来说，使用 final 修饰的第一个好处是**安全**，第二个好处是**高效**。我们以 JVM 中的字符串常量池为例，有如下两个变量：\n\n```java \nString s1 = \"java\";\nString s2 = \"java\";\n```\n\n只有字符串是不可变时，我们才能实现字符串常量池，它可以为我们缓存字符串，提高程序运行效率。\n\n![微信截图_20200405164821](../pictures/微信截图_20200405164821-1586080520904.png)\n\n试想如果 String 是可变的，那当 s1 的值修改之后，s2 的值也会跟着改变，这样就和我们预期的结果不符合，因此也就没有办法实现字符串常量池的功能了。\n\n## 4. String 和 StringBuilder、StringBuffer 的区别\n\n### （1） 可变性\n\n上文提到，String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。\n\n但StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，所以这两种对象都是可变的。AbstractStringBuilder 的源码如下：\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * The count is the number of characters used.\n     */\n    int count;\n    ...\n```\n\n### （2）线程安全性\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。\n\nStringBuffer 对方法加了同步锁或者对调用的方法加了同步锁 synchronized，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。源码如下：\n\n```java\n// StringBuffer 截取部分源码\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n// StringBuilder 截取部分源码\n@Override\npublic StringBuilder append(String str) {\n    super.append(str);\n    return this;\n}\n```\n\n### （3）性能\n\n因为 String 类型是不可变的，所以每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 性能更高一些，但却线程不安全的风险，因而我们可以再非并发操作的环境下使用 StringBuilder 操作字符串。\n\n### （4）对于三者使用的总结\n\n\t\t\t- 操作少量的数据: 适用 String\n\t\t\t- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\n\t\t\t- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer\n\n## 5. String 在 JVM（Java虚拟机）中是如何存储的？\n\nString常见的创建方式有两种，直接赋值的方式``Strings1 = \"Java\";``和``Strings2 = new String(\"Java\");``的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量 s1 会先去**字符串常量池**中找字符串“Java”，如果有相同的字符则直接返回**常量句柄**（一个唯一的整数，作为对象的身份id, 区分不同的对象和同类中的不同实例），如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 s2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中，它们在 JVM 中的存储位置如下图所示：\n\n![image-20200405194407416](../pictures/image-20200405194407416.png)\n\n代码演示如下：\n\n```java\nStrings1 = newString(\"Java\");\nStrings2 = s1.intern();\nStrings3 = \"Java\";\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s2 == s3); // true\n```\n\n## 6. String 的 intern 方法有什么含义?\n\npublic String **intern**() 返回字符串对象的规范化表示形式，返回值是一个字符串，内容与此字符串相等，但它保证来自字符串池中。\n\n一个初始为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果字符串池中已经包含一个等于此 String 对象的字符串（是否等于由 String 的 equals 方法来确定），则返回池中的字符串；否则将此 String 对象添加到池中，并且返回此 String 对象的引用。所有的字面值字符串和字符串赋值常量表达式都是内部的。\n\n如下例子中，变量 str1 会先去字符串常量池中找字符串 \"ab\", 如果有相同的字符串则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 str2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中。\n\n字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如 str3 str4）则不会进入字符串池中。\n\n```java\nString str1 = \"ab\";\nString str2 = new String(\"ab\");\nSystem.out.println(str1 == str2);           //false 引用地址不同\nSystem.out.println(str1.equals(str2));      //true 字符串值相同\nSystem.out.println(str1 == str2.intern());  //true\nString str3 = \"a\";\nString str4 = \"b\";\nSystem.out.println(str3 + str4 == str1);    //false\nSystem.out.println(\"a\" + \"b\" == str1);      //true\n```\n\n前文中说明了 equals 和 == 的区别，对于 String 而言，== 判断的是引用地址，那么什么时候会出现引用地址相同的情况呢？现在来看，如果给变量赋值的是静态字符串，就会在字符串中找相同字符串，如果有返回引用，这时候就存在相同的引用地址；而 new String 构造的字符串用 == 判断一定是 false。\n\n```java\nString str5 = new String(\"ab\");\nSystem.out.println(str2 == str5);           //false\nString str6 = \"ab\";\nSystem.out.println(str1 ==str6);            //true\n```\n\n## 7. String 的不可变\n\nString 对象是不可变的。从 JDK 文档可以发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象来包含修改后的字符串内容，而最初的 String 对象纹丝未动。\n\n例如下面的代码：\n\n```java\npublic static String upcase(String s) {\n    return s.toUpperCase();\n}\npublic static void main(String[] args) {\n    String q = \"howdy\";\n    System.out.println(q); // howdy \n    String qq = upcase(q);\n    System.out.println(qq); // HOWDY \n    System.out.println(q); // howdy \n}\n```\n\n当把 ``q``传递给``upcase()``方法时，实际传递的是引用的一个拷贝。每当 String 对象作为方法的参数时，都会复制一份引用，而该引用所指的对象一直在物理位置上没有任何变化。\n\n回到 upcase() 的定义，传入其中的引用有了名字 s, 只有 upcase() 方法运行时局部引用 s 才存在。一旦 upcase() 结束，s 就消失了。其返回值也就指向了一个新的对象，而 q 仍然在原来的位置。\n\n## 8. + 的重载与 StringBuilder\n\nString 对象是不可变的，你可以给一个 String 对象添加任意多的别名，因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，这样也就不会影响到其他引用。\n\n不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子：操作符 + 可以连接 String。当使用 + 操作符时，编译器会做一定的优化，例如在下面的代码中：\n\n```java\nString mango = \"mango\"; \nString s = \"abc\" + mango + \"def\" + 47; \n```\n\n编译器会自动引入``java.lang.StringBuilder``类（虽然源代码中并没有使用 StringBuilder 类，但因为其高效，编译器会使用它），先创建一个 StringBuilder 对象，对每个字符串调用一次 append 方法，共4次，最后调用 toString() 方法，存为 s。\n\n现在你可能觉得可以随意使用 String 对象，反正编译器会为你做性能优化。在这之前让我们深入看看编译器会为我们优化到什么程度。下面例子中采用两种方式生成 String：\n\n```java\npublic class WhitherStringBuilder { \n    public String implicit(String[] fields) { \n        String result = \"\"; \n        for(String field : fields) { \n            result += field;\n        }\n        return result; \n    }\n    public String explicit(String[] fields) { \n        StringBuilder result = new StringBuilder(); \n        for(String field : fields) { \n            result.append(field); \n        } \n        return result.toString(); \n    }\n}\n```\n\n第一种方式中，StringBuilder 是在循环体内部创建的，这意味着每进行一次循环，就会创建一个 StringBuilder 对象。第二种显示定义 StringBuilder 只生成一个 StringBuilder 对象。因此如果使用循环，且可能存在性能问题，那么最好自己创建一个 StringBuilder 对象。\n\n","source":"_posts/String的特点以及方法.md","raw":"---\ntitle: String的特点以及方法\ndate: 2020-04-04 23:24:48\ntags:\n  - String\n  - Java\ncategories: Java\ntypora-copy-images-to: ..\\..\\juliajiang\\source\\pictures\n\n---\n\n本文主要从源码出发，介绍了 String 的一些特点和方法。包括了 String 的底层实现，源码中的几个重要方法实现，String 使用 final 修饰的原因，String 与 StringBuilder、StringBuffered 的区别，String 在 JVM 中的存储，intern() 方法，不可变性，+ 的重载以及编译器使用 StringBuilder 的优化。\n\n<!--more-->\n\n## 1. String 如何实现\n\n以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. 用于储存字符串的值*/\n    private final char value[];\n\n    /** Cache the hash code for the string 缓存字符串的Hash Code*/\n    private int hash; // Default to 0\n    .....\n```\n\n在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`\n\n## 2. String 源码中的几个重要方法\n\n### 2.1 多构造方法\n\n如下选出源码中 String 比较重要的几个构造方法：\n\n``` java\n// String 为参数的构造方法\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n// char[] 为参数构造方法\npublic String(char value[]) {\n    this.value = Arrays.copyOf(value, value.length);\n}\n// StringBuffer 为参数的构造方法\npublic String(StringBuffer buffer) {\n    synchronized(buffer) {\n        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());\n    }\n}\n// StringBuilder 为参数的构造方法\npublic String(StringBuilder builder) {\n    this.value = Arrays.copyOf(builder.getValue(), builder.length());\n}\n```\n\n### 2.2 equals() 比较两个字符串是否相等\n\n[Object 的 equals 方法以及与 == de 区别更详细解释请参考](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\nObject 的 equals() 方法源码如下：\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\nString 的 equals() 方法重写了 Object 的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时先判断对比的值是否为 String 类型，如果不是直接返回false，如果是继续判断，具体源码如下：\n\n```java\npublic boolean equals(Object anObject) {\n    //对象引用相同，直接返回\n    if (this == anObject) {\n        return true;\n    }\n    //判断对比的值是否为String类型\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            //把两个字符串转为 char[] 数组对比\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。\n\n**equals() 和 == 的区别：**\n\n1. == 对于基本数据类型来说，是比较**值**是否相等的；对于引用类型来说，是用于比较**引用地址**是否相等的\n2. 从 Object 的 equals() 方法源码来看，对于 Object 而言，equals() 方法其实就是 ==, 而 String 重写了 equals() 方法，用于比较两个字符串的值是否相等。\n\n### 2.3 compareTo() 比较两个字符串\n\n用于两个字符串的字典序比较，返回 int 类型的值，源码如下：\n\n```java\npublic int compareTo(String anotherString) {\n    int len1 = value.length;\n    int len2 = anotherString.value.length;\n    int lim = Math.min(len1, len2);\n    char v1[] = value;\n    char v2[] = anotherString.value;\n\n    int k = 0;\n    while (k < lim) {\n        char c1 = v1[k];\n        char c2 = v2[k];\n        if (c1 != c2) {\n            return c1 - c2;\n        }\n        k++;\n    }\n    return len1 - len2;\n}\n```\n\n还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。\n\n**equals() 和 compareTo() 方法的区别：**\n\n1. equals() 可以接收一个Object类型的参数，而compareTo() 只接受String\n2. equals 返回值为 boolean, compareTo 返回 int\n\n### 2.4 其他重要方法\n\n```bash\nindexOf()：查询字符串首次出现的下标位置\nlastIndexOf()：查询字符串最后出现的下标位置\ncontains()：查询字符串中是否包含另一个字符串\ntoLowerCase()：把字符串全部转换成小写\ntoUpperCase()：把字符串全部转换成大写\nlength()：查询字符串的长度\ntrim()：去掉字符串首尾空格\nreplace()：替换字符串中的某些字符\nsplit()：把字符串分割并返回字符串数组\njoin()：把字符串数组转为字符串\n```\n\n## 3. 为什么 String 类型用 final 修饰？\n\n从 String 类的源码来看，String 是被 final 修饰的不可继承类，源码如下：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    ...\n```\n\n那这样设计有什么好处呢？\n\nJava 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时，不需要考虑谁会修改它的值；如果是可变的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上有一定的损失。\n\nJames Gosling 还说迫使 String 类设计成不可变的另一个原因是**安全**。当你在调用其他方法时，比如在调用一些系统级操作指令之前，可能会有一系列校验，如果是可变的话，可能在你校验之后，它的内部值又被改变了，这样可能引起严重的系统崩溃问题，这是迫使 String 类设计为不可变类的一个重要原因。\n\n总结来说，使用 final 修饰的第一个好处是**安全**，第二个好处是**高效**。我们以 JVM 中的字符串常量池为例，有如下两个变量：\n\n```java \nString s1 = \"java\";\nString s2 = \"java\";\n```\n\n只有字符串是不可变时，我们才能实现字符串常量池，它可以为我们缓存字符串，提高程序运行效率。\n\n![微信截图_20200405164821](../pictures/微信截图_20200405164821-1586080520904.png)\n\n试想如果 String 是可变的，那当 s1 的值修改之后，s2 的值也会跟着改变，这样就和我们预期的结果不符合，因此也就没有办法实现字符串常量池的功能了。\n\n## 4. String 和 StringBuilder、StringBuffer 的区别\n\n### （1） 可变性\n\n上文提到，String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。\n\n但StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，所以这两种对象都是可变的。AbstractStringBuilder 的源码如下：\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * The count is the number of characters used.\n     */\n    int count;\n    ...\n```\n\n### （2）线程安全性\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。\n\nStringBuffer 对方法加了同步锁或者对调用的方法加了同步锁 synchronized，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。源码如下：\n\n```java\n// StringBuffer 截取部分源码\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n// StringBuilder 截取部分源码\n@Override\npublic StringBuilder append(String str) {\n    super.append(str);\n    return this;\n}\n```\n\n### （3）性能\n\n因为 String 类型是不可变的，所以每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 性能更高一些，但却线程不安全的风险，因而我们可以再非并发操作的环境下使用 StringBuilder 操作字符串。\n\n### （4）对于三者使用的总结\n\n\t\t\t- 操作少量的数据: 适用 String\n\t\t\t- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\n\t\t\t- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer\n\n## 5. String 在 JVM（Java虚拟机）中是如何存储的？\n\nString常见的创建方式有两种，直接赋值的方式``Strings1 = \"Java\";``和``Strings2 = new String(\"Java\");``的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量 s1 会先去**字符串常量池**中找字符串“Java”，如果有相同的字符则直接返回**常量句柄**（一个唯一的整数，作为对象的身份id, 区分不同的对象和同类中的不同实例），如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 s2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中，它们在 JVM 中的存储位置如下图所示：\n\n![image-20200405194407416](../pictures/image-20200405194407416.png)\n\n代码演示如下：\n\n```java\nStrings1 = newString(\"Java\");\nStrings2 = s1.intern();\nStrings3 = \"Java\";\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s2 == s3); // true\n```\n\n## 6. String 的 intern 方法有什么含义?\n\npublic String **intern**() 返回字符串对象的规范化表示形式，返回值是一个字符串，内容与此字符串相等，但它保证来自字符串池中。\n\n一个初始为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果字符串池中已经包含一个等于此 String 对象的字符串（是否等于由 String 的 equals 方法来确定），则返回池中的字符串；否则将此 String 对象添加到池中，并且返回此 String 对象的引用。所有的字面值字符串和字符串赋值常量表达式都是内部的。\n\n如下例子中，变量 str1 会先去字符串常量池中找字符串 \"ab\", 如果有相同的字符串则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 str2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中。\n\n字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如 str3 str4）则不会进入字符串池中。\n\n```java\nString str1 = \"ab\";\nString str2 = new String(\"ab\");\nSystem.out.println(str1 == str2);           //false 引用地址不同\nSystem.out.println(str1.equals(str2));      //true 字符串值相同\nSystem.out.println(str1 == str2.intern());  //true\nString str3 = \"a\";\nString str4 = \"b\";\nSystem.out.println(str3 + str4 == str1);    //false\nSystem.out.println(\"a\" + \"b\" == str1);      //true\n```\n\n前文中说明了 equals 和 == 的区别，对于 String 而言，== 判断的是引用地址，那么什么时候会出现引用地址相同的情况呢？现在来看，如果给变量赋值的是静态字符串，就会在字符串中找相同字符串，如果有返回引用，这时候就存在相同的引用地址；而 new String 构造的字符串用 == 判断一定是 false。\n\n```java\nString str5 = new String(\"ab\");\nSystem.out.println(str2 == str5);           //false\nString str6 = \"ab\";\nSystem.out.println(str1 ==str6);            //true\n```\n\n## 7. String 的不可变\n\nString 对象是不可变的。从 JDK 文档可以发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象来包含修改后的字符串内容，而最初的 String 对象纹丝未动。\n\n例如下面的代码：\n\n```java\npublic static String upcase(String s) {\n    return s.toUpperCase();\n}\npublic static void main(String[] args) {\n    String q = \"howdy\";\n    System.out.println(q); // howdy \n    String qq = upcase(q);\n    System.out.println(qq); // HOWDY \n    System.out.println(q); // howdy \n}\n```\n\n当把 ``q``传递给``upcase()``方法时，实际传递的是引用的一个拷贝。每当 String 对象作为方法的参数时，都会复制一份引用，而该引用所指的对象一直在物理位置上没有任何变化。\n\n回到 upcase() 的定义，传入其中的引用有了名字 s, 只有 upcase() 方法运行时局部引用 s 才存在。一旦 upcase() 结束，s 就消失了。其返回值也就指向了一个新的对象，而 q 仍然在原来的位置。\n\n## 8. + 的重载与 StringBuilder\n\nString 对象是不可变的，你可以给一个 String 对象添加任意多的别名，因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，这样也就不会影响到其他引用。\n\n不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子：操作符 + 可以连接 String。当使用 + 操作符时，编译器会做一定的优化，例如在下面的代码中：\n\n```java\nString mango = \"mango\"; \nString s = \"abc\" + mango + \"def\" + 47; \n```\n\n编译器会自动引入``java.lang.StringBuilder``类（虽然源代码中并没有使用 StringBuilder 类，但因为其高效，编译器会使用它），先创建一个 StringBuilder 对象，对每个字符串调用一次 append 方法，共4次，最后调用 toString() 方法，存为 s。\n\n现在你可能觉得可以随意使用 String 对象，反正编译器会为你做性能优化。在这之前让我们深入看看编译器会为我们优化到什么程度。下面例子中采用两种方式生成 String：\n\n```java\npublic class WhitherStringBuilder { \n    public String implicit(String[] fields) { \n        String result = \"\"; \n        for(String field : fields) { \n            result += field;\n        }\n        return result; \n    }\n    public String explicit(String[] fields) { \n        StringBuilder result = new StringBuilder(); \n        for(String field : fields) { \n            result.append(field); \n        } \n        return result.toString(); \n    }\n}\n```\n\n第一种方式中，StringBuilder 是在循环体内部创建的，这意味着每进行一次循环，就会创建一个 StringBuilder 对象。第二种显示定义 StringBuilder 只生成一个 StringBuilder 对象。因此如果使用循环，且可能存在性能问题，那么最好自己创建一个 StringBuilder 对象。\n\n","slug":"String的特点以及方法","published":1,"updated":"2020-07-18T11:24:45.779Z","_id":"ck8x8a1g50007fwuq9dp15rd2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要从源码出发，介绍了 String 的一些特点和方法。包括了 String 的底层实现，源码中的几个重要方法实现，String 使用 final 修饰的原因，String 与 StringBuilder、StringBuffered 的区别，String 在 JVM 中的存储，intern() 方法，不可变性，+ 的重载以及编译器使用 StringBuilder 的优化。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-String-如何实现\"><a href=\"#1-String-如何实现\" class=\"headerlink\" title=\"1. String 如何实现\"></a>1. String 如何实现</h2><p>以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value is used for character storage. 用于储存字符串的值*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Cache the hash code for the string 缓存字符串的Hash Code*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// Default to 0</span></span><br><span class=\"line\">    .....</span><br></pre></td></tr></table></figure>\n\n<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>\n<h2 id=\"2-String-源码中的几个重要方法\"><a href=\"#2-String-源码中的几个重要方法\" class=\"headerlink\" title=\"2. String 源码中的几个重要方法\"></a>2. String 源码中的几个重要方法</h2><h3 id=\"2-1-多构造方法\"><a href=\"#2-1-多构造方法\" class=\"headerlink\" title=\"2.1 多构造方法\"></a>2.1 多构造方法</h3><p>如下选出源码中 String 比较重要的几个构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String 为参数的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(String original)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = original.value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash = original.hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// char[] 为参数构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(<span class=\"keyword\">char</span> value[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// StringBuffer 为参数的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuffer buffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(buffer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// StringBuilder 为参数的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-equals-比较两个字符串是否相等\"><a href=\"#2-2-equals-比较两个字符串是否相等\" class=\"headerlink\" title=\"2.2 equals() 比较两个字符串是否相等\"></a>2.2 equals() 比较两个字符串是否相等</h3><p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">Object 的 equals 方法以及与 == de 区别更详细解释请参考</a></p>\n<p>Object 的 equals() 方法源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>String 的 equals() 方法重写了 Object 的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时先判断对比的值是否为 String 类型，如果不是直接返回false，如果是继续判断，具体源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对象引用相同，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断对比的值是否为String类型</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把两个字符串转为 char[] 数组对比</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p>\n<p><strong>equals() 和 == 的区别：</strong></p>\n<ol>\n<li>== 对于基本数据类型来说，是比较<strong>值</strong>是否相等的；对于引用类型来说，是用于比较<strong>引用地址</strong>是否相等的</li>\n<li>从 Object 的 equals() 方法源码来看，对于 Object 而言，equals() 方法其实就是 ==, 而 String 重写了 equals() 方法，用于比较两个字符串的值是否相等。</li>\n</ol>\n<h3 id=\"2-3-compareTo-比较两个字符串\"><a href=\"#2-3-compareTo-比较两个字符串\" class=\"headerlink\" title=\"2.3 compareTo() 比较两个字符串\"></a>2.3 compareTo() 比较两个字符串</h3><p>用于两个字符串的字典序比较，返回 int 类型的值，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len1 = value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len2 = anotherString.value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lim = Math.min(len1, len2);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c1 = v1[k];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c2 = v2[k];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len1 - len2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p>\n<p><strong>equals() 和 compareTo() 方法的区别：</strong></p>\n<ol>\n<li>equals() 可以接收一个Object类型的参数，而compareTo() 只接受String</li>\n<li>equals 返回值为 boolean, compareTo 返回 int</li>\n</ol>\n<h3 id=\"2-4-其他重要方法\"><a href=\"#2-4-其他重要方法\" class=\"headerlink\" title=\"2.4 其他重要方法\"></a>2.4 其他重要方法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">indexOf()：查询字符串首次出现的下标位置</span><br><span class=\"line\">lastIndexOf()：查询字符串最后出现的下标位置</span><br><span class=\"line\">contains()：查询字符串中是否包含另一个字符串</span><br><span class=\"line\">toLowerCase()：把字符串全部转换成小写</span><br><span class=\"line\">toUpperCase()：把字符串全部转换成大写</span><br><span class=\"line\">length()：查询字符串的长度</span><br><span class=\"line\">trim()：去掉字符串首尾空格</span><br><span class=\"line\">replace()：替换字符串中的某些字符</span><br><span class=\"line\">split()：把字符串分割并返回字符串数组</span><br><span class=\"line\">join()：把字符串数组转为字符串</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-为什么-String-类型用-final-修饰？\"><a href=\"#3-为什么-String-类型用-final-修饰？\" class=\"headerlink\" title=\"3. 为什么 String 类型用 final 修饰？\"></a>3. 为什么 String 类型用 final 修饰？</h2><p>从 String 类的源码来看，String 是被 final 修饰的不可继承类，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>那这样设计有什么好处呢？</p>\n<p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时，不需要考虑谁会修改它的值；如果是可变的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上有一定的损失。</p>\n<p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是<strong>安全</strong>。当你在调用其他方法时，比如在调用一些系统级操作指令之前，可能会有一系列校验，如果是可变的话，可能在你校验之后，它的内部值又被改变了，这样可能引起严重的系统崩溃问题，这是迫使 String 类设计为不可变类的一个重要原因。</p>\n<p>总结来说，使用 final 修饰的第一个好处是<strong>安全</strong>，第二个好处是<strong>高效</strong>。我们以 JVM 中的字符串常量池为例，有如下两个变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">\"java\"</span>;</span><br><span class=\"line\">String s2 = <span class=\"string\">\"java\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>只有字符串是不可变时，我们才能实现字符串常量池，它可以为我们缓存字符串，提高程序运行效率。</p>\n<p><img src=\"../pictures/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200405164821-1586080520904.png\" alt=\"微信截图_20200405164821\"></p>\n<p>试想如果 String 是可变的，那当 s1 的值修改之后，s2 的值也会跟着改变，这样就和我们预期的结果不符合，因此也就没有办法实现字符串常量池的功能了。</p>\n<h2 id=\"4-String-和-StringBuilder、StringBuffer-的区别\"><a href=\"#4-String-和-StringBuilder、StringBuffer-的区别\" class=\"headerlink\" title=\"4. String 和 StringBuilder、StringBuffer 的区别\"></a>4. String 和 StringBuilder、StringBuffer 的区别</h2><h3 id=\"（1）-可变性\"><a href=\"#（1）-可变性\" class=\"headerlink\" title=\"（1） 可变性\"></a>（1） 可变性</h3><p>上文提到，String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>\n<p>但StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，所以这两种对象都是可变的。AbstractStringBuilder 的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The value is used for character storage.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The count is the number of characters used.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）线程安全性\"><a href=\"#（2）线程安全性\" class=\"headerlink\" title=\"（2）线程安全性\"></a>（2）线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>\n<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁 synchronized，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// StringBuffer 截取部分源码</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> StringBuffer <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    toStringCache = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.append(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// StringBuilder 截取部分源码</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringBuilder <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.append(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）性能\"><a href=\"#（3）性能\" class=\"headerlink\" title=\"（3）性能\"></a>（3）性能</h3><p>因为 String 类型是不可变的，所以每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 性能更高一些，但却线程不安全的风险，因而我们可以再非并发操作的环境下使用 StringBuilder 操作字符串。</p>\n<h3 id=\"（4）对于三者使用的总结\"><a href=\"#（4）对于三者使用的总结\" class=\"headerlink\" title=\"（4）对于三者使用的总结\"></a>（4）对于三者使用的总结</h3><pre><code>- 操作少量的数据: 适用 String\n- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\n- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</code></pre><h2 id=\"5-String-在-JVM（Java虚拟机）中是如何存储的？\"><a href=\"#5-String-在-JVM（Java虚拟机）中是如何存储的？\" class=\"headerlink\" title=\"5. String 在 JVM（Java虚拟机）中是如何存储的？\"></a>5. String 在 JVM（Java虚拟机）中是如何存储的？</h2><p>String常见的创建方式有两种，直接赋值的方式<code>Strings1 = &quot;Java&quot;;</code>和<code>Strings2 = new String(&quot;Java&quot;);</code>的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量 s1 会先去<strong>字符串常量池</strong>中找字符串“Java”，如果有相同的字符则直接返回<strong>常量句柄</strong>（一个唯一的整数，作为对象的身份id, 区分不同的对象和同类中的不同实例），如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 s2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中，它们在 JVM 中的存储位置如下图所示：</p>\n<p><img src=\"../pictures/image-20200405194407416.png\" alt=\"image-20200405194407416\"></p>\n<p>代码演示如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Strings1 = newString(<span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\">Strings2 = s1.intern();</span><br><span class=\"line\">Strings3 = <span class=\"string\">\"Java\"</span>;</span><br><span class=\"line\">System.out.println(s1 == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(s2 == s3); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-String-的-intern-方法有什么含义\"><a href=\"#6-String-的-intern-方法有什么含义\" class=\"headerlink\" title=\"6. String 的 intern 方法有什么含义?\"></a>6. String 的 intern 方法有什么含义?</h2><p>public String <strong>intern</strong>() 返回字符串对象的规范化表示形式，返回值是一个字符串，内容与此字符串相等，但它保证来自字符串池中。</p>\n<p>一个初始为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果字符串池中已经包含一个等于此 String 对象的字符串（是否等于由 String 的 equals 方法来确定），则返回池中的字符串；否则将此 String 对象添加到池中，并且返回此 String 对象的引用。所有的字面值字符串和字符串赋值常量表达式都是内部的。</p>\n<p>如下例子中，变量 str1 会先去字符串常量池中找字符串 “ab”, 如果有相同的字符串则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 str2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中。</p>\n<p>字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如 str3 str4）则不会进入字符串池中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>);</span><br><span class=\"line\">System.out.println(str1 == str2);           <span class=\"comment\">//false 引用地址不同</span></span><br><span class=\"line\">System.out.println(str1.equals(str2));      <span class=\"comment\">//true 字符串值相同</span></span><br><span class=\"line\">System.out.println(str1 == str2.intern());  <span class=\"comment\">//true</span></span><br><span class=\"line\">String str3 = <span class=\"string\">\"a\"</span>;</span><br><span class=\"line\">String str4 = <span class=\"string\">\"b\"</span>;</span><br><span class=\"line\">System.out.println(str3 + str4 == str1);    <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> == str1);      <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>前文中说明了 equals 和 == 的区别，对于 String 而言，== 判断的是引用地址，那么什么时候会出现引用地址相同的情况呢？现在来看，如果给变量赋值的是静态字符串，就会在字符串中找相同字符串，如果有返回引用，这时候就存在相同的引用地址；而 new String 构造的字符串用 == 判断一定是 false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str5 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>);</span><br><span class=\"line\">System.out.println(str2 == str5);           <span class=\"comment\">//false</span></span><br><span class=\"line\">String str6 = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">System.out.println(str1 ==str6);            <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-String-的不可变\"><a href=\"#7-String-的不可变\" class=\"headerlink\" title=\"7. String 的不可变\"></a>7. String 的不可变</h2><p>String 对象是不可变的。从 JDK 文档可以发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象来包含修改后的字符串内容，而最初的 String 对象纹丝未动。</p>\n<p>例如下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">upcase</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.toUpperCase();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String q = <span class=\"string\">\"howdy\"</span>;</span><br><span class=\"line\">    System.out.println(q); <span class=\"comment\">// howdy </span></span><br><span class=\"line\">    String qq = upcase(q);</span><br><span class=\"line\">    System.out.println(qq); <span class=\"comment\">// HOWDY </span></span><br><span class=\"line\">    System.out.println(q); <span class=\"comment\">// howdy </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当把 <code>q</code>传递给<code>upcase()</code>方法时，实际传递的是引用的一个拷贝。每当 String 对象作为方法的参数时，都会复制一份引用，而该引用所指的对象一直在物理位置上没有任何变化。</p>\n<p>回到 upcase() 的定义，传入其中的引用有了名字 s, 只有 upcase() 方法运行时局部引用 s 才存在。一旦 upcase() 结束，s 就消失了。其返回值也就指向了一个新的对象，而 q 仍然在原来的位置。</p>\n<h2 id=\"8-的重载与-StringBuilder\"><a href=\"#8-的重载与-StringBuilder\" class=\"headerlink\" title=\"8. + 的重载与 StringBuilder\"></a>8. + 的重载与 StringBuilder</h2><p>String 对象是不可变的，你可以给一个 String 对象添加任意多的别名，因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，这样也就不会影响到其他引用。</p>\n<p>不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子：操作符 + 可以连接 String。当使用 + 操作符时，编译器会做一定的优化，例如在下面的代码中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String mango = <span class=\"string\">\"mango\"</span>; </span><br><span class=\"line\">String s = <span class=\"string\">\"abc\"</span> + mango + <span class=\"string\">\"def\"</span> + <span class=\"number\">47</span>;</span><br></pre></td></tr></table></figure>\n\n<p>编译器会自动引入<code>java.lang.StringBuilder</code>类（虽然源代码中并没有使用 StringBuilder 类，但因为其高效，编译器会使用它），先创建一个 StringBuilder 对象，对每个字符串调用一次 append 方法，共4次，最后调用 toString() 方法，存为 s。</p>\n<p>现在你可能觉得可以随意使用 String 对象，反正编译器会为你做性能优化。在这之前让我们深入看看编译器会为我们优化到什么程度。下面例子中采用两种方式生成 String：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhitherStringBuilder</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">implicit</span><span class=\"params\">(String[] fields)</span> </span>&#123; </span><br><span class=\"line\">        String result = <span class=\"string\">\"\"</span>; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String field : fields) &#123; </span><br><span class=\"line\">            result += field;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">explicit</span><span class=\"params\">(String[] fields)</span> </span>&#123; </span><br><span class=\"line\">        StringBuilder result = <span class=\"keyword\">new</span> StringBuilder(); </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String field : fields) &#123; </span><br><span class=\"line\">            result.append(field); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.toString(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一种方式中，StringBuilder 是在循环体内部创建的，这意味着每进行一次循环，就会创建一个 StringBuilder 对象。第二种显示定义 StringBuilder 只生成一个 StringBuilder 对象。因此如果使用循环，且可能存在性能问题，那么最好自己创建一个 StringBuilder 对象。</p>\n","site":{"data":{}},"length":7795,"excerpt":"<p>本文主要从源码出发，介绍了 String 的一些特点和方法。包括了 String 的底层实现，源码中的几个重要方法实现，String 使用 final 修饰的原因，String 与 StringBuilder、StringBuffered 的区别，String 在 JVM 中的存储，intern() 方法，不可变性，+ 的重载以及编译器使用 StringBuilder 的优化。</p>","more":"<h2 id=\"1-String-如何实现\"><a href=\"#1-String-如何实现\" class=\"headerlink\" title=\"1. String 如何实现\"></a>1. String 如何实现</h2><p>以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value is used for character storage. 用于储存字符串的值*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Cache the hash code for the string 缓存字符串的Hash Code*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// Default to 0</span></span><br><span class=\"line\">    .....</span><br></pre></td></tr></table></figure>\n\n<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>\n<h2 id=\"2-String-源码中的几个重要方法\"><a href=\"#2-String-源码中的几个重要方法\" class=\"headerlink\" title=\"2. String 源码中的几个重要方法\"></a>2. String 源码中的几个重要方法</h2><h3 id=\"2-1-多构造方法\"><a href=\"#2-1-多构造方法\" class=\"headerlink\" title=\"2.1 多构造方法\"></a>2.1 多构造方法</h3><p>如下选出源码中 String 比较重要的几个构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String 为参数的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(String original)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = original.value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash = original.hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// char[] 为参数构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(<span class=\"keyword\">char</span> value[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// StringBuffer 为参数的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuffer buffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(buffer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// StringBuilder 为参数的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-equals-比较两个字符串是否相等\"><a href=\"#2-2-equals-比较两个字符串是否相等\" class=\"headerlink\" title=\"2.2 equals() 比较两个字符串是否相等\"></a>2.2 equals() 比较两个字符串是否相等</h3><p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">Object 的 equals 方法以及与 == de 区别更详细解释请参考</a></p>\n<p>Object 的 equals() 方法源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>String 的 equals() 方法重写了 Object 的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时先判断对比的值是否为 String 类型，如果不是直接返回false，如果是继续判断，具体源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对象引用相同，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断对比的值是否为String类型</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把两个字符串转为 char[] 数组对比</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p>\n<p><strong>equals() 和 == 的区别：</strong></p>\n<ol>\n<li>== 对于基本数据类型来说，是比较<strong>值</strong>是否相等的；对于引用类型来说，是用于比较<strong>引用地址</strong>是否相等的</li>\n<li>从 Object 的 equals() 方法源码来看，对于 Object 而言，equals() 方法其实就是 ==, 而 String 重写了 equals() 方法，用于比较两个字符串的值是否相等。</li>\n</ol>\n<h3 id=\"2-3-compareTo-比较两个字符串\"><a href=\"#2-3-compareTo-比较两个字符串\" class=\"headerlink\" title=\"2.3 compareTo() 比较两个字符串\"></a>2.3 compareTo() 比较两个字符串</h3><p>用于两个字符串的字典序比较，返回 int 类型的值，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len1 = value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len2 = anotherString.value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lim = Math.min(len1, len2);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c1 = v1[k];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c2 = v2[k];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len1 - len2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p>\n<p><strong>equals() 和 compareTo() 方法的区别：</strong></p>\n<ol>\n<li>equals() 可以接收一个Object类型的参数，而compareTo() 只接受String</li>\n<li>equals 返回值为 boolean, compareTo 返回 int</li>\n</ol>\n<h3 id=\"2-4-其他重要方法\"><a href=\"#2-4-其他重要方法\" class=\"headerlink\" title=\"2.4 其他重要方法\"></a>2.4 其他重要方法</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">indexOf()：查询字符串首次出现的下标位置</span><br><span class=\"line\">lastIndexOf()：查询字符串最后出现的下标位置</span><br><span class=\"line\">contains()：查询字符串中是否包含另一个字符串</span><br><span class=\"line\">toLowerCase()：把字符串全部转换成小写</span><br><span class=\"line\">toUpperCase()：把字符串全部转换成大写</span><br><span class=\"line\">length()：查询字符串的长度</span><br><span class=\"line\">trim()：去掉字符串首尾空格</span><br><span class=\"line\">replace()：替换字符串中的某些字符</span><br><span class=\"line\">split()：把字符串分割并返回字符串数组</span><br><span class=\"line\">join()：把字符串数组转为字符串</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-为什么-String-类型用-final-修饰？\"><a href=\"#3-为什么-String-类型用-final-修饰？\" class=\"headerlink\" title=\"3. 为什么 String 类型用 final 修饰？\"></a>3. 为什么 String 类型用 final 修饰？</h2><p>从 String 类的源码来看，String 是被 final 修饰的不可继承类，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>那这样设计有什么好处呢？</p>\n<p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时，不需要考虑谁会修改它的值；如果是可变的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上有一定的损失。</p>\n<p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是<strong>安全</strong>。当你在调用其他方法时，比如在调用一些系统级操作指令之前，可能会有一系列校验，如果是可变的话，可能在你校验之后，它的内部值又被改变了，这样可能引起严重的系统崩溃问题，这是迫使 String 类设计为不可变类的一个重要原因。</p>\n<p>总结来说，使用 final 修饰的第一个好处是<strong>安全</strong>，第二个好处是<strong>高效</strong>。我们以 JVM 中的字符串常量池为例，有如下两个变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">\"java\"</span>;</span><br><span class=\"line\">String s2 = <span class=\"string\">\"java\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>只有字符串是不可变时，我们才能实现字符串常量池，它可以为我们缓存字符串，提高程序运行效率。</p>\n<p><img src=\"../pictures/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200405164821-1586080520904.png\" alt=\"微信截图_20200405164821\"></p>\n<p>试想如果 String 是可变的，那当 s1 的值修改之后，s2 的值也会跟着改变，这样就和我们预期的结果不符合，因此也就没有办法实现字符串常量池的功能了。</p>\n<h2 id=\"4-String-和-StringBuilder、StringBuffer-的区别\"><a href=\"#4-String-和-StringBuilder、StringBuffer-的区别\" class=\"headerlink\" title=\"4. String 和 StringBuilder、StringBuffer 的区别\"></a>4. String 和 StringBuilder、StringBuffer 的区别</h2><h3 id=\"（1）-可变性\"><a href=\"#（1）-可变性\" class=\"headerlink\" title=\"（1） 可变性\"></a>（1） 可变性</h3><p>上文提到，String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>\n<p>但StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法，所以这两种对象都是可变的。AbstractStringBuilder 的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The value is used for character storage.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The count is the number of characters used.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）线程安全性\"><a href=\"#（2）线程安全性\" class=\"headerlink\" title=\"（2）线程安全性\"></a>（2）线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>\n<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁 synchronized，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// StringBuffer 截取部分源码</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> StringBuffer <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    toStringCache = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.append(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// StringBuilder 截取部分源码</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringBuilder <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.append(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）性能\"><a href=\"#（3）性能\" class=\"headerlink\" title=\"（3）性能\"></a>（3）性能</h3><p>因为 String 类型是不可变的，所以每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 性能更高一些，但却线程不安全的风险，因而我们可以再非并发操作的环境下使用 StringBuilder 操作字符串。</p>\n<h3 id=\"（4）对于三者使用的总结\"><a href=\"#（4）对于三者使用的总结\" class=\"headerlink\" title=\"（4）对于三者使用的总结\"></a>（4）对于三者使用的总结</h3><pre><code>- 操作少量的数据: 适用 String\n- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\n- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</code></pre><h2 id=\"5-String-在-JVM（Java虚拟机）中是如何存储的？\"><a href=\"#5-String-在-JVM（Java虚拟机）中是如何存储的？\" class=\"headerlink\" title=\"5. String 在 JVM（Java虚拟机）中是如何存储的？\"></a>5. String 在 JVM（Java虚拟机）中是如何存储的？</h2><p>String常见的创建方式有两种，直接赋值的方式<code>Strings1 = &quot;Java&quot;;</code>和<code>Strings2 = new String(&quot;Java&quot;);</code>的方式，但两者在JVM的存储区域却截然不同，在JDK1.8中，变量 s1 会先去<strong>字符串常量池</strong>中找字符串“Java”，如果有相同的字符则直接返回<strong>常量句柄</strong>（一个唯一的整数，作为对象的身份id, 区分不同的对象和同类中的不同实例），如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 s2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中，它们在 JVM 中的存储位置如下图所示：</p>\n<p><img src=\"../pictures/image-20200405194407416.png\" alt=\"image-20200405194407416\"></p>\n<p>代码演示如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Strings1 = newString(<span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\">Strings2 = s1.intern();</span><br><span class=\"line\">Strings3 = <span class=\"string\">\"Java\"</span>;</span><br><span class=\"line\">System.out.println(s1 == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(s2 == s3); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-String-的-intern-方法有什么含义\"><a href=\"#6-String-的-intern-方法有什么含义\" class=\"headerlink\" title=\"6. String 的 intern 方法有什么含义?\"></a>6. String 的 intern 方法有什么含义?</h2><p>public String <strong>intern</strong>() 返回字符串对象的规范化表示形式，返回值是一个字符串，内容与此字符串相等，但它保证来自字符串池中。</p>\n<p>一个初始为空的字符串池，它由类 String 私有地维护。当调用 intern 方法时，如果字符串池中已经包含一个等于此 String 对象的字符串（是否等于由 String 的 equals 方法来确定），则返回池中的字符串；否则将此 String 对象添加到池中，并且返回此 String 对象的引用。所有的字面值字符串和字符串赋值常量表达式都是内部的。</p>\n<p>如下例子中，变量 str1 会先去字符串常量池中找字符串 “ab”, 如果有相同的字符串则直接返回常量句柄，如果没有此字符串则会先在常量池中创建此字符串，然后再返回常量句柄；而变量 str2 是直接在堆上创建一个变量，如果调用 intern 方法才会把此字符串保存到常量池中。</p>\n<p>字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如 str3 str4）则不会进入字符串池中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>);</span><br><span class=\"line\">System.out.println(str1 == str2);           <span class=\"comment\">//false 引用地址不同</span></span><br><span class=\"line\">System.out.println(str1.equals(str2));      <span class=\"comment\">//true 字符串值相同</span></span><br><span class=\"line\">System.out.println(str1 == str2.intern());  <span class=\"comment\">//true</span></span><br><span class=\"line\">String str3 = <span class=\"string\">\"a\"</span>;</span><br><span class=\"line\">String str4 = <span class=\"string\">\"b\"</span>;</span><br><span class=\"line\">System.out.println(str3 + str4 == str1);    <span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> == str1);      <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>前文中说明了 equals 和 == 的区别，对于 String 而言，== 判断的是引用地址，那么什么时候会出现引用地址相同的情况呢？现在来看，如果给变量赋值的是静态字符串，就会在字符串中找相同字符串，如果有返回引用，这时候就存在相同的引用地址；而 new String 构造的字符串用 == 判断一定是 false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str5 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>);</span><br><span class=\"line\">System.out.println(str2 == str5);           <span class=\"comment\">//false</span></span><br><span class=\"line\">String str6 = <span class=\"string\">\"ab\"</span>;</span><br><span class=\"line\">System.out.println(str1 ==str6);            <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-String-的不可变\"><a href=\"#7-String-的不可变\" class=\"headerlink\" title=\"7. String 的不可变\"></a>7. String 的不可变</h2><p>String 对象是不可变的。从 JDK 文档可以发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象来包含修改后的字符串内容，而最初的 String 对象纹丝未动。</p>\n<p>例如下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">upcase</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.toUpperCase();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String q = <span class=\"string\">\"howdy\"</span>;</span><br><span class=\"line\">    System.out.println(q); <span class=\"comment\">// howdy </span></span><br><span class=\"line\">    String qq = upcase(q);</span><br><span class=\"line\">    System.out.println(qq); <span class=\"comment\">// HOWDY </span></span><br><span class=\"line\">    System.out.println(q); <span class=\"comment\">// howdy </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当把 <code>q</code>传递给<code>upcase()</code>方法时，实际传递的是引用的一个拷贝。每当 String 对象作为方法的参数时，都会复制一份引用，而该引用所指的对象一直在物理位置上没有任何变化。</p>\n<p>回到 upcase() 的定义，传入其中的引用有了名字 s, 只有 upcase() 方法运行时局部引用 s 才存在。一旦 upcase() 结束，s 就消失了。其返回值也就指向了一个新的对象，而 q 仍然在原来的位置。</p>\n<h2 id=\"8-的重载与-StringBuilder\"><a href=\"#8-的重载与-StringBuilder\" class=\"headerlink\" title=\"8. + 的重载与 StringBuilder\"></a>8. + 的重载与 StringBuilder</h2><p>String 对象是不可变的，你可以给一个 String 对象添加任意多的别名，因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，这样也就不会影响到其他引用。</p>\n<p>不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子：操作符 + 可以连接 String。当使用 + 操作符时，编译器会做一定的优化，例如在下面的代码中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String mango = <span class=\"string\">\"mango\"</span>; </span><br><span class=\"line\">String s = <span class=\"string\">\"abc\"</span> + mango + <span class=\"string\">\"def\"</span> + <span class=\"number\">47</span>;</span><br></pre></td></tr></table></figure>\n\n<p>编译器会自动引入<code>java.lang.StringBuilder</code>类（虽然源代码中并没有使用 StringBuilder 类，但因为其高效，编译器会使用它），先创建一个 StringBuilder 对象，对每个字符串调用一次 append 方法，共4次，最后调用 toString() 方法，存为 s。</p>\n<p>现在你可能觉得可以随意使用 String 对象，反正编译器会为你做性能优化。在这之前让我们深入看看编译器会为我们优化到什么程度。下面例子中采用两种方式生成 String：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhitherStringBuilder</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">implicit</span><span class=\"params\">(String[] fields)</span> </span>&#123; </span><br><span class=\"line\">        String result = <span class=\"string\">\"\"</span>; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String field : fields) &#123; </span><br><span class=\"line\">            result += field;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">explicit</span><span class=\"params\">(String[] fields)</span> </span>&#123; </span><br><span class=\"line\">        StringBuilder result = <span class=\"keyword\">new</span> StringBuilder(); </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String field : fields) &#123; </span><br><span class=\"line\">            result.append(field); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.toString(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一种方式中，StringBuilder 是在循环体内部创建的，这意味着每进行一次循环，就会创建一个 StringBuilder 对象。第二种显示定义 StringBuilder 只生成一个 StringBuilder 对象。因此如果使用循环，且可能存在性能问题，那么最好自己创建一个 StringBuilder 对象。</p>"},{"title":"KMP算法","date":"2020-07-17T08:17:33.000Z","typora-copy-images-to":"..\\pictures","_content":"\n本文主要介绍了 KMP算法的基本思想、代码、优化以及时间复杂度分析。\n\n## 1. KMP算法思想\n\n### 1.1 简介\n\n**字符串匹配** 是计算机的基本任务之一。举例来说，即有一个字符串\"BBC ABCDAB ABCDABCDABDE\"，判断该字符串中是否包含另一个字符串\"ABCDABD\"？许多算法可以完成这个任务，[Knuth-Morris-Pratt算法]([https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法))（简称KMP）是最常用的之一。它以三个发明者命名，其中K代表著名科学家Donald Knuth。\n\n接下来，我会先举例对KMP算法的思路进行解释（不涉及任何代码）。\n\n<!--more-->\n\n### 1.2 基本思路\n\n1. 首先，字符串\"BBC ABCDAB ABCDABCDABDE\"（称为文本串）的第一个字符与模式串\"ABCDABD\"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。\n\n   <img src=\"/pictures/bg2013050103.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n2. 因为B与A不匹配，模式串再往后移。\n\n   <img src=\"/pictures/bg2013050104.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n3. 就这样，直到文本串有一个字符，与模式串的第一个字符相同为止。\n\n   <img src=\"/pictures/bg2013050105.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n4. 接着比较文本串和模式串的下一个字符，还是相同。\n\n   <img src=\"/pictures/bg2013050106.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n5. 直到字符串有一个字符，与搜索词对应的字符不相同为止。\n\n   <img src=\"/pictures/bg2013050107.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n6. 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做固然可行，但是效率很差，因为你要把\"搜索位置\"移到已经比较过的位置，重比一遍。\n\n   <img src=\"/pictures/bg2013050108.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n7. 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是\"ABCDAB\"。KMP算法的想法是，**设法利用这个已知信息，不要把\"搜索位置\"移回已经比较过的位置，继续把它向后移，这样就提高了效率**。\n\n   <img src=\"/pictures/bg2013050107-1594975043794.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n8. 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。\n\n   <img src=\"/pictures/bg2013050109.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n9. 已知空格与D不匹配时，前面六个字符\"ABCDAB\"是匹配的。查表可知，最后一个匹配字符B（不匹配字符的前一个字符）对应的\"部分匹配值\"为2，因此按照下面的公式算出向后移动的位数：\n\n   ```java\n   移动位数 = 已匹配的字符数 - 失配字符的前一位字符的部分匹配值\n   ```\n\n   因为 6 - 2 等于4，所以将搜索词向后移动4位。\n\n10. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（\"AB\"），对应的\"部分匹配值\"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。\n\n    <img src=\"/pictures/bg2013050110.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n11. 因为空格与A不匹配，继续后移一位。\n\n    <img src=\"/pictures/bg2013050111.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n12. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。\n\n    <img src=\"/pictures/bg2013050112.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n13. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。\n\n    <img src=\"/pictures/bg2013050113.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n14. 下面介绍《部分匹配表》是如何产生的。\n\n    首先，要了解两个概念：\"前缀\"和\"后缀\"。 \"前缀\"指除了最后一个字符以外，一个字符串的全部头部组合；\"后缀\"指除了第一个字符以外，一个字符串的全部尾部组合。\n\n    <img src=\"/pictures/bg2013050114.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n15. \"部分匹配值\"就是\"前缀\"和\"后缀\"的最大公共元素长度。以\"ABCDABD\"为例，计算过程如下：\n\n    ![img](/pictures/20140725231726921)\n    \n16. \"部分匹配\"的实质是，有时候，字符串头部和尾部会有重复。比如，\"ABCDAB\"之中有两个\"AB\"，那么它的\"部分匹配值\"就是2（\"AB\"的长度）。搜索词移动的时候，第一个\"AB\"向后移动4位（字符串长度-部分匹配值），就可以来到第二个\"AB\"的位置。\n\n    <img src=\"/pictures/bg2013050112-1594975805920.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n到此，我们对于KMP的基本思路有了一个大致的了解，下一部分介绍KMP具体算法细节、代码及优化。\n\n## 2. KMP算法代码及优化\n\n假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？\n\n### 2.1 暴力匹配算法\n\n如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：\n\n- 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；\n- 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。\n\n暴力匹配代码如下：\n\n```java\nprivate int ViolentMatch(char[] s, char[] p){\n    int sLen = s.length;\n    int pLen = p.length;\n\n    int i = 0, j = 0;\n    while (i < sLen && j < pLen){\n        if(s[i] == p[j]){\n            i++;\n            j++;\n        }else{\n            i = i - j + 1;\n            j = 0;\n        }\n    }\n    if(j == pLen){\n        return i - j;\n    }else{\n        return -1;\n    }\n}\n```\n\n### 2.2 KMP算法\n\n#### 2.2.1 求解 next 数组\n\n##### 2.2.1.1 基本思路\n\n前文已经计算过“部分匹配表”，即前缀和后缀的最大公共元素长度，如下图所示：\n\n![img](/pictures/20140725231726921)\n\n由前文可知，失配时，模式串向右移动的位数公式为：\n\n```bash\n移动位数 = 已匹配的字符数 - 失配字符的前一位字符的最大公共元素长度\n```\n\n由此我们发现，当匹配一个字符失配时，我们并不会考虑当前字符，而是看失配字符的前一个字符的最大公共元素长度，如此，便引出了next数组。**next 数组相当于最大长度值整体向右移动一位，然后初值赋为-1.** 因而，对于给定的模式串，它的最大长度及next数组分别如下：\n\n![img](/pictures/20140728110939595)\n\n求得next数组之后，失配时模式串向右移动的位数为：\n\n```bash\n移动位数 = 失配字符所在位置 - 失配字符对应的next值\n```\n\n##### 2.2.1.2 代码计算 next 数组\n\n1. 如果**对于值 k, 已有 p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1，相当于next[j] = k**。究其本质，**next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀**。有了这个next 数组，在KMP匹配中，当模式串中 j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动 j - next[j] 位。\n\n2. 下面的问题是：已知next [0, ..., j]，如何求出next [j + 1]呢？\n\n   - 若p[k] == p[j]，则next[j + 1] = next [j] + 1 = k + 1。\n\n     如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。\n\n     ![img](/pictures/20140729182154066)\n\n   - 若p[k ] ≠ p[j]，如果此时 p[next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。\n\n     如下图所示，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。  \n     ![img](/pictures/20140729181940812)   \n\n     结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk'-1 pk' = pj-k' pj-1 pj，则最大相同的前缀后缀长度为k' + 1，从而next [j + 1] = k’ + 1 = next [k' ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。\n\n     那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？ 这又归根到next数组的含义。**我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。**\n\n3. 综上，可以通过递推求得 next 数组，代码如下：\n\n   ```java\n   public int[] getNext(char[] p){\n       int pLen = p.length;\n       int[] next = new int[pLen];\n       next[0] = -1;\n       int k = -1;\n       int j = 0;\n       while (j < pLen - 1){\n           // p[k] 表示前缀；p[j] 表示后缀\n           if(k == -1 || p[j] == p[k]){\n               ++k;\n               next[++j] = k;\n           }else{\n               k = next[k];\n           }\n       }\n       return next;\n   }\n   ```\n\n##### 2.2.1.3 总结 next 数组含义\n\n1. 代表失配字符之前的字符串中，有多大长度的相同前缀后缀。\n2. 在某个字符失配后，next 值会告诉你下一步匹配中，模式串应该跳到哪个位置。如果next [j] 等于0或 -1，则跳到模式串的开头字符；若next [j] = k 且 k > 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。\n\n#### 2.2.2 KMP 算法\n\n根据上文的分析，KMP算法的代码如下：\n\n```java\npublic int kmp(char[] s, char[] p, int[] next){\n    int i = 0, j = 0;\n    int sLen = s.length;\n    int pLen = p.length;\n    while (i < sLen && j < pLen){\n        if(j == -1 || s[i] == p[j]){\n            i++;\n            j++;\n        }else{\n            j = next[j];\n        }\n    }\n    if(j == pLen){\n        return i - j;\n    }else{\n        return -1;\n    }\n}\n```\n\n#### 2.2.3 next 数组的优化\n\n行文至此，我们全面了解了KMP算法的基本思路、流程、代码以及next 数组的求解，但忽略了一个小问题。\n\n比如，如果用之前的next 数组方法求模式串“abab”的 next 数组，可得其 next 数组为 -1 0 0 1，当它跟下图中的文本串去匹配的时候，发现 b 跟 c 失配，于是模式串右移 j - next[j] = 3 - 1 = 2位。\n\n<img src=\"/pictures/8394323_1308075859Zfue.jpg\" alt=\"8394323_1308075859Zfue\" style=\"zoom:67%;\" />\n\n右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？\n\n<img src=\"/pictures/8394323_13080758591kyV-1595069195969.jpg\" alt=\"8394323_13080758591kyV\" style=\"zoom:67%;\" />\n\n问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。\n\n因此，求解 next 数组的代码优化如下：\n\n```java\npublic int[] getNextval(char[] p){\n    int pLen = p.length;\n    int[] next = new int[pLen];\n    next[0] = -1;\n    int k = -1;\n    int j = 0;\n    while (j < pLen - 1){\n        // p[k] 表示前缀；p[j] 表示后缀\n        if(k == -1 || p[j] == p[k]){\n            ++k;\n            ++j;\n            if(p[j] != p[k]){\n                next[j] = k;\n            }else{\n                // 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]\n                next[j] = next[k];\n            }\n\n        }else{\n            k = next[k];\n        }\n    }\n    return next;\n}\n```\n\n## 3. KMP 算法时间复杂度分析\n\n我们先来回顾一下KMP算法的流程，假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置：\n\n1. 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；\n2. 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。\n\n我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。\n\n所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。\n\n## 4. 参考文献\n\n1. https://blog.csdn.net/v_july_v/article/details/7041827\n\n2. [http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)\n\n\n\n","source":"_posts/KMP算法.md","raw":"---\ntitle: KMP算法\ndate: 2020-07-17 16:17:33\ntags:\n  - String\n  - Algorithm\ncategories: Algorithm\ntypora-copy-images-to: ..\\pictures\n---\n\n本文主要介绍了 KMP算法的基本思想、代码、优化以及时间复杂度分析。\n\n## 1. KMP算法思想\n\n### 1.1 简介\n\n**字符串匹配** 是计算机的基本任务之一。举例来说，即有一个字符串\"BBC ABCDAB ABCDABCDABDE\"，判断该字符串中是否包含另一个字符串\"ABCDABD\"？许多算法可以完成这个任务，[Knuth-Morris-Pratt算法]([https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法))（简称KMP）是最常用的之一。它以三个发明者命名，其中K代表著名科学家Donald Knuth。\n\n接下来，我会先举例对KMP算法的思路进行解释（不涉及任何代码）。\n\n<!--more-->\n\n### 1.2 基本思路\n\n1. 首先，字符串\"BBC ABCDAB ABCDABCDABDE\"（称为文本串）的第一个字符与模式串\"ABCDABD\"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。\n\n   <img src=\"/pictures/bg2013050103.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n2. 因为B与A不匹配，模式串再往后移。\n\n   <img src=\"/pictures/bg2013050104.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n3. 就这样，直到文本串有一个字符，与模式串的第一个字符相同为止。\n\n   <img src=\"/pictures/bg2013050105.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n4. 接着比较文本串和模式串的下一个字符，还是相同。\n\n   <img src=\"/pictures/bg2013050106.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n5. 直到字符串有一个字符，与搜索词对应的字符不相同为止。\n\n   <img src=\"/pictures/bg2013050107.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n6. 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做固然可行，但是效率很差，因为你要把\"搜索位置\"移到已经比较过的位置，重比一遍。\n\n   <img src=\"/pictures/bg2013050108.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n7. 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是\"ABCDAB\"。KMP算法的想法是，**设法利用这个已知信息，不要把\"搜索位置\"移回已经比较过的位置，继续把它向后移，这样就提高了效率**。\n\n   <img src=\"/pictures/bg2013050107-1594975043794.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n8. 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。\n\n   <img src=\"/pictures/bg2013050109.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n9. 已知空格与D不匹配时，前面六个字符\"ABCDAB\"是匹配的。查表可知，最后一个匹配字符B（不匹配字符的前一个字符）对应的\"部分匹配值\"为2，因此按照下面的公式算出向后移动的位数：\n\n   ```java\n   移动位数 = 已匹配的字符数 - 失配字符的前一位字符的部分匹配值\n   ```\n\n   因为 6 - 2 等于4，所以将搜索词向后移动4位。\n\n10. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（\"AB\"），对应的\"部分匹配值\"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。\n\n    <img src=\"/pictures/bg2013050110.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n11. 因为空格与A不匹配，继续后移一位。\n\n    <img src=\"/pictures/bg2013050111.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n12. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。\n\n    <img src=\"/pictures/bg2013050112.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n13. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。\n\n    <img src=\"/pictures/bg2013050113.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n14. 下面介绍《部分匹配表》是如何产生的。\n\n    首先，要了解两个概念：\"前缀\"和\"后缀\"。 \"前缀\"指除了最后一个字符以外，一个字符串的全部头部组合；\"后缀\"指除了第一个字符以外，一个字符串的全部尾部组合。\n\n    <img src=\"/pictures/bg2013050114.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n15. \"部分匹配值\"就是\"前缀\"和\"后缀\"的最大公共元素长度。以\"ABCDABD\"为例，计算过程如下：\n\n    ![img](/pictures/20140725231726921)\n    \n16. \"部分匹配\"的实质是，有时候，字符串头部和尾部会有重复。比如，\"ABCDAB\"之中有两个\"AB\"，那么它的\"部分匹配值\"就是2（\"AB\"的长度）。搜索词移动的时候，第一个\"AB\"向后移动4位（字符串长度-部分匹配值），就可以来到第二个\"AB\"的位置。\n\n    <img src=\"/pictures/bg2013050112-1594975805920.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n到此，我们对于KMP的基本思路有了一个大致的了解，下一部分介绍KMP具体算法细节、代码及优化。\n\n## 2. KMP算法代码及优化\n\n假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？\n\n### 2.1 暴力匹配算法\n\n如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：\n\n- 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；\n- 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。\n\n暴力匹配代码如下：\n\n```java\nprivate int ViolentMatch(char[] s, char[] p){\n    int sLen = s.length;\n    int pLen = p.length;\n\n    int i = 0, j = 0;\n    while (i < sLen && j < pLen){\n        if(s[i] == p[j]){\n            i++;\n            j++;\n        }else{\n            i = i - j + 1;\n            j = 0;\n        }\n    }\n    if(j == pLen){\n        return i - j;\n    }else{\n        return -1;\n    }\n}\n```\n\n### 2.2 KMP算法\n\n#### 2.2.1 求解 next 数组\n\n##### 2.2.1.1 基本思路\n\n前文已经计算过“部分匹配表”，即前缀和后缀的最大公共元素长度，如下图所示：\n\n![img](/pictures/20140725231726921)\n\n由前文可知，失配时，模式串向右移动的位数公式为：\n\n```bash\n移动位数 = 已匹配的字符数 - 失配字符的前一位字符的最大公共元素长度\n```\n\n由此我们发现，当匹配一个字符失配时，我们并不会考虑当前字符，而是看失配字符的前一个字符的最大公共元素长度，如此，便引出了next数组。**next 数组相当于最大长度值整体向右移动一位，然后初值赋为-1.** 因而，对于给定的模式串，它的最大长度及next数组分别如下：\n\n![img](/pictures/20140728110939595)\n\n求得next数组之后，失配时模式串向右移动的位数为：\n\n```bash\n移动位数 = 失配字符所在位置 - 失配字符对应的next值\n```\n\n##### 2.2.1.2 代码计算 next 数组\n\n1. 如果**对于值 k, 已有 p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1，相当于next[j] = k**。究其本质，**next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀**。有了这个next 数组，在KMP匹配中，当模式串中 j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动 j - next[j] 位。\n\n2. 下面的问题是：已知next [0, ..., j]，如何求出next [j + 1]呢？\n\n   - 若p[k] == p[j]，则next[j + 1] = next [j] + 1 = k + 1。\n\n     如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。\n\n     ![img](/pictures/20140729182154066)\n\n   - 若p[k ] ≠ p[j]，如果此时 p[next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。\n\n     如下图所示，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。  \n     ![img](/pictures/20140729181940812)   \n\n     结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk'-1 pk' = pj-k' pj-1 pj，则最大相同的前缀后缀长度为k' + 1，从而next [j + 1] = k’ + 1 = next [k' ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。\n\n     那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？ 这又归根到next数组的含义。**我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。**\n\n3. 综上，可以通过递推求得 next 数组，代码如下：\n\n   ```java\n   public int[] getNext(char[] p){\n       int pLen = p.length;\n       int[] next = new int[pLen];\n       next[0] = -1;\n       int k = -1;\n       int j = 0;\n       while (j < pLen - 1){\n           // p[k] 表示前缀；p[j] 表示后缀\n           if(k == -1 || p[j] == p[k]){\n               ++k;\n               next[++j] = k;\n           }else{\n               k = next[k];\n           }\n       }\n       return next;\n   }\n   ```\n\n##### 2.2.1.3 总结 next 数组含义\n\n1. 代表失配字符之前的字符串中，有多大长度的相同前缀后缀。\n2. 在某个字符失配后，next 值会告诉你下一步匹配中，模式串应该跳到哪个位置。如果next [j] 等于0或 -1，则跳到模式串的开头字符；若next [j] = k 且 k > 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。\n\n#### 2.2.2 KMP 算法\n\n根据上文的分析，KMP算法的代码如下：\n\n```java\npublic int kmp(char[] s, char[] p, int[] next){\n    int i = 0, j = 0;\n    int sLen = s.length;\n    int pLen = p.length;\n    while (i < sLen && j < pLen){\n        if(j == -1 || s[i] == p[j]){\n            i++;\n            j++;\n        }else{\n            j = next[j];\n        }\n    }\n    if(j == pLen){\n        return i - j;\n    }else{\n        return -1;\n    }\n}\n```\n\n#### 2.2.3 next 数组的优化\n\n行文至此，我们全面了解了KMP算法的基本思路、流程、代码以及next 数组的求解，但忽略了一个小问题。\n\n比如，如果用之前的next 数组方法求模式串“abab”的 next 数组，可得其 next 数组为 -1 0 0 1，当它跟下图中的文本串去匹配的时候，发现 b 跟 c 失配，于是模式串右移 j - next[j] = 3 - 1 = 2位。\n\n<img src=\"/pictures/8394323_1308075859Zfue.jpg\" alt=\"8394323_1308075859Zfue\" style=\"zoom:67%;\" />\n\n右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？\n\n<img src=\"/pictures/8394323_13080758591kyV-1595069195969.jpg\" alt=\"8394323_13080758591kyV\" style=\"zoom:67%;\" />\n\n问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。\n\n因此，求解 next 数组的代码优化如下：\n\n```java\npublic int[] getNextval(char[] p){\n    int pLen = p.length;\n    int[] next = new int[pLen];\n    next[0] = -1;\n    int k = -1;\n    int j = 0;\n    while (j < pLen - 1){\n        // p[k] 表示前缀；p[j] 表示后缀\n        if(k == -1 || p[j] == p[k]){\n            ++k;\n            ++j;\n            if(p[j] != p[k]){\n                next[j] = k;\n            }else{\n                // 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]\n                next[j] = next[k];\n            }\n\n        }else{\n            k = next[k];\n        }\n    }\n    return next;\n}\n```\n\n## 3. KMP 算法时间复杂度分析\n\n我们先来回顾一下KMP算法的流程，假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置：\n\n1. 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；\n2. 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。\n\n我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。\n\n所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。\n\n## 4. 参考文献\n\n1. https://blog.csdn.net/v_july_v/article/details/7041827\n\n2. [http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)\n\n\n\n","slug":"KMP算法","published":1,"updated":"2020-07-18T11:22:56.433Z","_id":"ckcrjzdl40000souq1s2u9msj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要介绍了 KMP算法的基本思想、代码、优化以及时间复杂度分析。</p>\n<h2 id=\"1-KMP算法思想\"><a href=\"#1-KMP算法思想\" class=\"headerlink\" title=\"1. KMP算法思想\"></a>1. KMP算法思想</h2><h3 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h3><p><strong>字符串匹配</strong> 是计算机的基本任务之一。举例来说，即有一个字符串”BBC ABCDAB ABCDABCDABDE”，判断该字符串中是否包含另一个字符串”ABCDABD”？许多算法可以完成这个任务，<a href=\"[https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法)\">Knuth-Morris-Pratt算法</a>（简称KMP）是最常用的之一。它以三个发明者命名，其中K代表著名科学家Donald Knuth。</p>\n<p>接下来，我会先举例对KMP算法的思路进行解释（不涉及任何代码）。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-2-基本思路\"><a href=\"#1-2-基本思路\" class=\"headerlink\" title=\"1.2 基本思路\"></a>1.2 基本思路</h3><ol>\n<li><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”（称为文本串）的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>\n<img src=\"/pictures/bg2013050103.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>因为B与A不匹配，模式串再往后移。</p>\n<img src=\"/pictures/bg2013050104.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>就这样，直到文本串有一个字符，与模式串的第一个字符相同为止。</p>\n<img src=\"/pictures/bg2013050105.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>接着比较文本串和模式串的下一个字符，还是相同。</p>\n<img src=\"/pictures/bg2013050106.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>\n<img src=\"/pictures/bg2013050107.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做固然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>\n<img src=\"/pictures/bg2013050108.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。</p>\n<img src=\"/pictures/bg2013050107-1594975043794.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>\n<img src=\"/pictures/bg2013050109.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B（不匹配字符的前一个字符）对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的部分匹配值</span><br></pre></td></tr></table></figure>\n\n<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>\n</li>\n<li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>\n<img src=\"/pictures/bg2013050110.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>因为空格与A不匹配，继续后移一位。</p>\n<img src=\"/pictures/bg2013050111.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>\n<img src=\"/pictures/bg2013050112.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>\n<img src=\"/pictures/bg2013050113.png\" alt=\"img\" style=\"zoom: 67%;\" />\n</li>\n<li><p>下面介绍《部分匹配表》是如何产生的。</p>\n<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>\n<img src=\"/pictures/bg2013050114.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>“部分匹配值”就是”前缀”和”后缀”的最大公共元素长度。以”ABCDABD”为例，计算过程如下：</p>\n<p><img src=\"/pictures/20140725231726921\" alt=\"img\"></p>\n</li>\n<li><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>\n<img src=\"/pictures/bg2013050112-1594975805920.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n</li>\n</ol>\n<p>到此，我们对于KMP的基本思路有了一个大致的了解，下一部分介绍KMP具体算法细节、代码及优化。</p>\n<h2 id=\"2-KMP算法代码及优化\"><a href=\"#2-KMP算法代码及优化\" class=\"headerlink\" title=\"2. KMP算法代码及优化\"></a>2. KMP算法代码及优化</h2><p>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>\n<h3 id=\"2-1-暴力匹配算法\"><a href=\"#2-1-暴力匹配算法\" class=\"headerlink\" title=\"2.1 暴力匹配算法\"></a>2.1 暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>\n<ul>\n<li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li>\n<li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>\n</ul>\n<p>暴力匹配代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ViolentMatch</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s, <span class=\"keyword\">char</span>[] p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == p[j])&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            i = i - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">            j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j == pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-KMP算法\"><a href=\"#2-2-KMP算法\" class=\"headerlink\" title=\"2.2 KMP算法\"></a>2.2 KMP算法</h3><h4 id=\"2-2-1-求解-next-数组\"><a href=\"#2-2-1-求解-next-数组\" class=\"headerlink\" title=\"2.2.1 求解 next 数组\"></a>2.2.1 求解 next 数组</h4><h5 id=\"2-2-1-1-基本思路\"><a href=\"#2-2-1-1-基本思路\" class=\"headerlink\" title=\"2.2.1.1 基本思路\"></a>2.2.1.1 基本思路</h5><p>前文已经计算过“部分匹配表”，即前缀和后缀的最大公共元素长度，如下图所示：</p>\n<p><img src=\"/pictures/20140725231726921\" alt=\"img\"></p>\n<p>由前文可知，失配时，模式串向右移动的位数公式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的最大公共元素长度</span><br></pre></td></tr></table></figure>\n\n<p>由此我们发现，当匹配一个字符失配时，我们并不会考虑当前字符，而是看失配字符的前一个字符的最大公共元素长度，如此，便引出了next数组。<strong>next 数组相当于最大长度值整体向右移动一位，然后初值赋为-1.</strong> 因而，对于给定的模式串，它的最大长度及next数组分别如下：</p>\n<p><img src=\"/pictures/20140728110939595\" alt=\"img\"></p>\n<p>求得next数组之后，失配时模式串向右移动的位数为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移动位数 = 失配字符所在位置 - 失配字符对应的next值</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-1-2-代码计算-next-数组\"><a href=\"#2-2-1-2-代码计算-next-数组\" class=\"headerlink\" title=\"2.2.1.2 代码计算 next 数组\"></a>2.2.1.2 代码计算 next 数组</h5><ol>\n<li><p>如果<strong>对于值 k, 已有 p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k</strong>。究其本质，<strong>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀</strong>。有了这个next 数组，在KMP匹配中，当模式串中 j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动 j - next[j] 位。</p>\n</li>\n<li><p>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</p>\n<ul>\n<li><p>若p[k] == p[j]，则next[j + 1] = next [j] + 1 = k + 1。</p>\n<p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p>\n<p><img src=\"/pictures/20140729182154066\" alt=\"img\"></p>\n</li>\n<li><p>若p[k ] ≠ p[j]，如果此时 p[next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</p>\n<p>如下图所示，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。<br><img src=\"/pictures/20140729181940812\" alt=\"img\">   </p>\n<p>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk’-1 pk’ = pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] = k’ + 1 = next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。</p>\n<p>那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？ 这又归根到next数组的含义。<strong>我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。</strong></p>\n</li>\n</ul>\n</li>\n<li><p>综上，可以通过递推求得 next 数组，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] getNext(<span class=\"keyword\">char</span>[] p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[pLen];</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; pLen - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == -<span class=\"number\">1</span> || p[j] == p[k])&#123;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">            next[++j] = k;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            k = next[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h5 id=\"2-2-1-3-总结-next-数组含义\"><a href=\"#2-2-1-3-总结-next-数组含义\" class=\"headerlink\" title=\"2.2.1.3 总结 next 数组含义\"></a>2.2.1.3 总结 next 数组含义</h5><ol>\n<li>代表失配字符之前的字符串中，有多大长度的相同前缀后缀。</li>\n<li>在某个字符失配后，next 值会告诉你下一步匹配中，模式串应该跳到哪个位置。如果next [j] 等于0或 -1，则跳到模式串的开头字符；若next [j] = k 且 k &gt; 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</li>\n</ol>\n<h4 id=\"2-2-2-KMP-算法\"><a href=\"#2-2-2-KMP-算法\" class=\"headerlink\" title=\"2.2.2 KMP 算法\"></a>2.2.2 KMP 算法</h4><p>根据上文的分析，KMP算法的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kmp</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s, <span class=\"keyword\">char</span>[] p, <span class=\"keyword\">int</span>[] next)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == -<span class=\"number\">1</span> || s[i] == p[j])&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j == pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-3-next-数组的优化\"><a href=\"#2-2-3-next-数组的优化\" class=\"headerlink\" title=\"2.2.3 next 数组的优化\"></a>2.2.3 next 数组的优化</h4><p>行文至此，我们全面了解了KMP算法的基本思路、流程、代码以及next 数组的求解，但忽略了一个小问题。</p>\n<p>比如，如果用之前的next 数组方法求模式串“abab”的 next 数组，可得其 next 数组为 -1 0 0 1，当它跟下图中的文本串去匹配的时候，发现 b 跟 c 失配，于是模式串右移 j - next[j] = 3 - 1 = 2位。</p>\n<img src=\"/pictures/8394323_1308075859Zfue.jpg\" alt=\"8394323_1308075859Zfue\" style=\"zoom:67%;\" />\n\n<p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</p>\n<img src=\"/pictures/8394323_13080758591kyV-1595069195969.jpg\" alt=\"8394323_13080758591kyV\" style=\"zoom:67%;\" />\n\n<p>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p>\n<p>因此，求解 next 数组的代码优化如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] getNextval(<span class=\"keyword\">char</span>[] p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[pLen];</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; pLen - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == -<span class=\"number\">1</span> || p[j] == p[k])&#123;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[j] != p[k])&#123;</span><br><span class=\"line\">                next[j] = k;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class=\"line\">                next[j] = next[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            k = next[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-KMP-算法时间复杂度分析\"><a href=\"#3-KMP-算法时间复杂度分析\" class=\"headerlink\" title=\"3. KMP 算法时间复杂度分析\"></a>3. KMP 算法时间复杂度分析</h2><p>我们先来回顾一下KMP算法的流程，假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置：</p>\n<ol>\n<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>\n<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</li>\n</ol>\n<p>我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。</p>\n<p>所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p>\n<h2 id=\"4-参考文献\"><a href=\"#4-参考文献\" class=\"headerlink\" title=\"4. 参考文献\"></a>4. 参考文献</h2><ol>\n<li><p><a href=\"https://blog.csdn.net/v_july_v/article/details/7041827\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>\n</li>\n</ol>\n","site":{"data":{}},"length":5400,"excerpt":"<p>本文主要介绍了 KMP算法的基本思想、代码、优化以及时间复杂度分析。</p>\n<h2 id=\"1-KMP算法思想\"><a href=\"#1-KMP算法思想\" class=\"headerlink\" title=\"1. KMP算法思想\"></a>1. KMP算法思想</h2><h3 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h3><p><strong>字符串匹配</strong> 是计算机的基本任务之一。举例来说，即有一个字符串”BBC ABCDAB ABCDABCDABDE”，判断该字符串中是否包含另一个字符串”ABCDABD”？许多算法可以完成这个任务，<a href=\"[https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法)\">Knuth-Morris-Pratt算法</a>（简称KMP）是最常用的之一。它以三个发明者命名，其中K代表著名科学家Donald Knuth。</p>\n<p>接下来，我会先举例对KMP算法的思路进行解释（不涉及任何代码）。</p>","more":"<h3 id=\"1-2-基本思路\"><a href=\"#1-2-基本思路\" class=\"headerlink\" title=\"1.2 基本思路\"></a>1.2 基本思路</h3><ol>\n<li><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”（称为文本串）的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>\n<img src=\"/pictures/bg2013050103.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>因为B与A不匹配，模式串再往后移。</p>\n<img src=\"/pictures/bg2013050104.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>就这样，直到文本串有一个字符，与模式串的第一个字符相同为止。</p>\n<img src=\"/pictures/bg2013050105.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>接着比较文本串和模式串的下一个字符，还是相同。</p>\n<img src=\"/pictures/bg2013050106.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>\n<img src=\"/pictures/bg2013050107.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做固然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>\n<img src=\"/pictures/bg2013050108.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。</p>\n<img src=\"/pictures/bg2013050107-1594975043794.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>\n<img src=\"/pictures/bg2013050109.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B（不匹配字符的前一个字符）对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的部分匹配值</span><br></pre></td></tr></table></figure>\n\n<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>\n</li>\n<li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>\n<img src=\"/pictures/bg2013050110.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>因为空格与A不匹配，继续后移一位。</p>\n<img src=\"/pictures/bg2013050111.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>\n<img src=\"/pictures/bg2013050112.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>\n<img src=\"/pictures/bg2013050113.png\" alt=\"img\" style=\"zoom: 67%;\" />\n</li>\n<li><p>下面介绍《部分匹配表》是如何产生的。</p>\n<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>\n<img src=\"/pictures/bg2013050114.png\" alt=\"img\" style=\"zoom:67%;\" />\n</li>\n<li><p>“部分匹配值”就是”前缀”和”后缀”的最大公共元素长度。以”ABCDABD”为例，计算过程如下：</p>\n<p><img src=\"/pictures/20140725231726921\" alt=\"img\"></p>\n</li>\n<li><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>\n<img src=\"/pictures/bg2013050112-1594975805920.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n</li>\n</ol>\n<p>到此，我们对于KMP的基本思路有了一个大致的了解，下一部分介绍KMP具体算法细节、代码及优化。</p>\n<h2 id=\"2-KMP算法代码及优化\"><a href=\"#2-KMP算法代码及优化\" class=\"headerlink\" title=\"2. KMP算法代码及优化\"></a>2. KMP算法代码及优化</h2><p>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</p>\n<h3 id=\"2-1-暴力匹配算法\"><a href=\"#2-1-暴力匹配算法\" class=\"headerlink\" title=\"2.1 暴力匹配算法\"></a>2.1 暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p>\n<ul>\n<li>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</li>\n<li>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li>\n</ul>\n<p>暴力匹配代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ViolentMatch</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s, <span class=\"keyword\">char</span>[] p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == p[j])&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            i = i - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">            j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j == pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-KMP算法\"><a href=\"#2-2-KMP算法\" class=\"headerlink\" title=\"2.2 KMP算法\"></a>2.2 KMP算法</h3><h4 id=\"2-2-1-求解-next-数组\"><a href=\"#2-2-1-求解-next-数组\" class=\"headerlink\" title=\"2.2.1 求解 next 数组\"></a>2.2.1 求解 next 数组</h4><h5 id=\"2-2-1-1-基本思路\"><a href=\"#2-2-1-1-基本思路\" class=\"headerlink\" title=\"2.2.1.1 基本思路\"></a>2.2.1.1 基本思路</h5><p>前文已经计算过“部分匹配表”，即前缀和后缀的最大公共元素长度，如下图所示：</p>\n<p><img src=\"/pictures/20140725231726921\" alt=\"img\"></p>\n<p>由前文可知，失配时，模式串向右移动的位数公式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移动位数 = 已匹配的字符数 - 失配字符的前一位字符的最大公共元素长度</span><br></pre></td></tr></table></figure>\n\n<p>由此我们发现，当匹配一个字符失配时，我们并不会考虑当前字符，而是看失配字符的前一个字符的最大公共元素长度，如此，便引出了next数组。<strong>next 数组相当于最大长度值整体向右移动一位，然后初值赋为-1.</strong> 因而，对于给定的模式串，它的最大长度及next数组分别如下：</p>\n<p><img src=\"/pictures/20140728110939595\" alt=\"img\"></p>\n<p>求得next数组之后，失配时模式串向右移动的位数为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">移动位数 = 失配字符所在位置 - 失配字符对应的next值</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-1-2-代码计算-next-数组\"><a href=\"#2-2-1-2-代码计算-next-数组\" class=\"headerlink\" title=\"2.2.1.2 代码计算 next 数组\"></a>2.2.1.2 代码计算 next 数组</h5><ol>\n<li><p>如果<strong>对于值 k, 已有 p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k</strong>。究其本质，<strong>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀</strong>。有了这个next 数组，在KMP匹配中，当模式串中 j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动 j - next[j] 位。</p>\n</li>\n<li><p>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</p>\n<ul>\n<li><p>若p[k] == p[j]，则next[j + 1] = next [j] + 1 = k + 1。</p>\n<p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p>\n<p><img src=\"/pictures/20140729182154066\" alt=\"img\"></p>\n</li>\n<li><p>若p[k ] ≠ p[j]，如果此时 p[next[k] ] == p[j]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</p>\n<p>如下图所示，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。<br><img src=\"/pictures/20140729181940812\" alt=\"img\">   </p>\n<p>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk’-1 pk’ = pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] = k’ + 1 = next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。</p>\n<p>那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？ 这又归根到next数组的含义。<strong>我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。</strong></p>\n</li>\n</ul>\n</li>\n<li><p>综上，可以通过递推求得 next 数组，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] getNext(<span class=\"keyword\">char</span>[] p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[pLen];</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; pLen - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == -<span class=\"number\">1</span> || p[j] == p[k])&#123;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">            next[++j] = k;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            k = next[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h5 id=\"2-2-1-3-总结-next-数组含义\"><a href=\"#2-2-1-3-总结-next-数组含义\" class=\"headerlink\" title=\"2.2.1.3 总结 next 数组含义\"></a>2.2.1.3 总结 next 数组含义</h5><ol>\n<li>代表失配字符之前的字符串中，有多大长度的相同前缀后缀。</li>\n<li>在某个字符失配后，next 值会告诉你下一步匹配中，模式串应该跳到哪个位置。如果next [j] 等于0或 -1，则跳到模式串的开头字符；若next [j] = k 且 k &gt; 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</li>\n</ol>\n<h4 id=\"2-2-2-KMP-算法\"><a href=\"#2-2-2-KMP-算法\" class=\"headerlink\" title=\"2.2.2 KMP 算法\"></a>2.2.2 KMP 算法</h4><p>根据上文的分析，KMP算法的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kmp</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s, <span class=\"keyword\">char</span>[] p, <span class=\"keyword\">int</span>[] next)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == -<span class=\"number\">1</span> || s[i] == p[j])&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j == pLen)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-3-next-数组的优化\"><a href=\"#2-2-3-next-数组的优化\" class=\"headerlink\" title=\"2.2.3 next 数组的优化\"></a>2.2.3 next 数组的优化</h4><p>行文至此，我们全面了解了KMP算法的基本思路、流程、代码以及next 数组的求解，但忽略了一个小问题。</p>\n<p>比如，如果用之前的next 数组方法求模式串“abab”的 next 数组，可得其 next 数组为 -1 0 0 1，当它跟下图中的文本串去匹配的时候，发现 b 跟 c 失配，于是模式串右移 j - next[j] = 3 - 1 = 2位。</p>\n<img src=\"/pictures/8394323_1308075859Zfue.jpg\" alt=\"8394323_1308075859Zfue\" style=\"zoom:67%;\" />\n\n<p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</p>\n<img src=\"/pictures/8394323_13080758591kyV-1595069195969.jpg\" alt=\"8394323_13080758591kyV\" style=\"zoom:67%;\" />\n\n<p>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。</p>\n<p>因此，求解 next 数组的代码优化如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] getNextval(<span class=\"keyword\">char</span>[] p)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pLen = p.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[pLen];</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; pLen - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// p[k] 表示前缀；p[j] 表示后缀</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == -<span class=\"number\">1</span> || p[j] == p[k])&#123;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[j] != p[k])&#123;</span><br><span class=\"line\">                next[j] = k;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 因为不能出现p[j] = p[next[j]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class=\"line\">                next[j] = next[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            k = next[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-KMP-算法时间复杂度分析\"><a href=\"#3-KMP-算法时间复杂度分析\" class=\"headerlink\" title=\"3. KMP 算法时间复杂度分析\"></a>3. KMP 算法时间复杂度分析</h2><p>我们先来回顾一下KMP算法的流程，假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置：</p>\n<ol>\n<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>\n<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</li>\n</ol>\n<p>我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。</p>\n<p>所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p>\n<h2 id=\"4-参考文献\"><a href=\"#4-参考文献\" class=\"headerlink\" title=\"4. 参考文献\"></a>4. 参考文献</h2><ol>\n<li><p><a href=\"https://blog.csdn.net/v_july_v/article/details/7041827\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>\n</li>\n</ol>"},{"title":"JSON与Java对象的转换","date":"2020-07-23T06:36:31.000Z","typora-copy-images-to":"..\\pictures","_content":"\n本文简要介绍了 JSON 的定义、语法规则，同时总结了两个把 JSON 字符串转为 JavaBean 的库分别是 json-lib、fastjson，另外还有 json 数据的传输与接收的简单使用。\n\n## 1. JSON\n\n### 1.1 什么是 JSON？\n\n**JSON（JavaScript Object Notation，JavaScript对象表示法）：**（from Wikipedia）是一种由道格拉斯·克罗克福特构想和设计、*轻量级的数据交换语言*，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是*独立于语言的文本格式*，并且采用了类似于C语言家族的一些习惯。\n\nJSON 数据格式与语言无关。即便它源自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。\n\n<!--more-->\n\n### 1.2 JSON 语法规则\n\n- 数据格式为 键/值 对（一个名称对应一个值）\n\n```json\n\"name\":\"julia\"\n```\n\n- 数据由逗号分隔\n- 大括号保存对象（对象可以保存多个键值对）\n\n```json\n{\"name\":\"julia\", \"url\":\"juliajiang7.github.io/\"}\n```\n\n- 方括号保存数组，数组可以包含对象\n\n```json\n\"sites\":[\n    {\"name\":\"julia\", \"url\":\"juliajiang7.github.io\"},\n    {\"name\":\"Google\", \"url\":\"www.google.com\"}\n]\n```\n\n详细请参考 [JSON教程](https://www.runoob.com/json/json-tutorial.html)\n\n## 2. 使用 json-lib\n\nhttp://json-lib.sourceforge.net/\n\nJSON-lib is a java library for transforming beans, maps, collections, java arrays and XML to JSON and back again to beans and DynaBeans.\nIt is based on the work by Douglas Crockford in http://www.json.org/java.\n\n### 2.1 引入 maven\n\n```xml\n<dependency>\n    <groupId>net.sf.json-lib</groupId>\n    <artifactId>json-lib</artifactId>\n    <version>2.2.3</version>\n    <classifier>jdk15</classifier>\n</dependency>\n```\n\n### 2.2 json 对象转为 Java 对象\n\n#### 2.2.1 创建实体 Student \n\n```java\npublic class Student {\n    private String name;\n    private Integer age;\n    private Boolean isValid;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public Boolean getIsValid() {\n        return isValid;\n    }\n\n    public void setIsValid(Boolean valid) {\n        isValid = valid;\n    }\n}\n```\n\n#### 2.2.2 转换对象\n\n```java\n@Test\npublic void test(){\n    String jsonStr = \"{\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true}\";\n    // 将json字符串转为JSONObject对象\n    JSONObject jsonObject = JSONObject.fromObject(jsonStr);\n    // 将JSONObject对象转为Student对象\n    Student student = (Student) JSONObject.toBean(jsonObject, Student.class);\n    System.out.println(student);\n}\n// 输出：\n// Student{name='julia', age=16, isValid=true}\n```\n\n### 2.3 json 数组转为 Java 的 List\\<T>\n\n```java\n@Test\npublic void test2(){\n    String jsonStr = \"[{\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true}, \" +\n        \"{\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false}, \" +\n        \"{\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true}]\";\n    // 将json数组转为JSONArray对象\n    JSONArray jsonArray = JSONArray.fromObject(jsonStr);\n    // 将JSONArray对象转为List\n    List<Student> students = (List<Student>) JSONArray.toCollection(jsonArray, Student.class);\n    System.out.println(students);\n}\n// 输出：\n// [Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}, Student{name='jiang', age=18, isValid=true}]\n```\n\n### 2.4 json 复杂数据转为 JavaBean 对象\n\n如果 json 对象中包含数组，这个数组中包含 json 对象，如下所示：\n\n![image-20200514143731277](/pictures/image-20200514143731277-1595486755603.png)\n\n要将这个 json 字符串转为 JavaBean 对象，实体类需要有 List<Student\\> 属性。定义实体来 Teacher 如下：\n\n#### 2.4.1 创建 Teacher 对象\n\n```java\npublic class Teacher {\n    private String name;\n    private Integer age;\n    List<Student> students;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public List<Student> getStudents() {\n        return students;\n    }\n\n    public void setStudents(List<Student> students) {\n        this.students = students;\n    }\n}\n```\n\n#### 2.4.2 转换对象\n\n我们还是采用前面的方式进行转换，发现在获取 ``student.getName()`` 时报错**net.sf.ezmorph.bean.MorphDynaBean cannot be cast to** 如下所示：\n\n```java\n@Test\npublic void test3(){\n    String jsonStr = \"{\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\" +\n        \"[{\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true},\" +\n        \"{\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false}]}\";\n    // 将json数组转为JSONArray对象\n    JSONObject jsonObject = JSONObject.fromObject(jsonStr);\n    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher.class);\n    System.out.println(teacher);\n    for (Student student : teacher.getStudents()) {\n        System.out.println(student.getName());\n    }\n}\n// 输出：\n/* \nTeacher{name='teacher', age=30, students=[net.sf.ezmorph.bean.MorphDynaBean@3c6aa04a[\n  {isValid=true, name=julia, age=16}\n], net.sf.ezmorph.bean.MorphDynaBean@2257fadf[\n  {isValid=false, name=fan, age=17}\n]]}\n\njava.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.juliajiang.blogtest.entity.Student\n...\n*/\n```\n\n这是因为：在操作 json 数据时，如果没有指明数据类型，那么只能是基本类型（比如上述Integer、Boolean等）或者String类型，不能出现复杂数据类型。\n\n应该采用如下方式转换：\n\n```java\n@Test\npublic void test3(){\n    String jsonStr = \"{\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\" +\n        \"[{\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true},\" +\n        \"{\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false}]}\";\n    // 将json数组转为JSONArray对象\n    JSONObject jsonObject = JSONObject.fromObject(jsonStr);\n    Map<String, Class> map = new HashMap<>();\n    map.put(\"students\", Student.class);\n    // 添加map\n    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher.class, map);\n    System.out.println(teacher);\n    for (Student student : teacher.getStudents()) {\n        System.out.println(student.getName());\n    }\n}\n// 输出：\n/*\nTeacher{name='teacher', age=30, students=[Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}]}\njulia\nfan\n*/\n```\n\n其中 map 对象是 Teacher 中各个属性的类型，map 的 key 是属性的名，value 是属性的类型。\n\n## 3. 使用 fastjson\n\nfastjson 中文WiKi：https://github.com/alibaba/fastjson/wiki/Quick-Start-CN\n\n### 3.1 什么是 fastjson?\n\nfastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。\n\n### 3.2 引入 maven \n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.28</version>\n</dependency>\n```\n\n### 3.3 json 字符串与 Java 对象互转\n\n```java\n@Test\npublic void test4(){\n    Student student = new Student(\"julia\", 16, true);\n    // 将Java对象转为json字符串\n    String jsonString = JSON.toJSONString(student);\n    System.out.println(jsonString);\n    // 将json字符串转为Java对象\n    Student student1 = JSON.parseObject(jsonString, Student.class);\n    System.out.println(student1);\n}\n/* 输出：\n{\"age\":16,\"isValid\":true,\"name\":\"julia\"}\nStudent{name='julia', age=16, isValid=true}\n*/\n```\n\n### 3.4 json 数组转为 List\\<T> \n\n```java\n@Test\npublic void test(){\n    String jsonStr = \"[{\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true}, \" +\n        \"{\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false}, \" +\n        \"{\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true}]\";\n    List<Student> students = JSONArray.parseArray(jsonStr, Student.class);\n    System.out.println(students);\n}\n/*\n输出：\n[Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}, Student{name='jiang', age=18, isValid=true}]\n*/\n```\n\n### 3.5 json 复杂数据转为 Java 对象\n\n```java \n@Test\npublic void test2(){\n    String jsonStr = \"{\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\" +\n        \"[{\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true},\" +\n        \"{\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false}]}\";\n    Teacher teacher = JSON.parseObject(jsonStr, Teacher.class);\n    System.out.println(teacher);\n    for (Student student : teacher.getStudents()) {\n        System.out.println(student.getName());\n    }\n}\n/*输出：\nTeacher{name='teacher', age=30, students=[Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}]}\njulia\nfan\n*/\n```\n\n## 4. fastjson 和 json-lib 对比\n\n就以上三种使用途径来看，fastjson 确实更加方便。\n\n## 5. json 数据的传输与接收\n\nJSON 通常用于与服务端交换数据，在向服务器发送数据时一般是字符串。我们可以使用 `` JSON.stringify() `` 方法将 JavaScript 对象转换为字符串。\n\n向服务器发送请求：\n\n```javascript\nvar param = JSON.stringify(searchList);\n$.post(url, {\n            searchList:param\n        },function (data) {\n            /*...*/\n        });\n```\n\nspringboot 后台 controller 接收：\n\n```java\n@RequestMapping(\"/search\")\n@ResponseBody\npublic Map search(String searchList){\n    // 将前台接收的 json 数组转化为实体SearchList的列表\n    List<SearchList> lists = JSONArray.parseArray(searchList, SearchList.class);\n    /*...*/\n}\n```\n\n## 6. 参考文献\n\n1. https://www.runoob.com/json/json-tutorial.html","source":"_posts/JSON与Java对象的转换.md","raw":"---\ntitle: JSON与Java对象的转换\ndate: 2020-07-23 14:36:31\ntags:\n  - Java\n  - json\ncategories: Java\ntypora-copy-images-to: ..\\pictures\n---\n\n本文简要介绍了 JSON 的定义、语法规则，同时总结了两个把 JSON 字符串转为 JavaBean 的库分别是 json-lib、fastjson，另外还有 json 数据的传输与接收的简单使用。\n\n## 1. JSON\n\n### 1.1 什么是 JSON？\n\n**JSON（JavaScript Object Notation，JavaScript对象表示法）：**（from Wikipedia）是一种由道格拉斯·克罗克福特构想和设计、*轻量级的数据交换语言*，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是*独立于语言的文本格式*，并且采用了类似于C语言家族的一些习惯。\n\nJSON 数据格式与语言无关。即便它源自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。\n\n<!--more-->\n\n### 1.2 JSON 语法规则\n\n- 数据格式为 键/值 对（一个名称对应一个值）\n\n```json\n\"name\":\"julia\"\n```\n\n- 数据由逗号分隔\n- 大括号保存对象（对象可以保存多个键值对）\n\n```json\n{\"name\":\"julia\", \"url\":\"juliajiang7.github.io/\"}\n```\n\n- 方括号保存数组，数组可以包含对象\n\n```json\n\"sites\":[\n    {\"name\":\"julia\", \"url\":\"juliajiang7.github.io\"},\n    {\"name\":\"Google\", \"url\":\"www.google.com\"}\n]\n```\n\n详细请参考 [JSON教程](https://www.runoob.com/json/json-tutorial.html)\n\n## 2. 使用 json-lib\n\nhttp://json-lib.sourceforge.net/\n\nJSON-lib is a java library for transforming beans, maps, collections, java arrays and XML to JSON and back again to beans and DynaBeans.\nIt is based on the work by Douglas Crockford in http://www.json.org/java.\n\n### 2.1 引入 maven\n\n```xml\n<dependency>\n    <groupId>net.sf.json-lib</groupId>\n    <artifactId>json-lib</artifactId>\n    <version>2.2.3</version>\n    <classifier>jdk15</classifier>\n</dependency>\n```\n\n### 2.2 json 对象转为 Java 对象\n\n#### 2.2.1 创建实体 Student \n\n```java\npublic class Student {\n    private String name;\n    private Integer age;\n    private Boolean isValid;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public Boolean getIsValid() {\n        return isValid;\n    }\n\n    public void setIsValid(Boolean valid) {\n        isValid = valid;\n    }\n}\n```\n\n#### 2.2.2 转换对象\n\n```java\n@Test\npublic void test(){\n    String jsonStr = \"{\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true}\";\n    // 将json字符串转为JSONObject对象\n    JSONObject jsonObject = JSONObject.fromObject(jsonStr);\n    // 将JSONObject对象转为Student对象\n    Student student = (Student) JSONObject.toBean(jsonObject, Student.class);\n    System.out.println(student);\n}\n// 输出：\n// Student{name='julia', age=16, isValid=true}\n```\n\n### 2.3 json 数组转为 Java 的 List\\<T>\n\n```java\n@Test\npublic void test2(){\n    String jsonStr = \"[{\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true}, \" +\n        \"{\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false}, \" +\n        \"{\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true}]\";\n    // 将json数组转为JSONArray对象\n    JSONArray jsonArray = JSONArray.fromObject(jsonStr);\n    // 将JSONArray对象转为List\n    List<Student> students = (List<Student>) JSONArray.toCollection(jsonArray, Student.class);\n    System.out.println(students);\n}\n// 输出：\n// [Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}, Student{name='jiang', age=18, isValid=true}]\n```\n\n### 2.4 json 复杂数据转为 JavaBean 对象\n\n如果 json 对象中包含数组，这个数组中包含 json 对象，如下所示：\n\n![image-20200514143731277](/pictures/image-20200514143731277-1595486755603.png)\n\n要将这个 json 字符串转为 JavaBean 对象，实体类需要有 List<Student\\> 属性。定义实体来 Teacher 如下：\n\n#### 2.4.1 创建 Teacher 对象\n\n```java\npublic class Teacher {\n    private String name;\n    private Integer age;\n    List<Student> students;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public List<Student> getStudents() {\n        return students;\n    }\n\n    public void setStudents(List<Student> students) {\n        this.students = students;\n    }\n}\n```\n\n#### 2.4.2 转换对象\n\n我们还是采用前面的方式进行转换，发现在获取 ``student.getName()`` 时报错**net.sf.ezmorph.bean.MorphDynaBean cannot be cast to** 如下所示：\n\n```java\n@Test\npublic void test3(){\n    String jsonStr = \"{\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\" +\n        \"[{\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true},\" +\n        \"{\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false}]}\";\n    // 将json数组转为JSONArray对象\n    JSONObject jsonObject = JSONObject.fromObject(jsonStr);\n    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher.class);\n    System.out.println(teacher);\n    for (Student student : teacher.getStudents()) {\n        System.out.println(student.getName());\n    }\n}\n// 输出：\n/* \nTeacher{name='teacher', age=30, students=[net.sf.ezmorph.bean.MorphDynaBean@3c6aa04a[\n  {isValid=true, name=julia, age=16}\n], net.sf.ezmorph.bean.MorphDynaBean@2257fadf[\n  {isValid=false, name=fan, age=17}\n]]}\n\njava.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.juliajiang.blogtest.entity.Student\n...\n*/\n```\n\n这是因为：在操作 json 数据时，如果没有指明数据类型，那么只能是基本类型（比如上述Integer、Boolean等）或者String类型，不能出现复杂数据类型。\n\n应该采用如下方式转换：\n\n```java\n@Test\npublic void test3(){\n    String jsonStr = \"{\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\" +\n        \"[{\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true},\" +\n        \"{\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false}]}\";\n    // 将json数组转为JSONArray对象\n    JSONObject jsonObject = JSONObject.fromObject(jsonStr);\n    Map<String, Class> map = new HashMap<>();\n    map.put(\"students\", Student.class);\n    // 添加map\n    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher.class, map);\n    System.out.println(teacher);\n    for (Student student : teacher.getStudents()) {\n        System.out.println(student.getName());\n    }\n}\n// 输出：\n/*\nTeacher{name='teacher', age=30, students=[Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}]}\njulia\nfan\n*/\n```\n\n其中 map 对象是 Teacher 中各个属性的类型，map 的 key 是属性的名，value 是属性的类型。\n\n## 3. 使用 fastjson\n\nfastjson 中文WiKi：https://github.com/alibaba/fastjson/wiki/Quick-Start-CN\n\n### 3.1 什么是 fastjson?\n\nfastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。\n\n### 3.2 引入 maven \n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.28</version>\n</dependency>\n```\n\n### 3.3 json 字符串与 Java 对象互转\n\n```java\n@Test\npublic void test4(){\n    Student student = new Student(\"julia\", 16, true);\n    // 将Java对象转为json字符串\n    String jsonString = JSON.toJSONString(student);\n    System.out.println(jsonString);\n    // 将json字符串转为Java对象\n    Student student1 = JSON.parseObject(jsonString, Student.class);\n    System.out.println(student1);\n}\n/* 输出：\n{\"age\":16,\"isValid\":true,\"name\":\"julia\"}\nStudent{name='julia', age=16, isValid=true}\n*/\n```\n\n### 3.4 json 数组转为 List\\<T> \n\n```java\n@Test\npublic void test(){\n    String jsonStr = \"[{\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true}, \" +\n        \"{\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false}, \" +\n        \"{\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true}]\";\n    List<Student> students = JSONArray.parseArray(jsonStr, Student.class);\n    System.out.println(students);\n}\n/*\n输出：\n[Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}, Student{name='jiang', age=18, isValid=true}]\n*/\n```\n\n### 3.5 json 复杂数据转为 Java 对象\n\n```java \n@Test\npublic void test2(){\n    String jsonStr = \"{\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\" +\n        \"[{\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true},\" +\n        \"{\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false}]}\";\n    Teacher teacher = JSON.parseObject(jsonStr, Teacher.class);\n    System.out.println(teacher);\n    for (Student student : teacher.getStudents()) {\n        System.out.println(student.getName());\n    }\n}\n/*输出：\nTeacher{name='teacher', age=30, students=[Student{name='julia', age=16, isValid=true}, Student{name='fan', age=17, isValid=false}]}\njulia\nfan\n*/\n```\n\n## 4. fastjson 和 json-lib 对比\n\n就以上三种使用途径来看，fastjson 确实更加方便。\n\n## 5. json 数据的传输与接收\n\nJSON 通常用于与服务端交换数据，在向服务器发送数据时一般是字符串。我们可以使用 `` JSON.stringify() `` 方法将 JavaScript 对象转换为字符串。\n\n向服务器发送请求：\n\n```javascript\nvar param = JSON.stringify(searchList);\n$.post(url, {\n            searchList:param\n        },function (data) {\n            /*...*/\n        });\n```\n\nspringboot 后台 controller 接收：\n\n```java\n@RequestMapping(\"/search\")\n@ResponseBody\npublic Map search(String searchList){\n    // 将前台接收的 json 数组转化为实体SearchList的列表\n    List<SearchList> lists = JSONArray.parseArray(searchList, SearchList.class);\n    /*...*/\n}\n```\n\n## 6. 参考文献\n\n1. https://www.runoob.com/json/json-tutorial.html","slug":"JSON与Java对象的转换","published":1,"updated":"2020-07-23T07:00:41.280Z","_id":"ckcyg4y4v0001jkuq8x3p0f12","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文简要介绍了 JSON 的定义、语法规则，同时总结了两个把 JSON 字符串转为 JavaBean 的库分别是 json-lib、fastjson，另外还有 json 数据的传输与接收的简单使用。</p>\n<h2 id=\"1-JSON\"><a href=\"#1-JSON\" class=\"headerlink\" title=\"1. JSON\"></a>1. JSON</h2><h3 id=\"1-1-什么是-JSON？\"><a href=\"#1-1-什么是-JSON？\" class=\"headerlink\" title=\"1.1 什么是 JSON？\"></a>1.1 什么是 JSON？</h3><p><strong>JSON（JavaScript Object Notation，JavaScript对象表示法）：</strong>（from Wikipedia）是一种由道格拉斯·克罗克福特构想和设计、<em>轻量级的数据交换语言</em>，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是<em>独立于语言的文本格式</em>，并且采用了类似于C语言家族的一些习惯。</p>\n<p>JSON 数据格式与语言无关。即便它源自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-2-JSON-语法规则\"><a href=\"#1-2-JSON-语法规则\" class=\"headerlink\" title=\"1.2 JSON 语法规则\"></a>1.2 JSON 语法规则</h3><ul>\n<li>数据格式为 键/值 对（一个名称对应一个值）</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"name\":\"julia\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数据由逗号分隔</li>\n<li>大括号保存对象（对象可以保存多个键值对）</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">\"name\"</span>:<span class=\"string\">\"julia\"</span>, <span class=\"attr\">\"url\"</span>:<span class=\"string\">\"juliajiang7.github.io/\"</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方括号保存数组，数组可以包含对象</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"sites\":[</span><br><span class=\"line\">    &#123;\"name\":\"julia\", \"url\":\"juliajiang7.github.io\"&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">\"name\"</span>:<span class=\"string\">\"Google\"</span>, <span class=\"attr\">\"url\"</span>:<span class=\"string\">\"www.google.com\"</span>&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>详细请参考 <a href=\"https://www.runoob.com/json/json-tutorial.html\" target=\"_blank\" rel=\"noopener\">JSON教程</a></p>\n<h2 id=\"2-使用-json-lib\"><a href=\"#2-使用-json-lib\" class=\"headerlink\" title=\"2. 使用 json-lib\"></a>2. 使用 json-lib</h2><p><a href=\"http://json-lib.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">http://json-lib.sourceforge.net/</a></p>\n<p>JSON-lib is a java library for transforming beans, maps, collections, java arrays and XML to JSON and back again to beans and DynaBeans.<br>It is based on the work by Douglas Crockford in <a href=\"http://www.json.org/java\" target=\"_blank\" rel=\"noopener\">http://www.json.org/java</a>.</p>\n<h3 id=\"2-1-引入-maven\"><a href=\"#2-1-引入-maven\" class=\"headerlink\" title=\"2.1 引入 maven\"></a>2.1 引入 maven</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.json-lib<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>json-lib<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">classifier</span>&gt;</span>jdk15<span class=\"tag\">&lt;/<span class=\"name\">classifier</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-json-对象转为-Java-对象\"><a href=\"#2-2-json-对象转为-Java-对象\" class=\"headerlink\" title=\"2.2 json 对象转为 Java 对象\"></a>2.2 json 对象转为 Java 对象</h3><h4 id=\"2-2-1-创建实体-Student\"><a href=\"#2-2-1-创建实体-Student\" class=\"headerlink\" title=\"2.2.1 创建实体 Student\"></a>2.2.1 创建实体 Student</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean isValid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">getIsValid</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIsValid</span><span class=\"params\">(Boolean valid)</span> </span>&#123;</span><br><span class=\"line\">        isValid = valid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-转换对象\"><a href=\"#2-2-2-转换对象\" class=\"headerlink\" title=\"2.2.2 转换对象\"></a>2.2.2 转换对象</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json字符串转为JSONObject对象</span></span><br><span class=\"line\">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class=\"line\">    <span class=\"comment\">// 将JSONObject对象转为Student对象</span></span><br><span class=\"line\">    Student student = (Student) JSONObject.toBean(jsonObject, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-json-数组转为-Java-的-List-lt-T-gt\"><a href=\"#2-3-json-数组转为-Java-的-List-lt-T-gt\" class=\"headerlink\" title=\"2.3 json 数组转为 Java 的 List&lt;T&gt;\"></a>2.3 json 数组转为 Java 的 List&lt;T&gt;</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true&#125;]\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json数组转为JSONArray对象</span></span><br><span class=\"line\">    JSONArray jsonArray = JSONArray.fromObject(jsonStr);</span><br><span class=\"line\">    <span class=\"comment\">// 将JSONArray对象转为List</span></span><br><span class=\"line\">    List&lt;Student&gt; students = (List&lt;Student&gt;) JSONArray.toCollection(jsonArray, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(students);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// [Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-json-复杂数据转为-JavaBean-对象\"><a href=\"#2-4-json-复杂数据转为-JavaBean-对象\" class=\"headerlink\" title=\"2.4 json 复杂数据转为 JavaBean 对象\"></a>2.4 json 复杂数据转为 JavaBean 对象</h3><p>如果 json 对象中包含数组，这个数组中包含 json 对象，如下所示：</p>\n<p><img src=\"/pictures/image-20200514143731277-1595486755603.png\" alt=\"image-20200514143731277\"></p>\n<p>要将这个 json 字符串转为 JavaBean 对象，实体类需要有 List&lt;Student&gt; 属性。定义实体来 Teacher 如下：</p>\n<h4 id=\"2-4-1-创建-Teacher-对象\"><a href=\"#2-4-1-创建-Teacher-对象\" class=\"headerlink\" title=\"2.4.1 创建 Teacher 对象\"></a>2.4.1 创建 Teacher 对象</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    List&lt;Student&gt; students;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Student&gt; <span class=\"title\">getStudents</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStudents</span><span class=\"params\">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.students = students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-2-转换对象\"><a href=\"#2-4-2-转换对象\" class=\"headerlink\" title=\"2.4.2 转换对象\"></a>2.4.2 转换对象</h4><p>我们还是采用前面的方式进行转换，发现在获取 <code>student.getName()</code> 时报错<strong>net.sf.ezmorph.bean.MorphDynaBean cannot be cast to</strong> 如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true&#125;,\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false&#125;]&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json数组转为JSONArray对象</span></span><br><span class=\"line\">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class=\"line\">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(teacher);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class=\"line\">        System.out.println(student.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">Teacher&#123;name='teacher', age=30, students=[net.sf.ezmorph.bean.MorphDynaBean@3c6aa04a[</span></span><br><span class=\"line\"><span class=\"comment\">  &#123;isValid=true, name=julia, age=16&#125;</span></span><br><span class=\"line\"><span class=\"comment\">], net.sf.ezmorph.bean.MorphDynaBean@2257fadf[</span></span><br><span class=\"line\"><span class=\"comment\">  &#123;isValid=false, name=fan, age=17&#125;</span></span><br><span class=\"line\"><span class=\"comment\">]]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">java.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.juliajiang.blogtest.entity.Student</span></span><br><span class=\"line\"><span class=\"comment\">...</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为：在操作 json 数据时，如果没有指明数据类型，那么只能是基本类型（比如上述Integer、Boolean等）或者String类型，不能出现复杂数据类型。</p>\n<p>应该采用如下方式转换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true&#125;,\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false&#125;]&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json数组转为JSONArray对象</span></span><br><span class=\"line\">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class=\"line\">    Map&lt;String, Class&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"string\">\"students\"</span>, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 添加map</span></span><br><span class=\"line\">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">map</span>)</span>;</span><br><span class=\"line\">    System.out.println(teacher);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class=\"line\">        System.out.println(student.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">julia</span></span><br><span class=\"line\"><span class=\"comment\">fan</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 map 对象是 Teacher 中各个属性的类型，map 的 key 是属性的名，value 是属性的类型。</p>\n<h2 id=\"3-使用-fastjson\"><a href=\"#3-使用-fastjson\" class=\"headerlink\" title=\"3. 使用 fastjson\"></a>3. 使用 fastjson</h2><p>fastjson 中文WiKi：<a href=\"https://github.com/alibaba/fastjson/wiki/Quick-Start-CN\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p>\n<h3 id=\"3-1-什么是-fastjson\"><a href=\"#3-1-什么是-fastjson\" class=\"headerlink\" title=\"3.1 什么是 fastjson?\"></a>3.1 什么是 fastjson?</h3><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>\n<h3 id=\"3-2-引入-maven\"><a href=\"#3-2-引入-maven\" class=\"headerlink\" title=\"3.2 引入 maven\"></a>3.2 引入 maven</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>fastjson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.28<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-json-字符串与-Java-对象互转\"><a href=\"#3-3-json-字符串与-Java-对象互转\" class=\"headerlink\" title=\"3.3 json 字符串与 Java 对象互转\"></a>3.3 json 字符串与 Java 对象互转</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"julia\"</span>, <span class=\"number\">16</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 将Java对象转为json字符串</span></span><br><span class=\"line\">    String jsonString = JSON.toJSONString(student);</span><br><span class=\"line\">    System.out.println(jsonString);</span><br><span class=\"line\">    <span class=\"comment\">// 将json字符串转为Java对象</span></span><br><span class=\"line\">    Student student1 = JSON.parseObject(jsonString, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(student1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 输出：</span></span><br><span class=\"line\"><span class=\"comment\">&#123;\"age\":16,\"isValid\":true,\"name\":\"julia\"&#125;</span></span><br><span class=\"line\"><span class=\"comment\">Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-json-数组转为-List-lt-T-gt\"><a href=\"#3-4-json-数组转为-List-lt-T-gt\" class=\"headerlink\" title=\"3.4 json 数组转为 List&lt;T&gt;\"></a>3.4 json 数组转为 List&lt;T&gt;</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true&#125;]\"</span>;</span><br><span class=\"line\">    List&lt;Student&gt; students = JSONArray.parseArray(jsonStr, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(students);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\">[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-json-复杂数据转为-Java-对象\"><a href=\"#3-5-json-复杂数据转为-Java-对象\" class=\"headerlink\" title=\"3.5 json 复杂数据转为 Java 对象\"></a>3.5 json 复杂数据转为 Java 对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true&#125;,\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false&#125;]&#125;\"</span>;</span><br><span class=\"line\">    Teacher teacher = JSON.parseObject(jsonStr, Teacher<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(teacher);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class=\"line\">        System.out.println(student.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*输出：</span></span><br><span class=\"line\"><span class=\"comment\">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">julia</span></span><br><span class=\"line\"><span class=\"comment\">fan</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-fastjson-和-json-lib-对比\"><a href=\"#4-fastjson-和-json-lib-对比\" class=\"headerlink\" title=\"4. fastjson 和 json-lib 对比\"></a>4. fastjson 和 json-lib 对比</h2><p>就以上三种使用途径来看，fastjson 确实更加方便。</p>\n<h2 id=\"5-json-数据的传输与接收\"><a href=\"#5-json-数据的传输与接收\" class=\"headerlink\" title=\"5. json 数据的传输与接收\"></a>5. json 数据的传输与接收</h2><p>JSON 通常用于与服务端交换数据，在向服务器发送数据时一般是字符串。我们可以使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为字符串。</p>\n<p>向服务器发送请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> param = <span class=\"built_in\">JSON</span>.stringify(searchList);</span><br><span class=\"line\">$.post(url, &#123;</span><br><span class=\"line\">            searchList:param</span><br><span class=\"line\">        &#125;,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>springboot 后台 controller 接收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/search\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">search</span><span class=\"params\">(String searchList)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将前台接收的 json 数组转化为实体SearchList的列表</span></span><br><span class=\"line\">    List&lt;SearchList&gt; lists = JSONArray.parseArray(searchList, SearchList<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-参考文献\"><a href=\"#6-参考文献\" class=\"headerlink\" title=\"6. 参考文献\"></a>6. 参考文献</h2><ol>\n<li><a href=\"https://www.runoob.com/json/json-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/json/json-tutorial.html</a></li>\n</ol>\n","site":{"data":{}},"length":7675,"excerpt":"<p>本文简要介绍了 JSON 的定义、语法规则，同时总结了两个把 JSON 字符串转为 JavaBean 的库分别是 json-lib、fastjson，另外还有 json 数据的传输与接收的简单使用。</p>\n<h2 id=\"1-JSON\"><a href=\"#1-JSON\" class=\"headerlink\" title=\"1. JSON\"></a>1. JSON</h2><h3 id=\"1-1-什么是-JSON？\"><a href=\"#1-1-什么是-JSON？\" class=\"headerlink\" title=\"1.1 什么是 JSON？\"></a>1.1 什么是 JSON？</h3><p><strong>JSON（JavaScript Object Notation，JavaScript对象表示法）：</strong>（from Wikipedia）是一种由道格拉斯·克罗克福特构想和设计、<em>轻量级的数据交换语言</em>，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是<em>独立于语言的文本格式</em>，并且采用了类似于C语言家族的一些习惯。</p>\n<p>JSON 数据格式与语言无关。即便它源自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析。JSON 的官方 MIME 类型是 application/json，文件扩展名是 .json。</p>","more":"<h3 id=\"1-2-JSON-语法规则\"><a href=\"#1-2-JSON-语法规则\" class=\"headerlink\" title=\"1.2 JSON 语法规则\"></a>1.2 JSON 语法规则</h3><ul>\n<li>数据格式为 键/值 对（一个名称对应一个值）</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"name\":\"julia\"</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数据由逗号分隔</li>\n<li>大括号保存对象（对象可以保存多个键值对）</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">\"name\"</span>:<span class=\"string\">\"julia\"</span>, <span class=\"attr\">\"url\"</span>:<span class=\"string\">\"juliajiang7.github.io/\"</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方括号保存数组，数组可以包含对象</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"sites\":[</span><br><span class=\"line\">    &#123;\"name\":\"julia\", \"url\":\"juliajiang7.github.io\"&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">\"name\"</span>:<span class=\"string\">\"Google\"</span>, <span class=\"attr\">\"url\"</span>:<span class=\"string\">\"www.google.com\"</span>&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>详细请参考 <a href=\"https://www.runoob.com/json/json-tutorial.html\" target=\"_blank\" rel=\"noopener\">JSON教程</a></p>\n<h2 id=\"2-使用-json-lib\"><a href=\"#2-使用-json-lib\" class=\"headerlink\" title=\"2. 使用 json-lib\"></a>2. 使用 json-lib</h2><p><a href=\"http://json-lib.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">http://json-lib.sourceforge.net/</a></p>\n<p>JSON-lib is a java library for transforming beans, maps, collections, java arrays and XML to JSON and back again to beans and DynaBeans.<br>It is based on the work by Douglas Crockford in <a href=\"http://www.json.org/java\" target=\"_blank\" rel=\"noopener\">http://www.json.org/java</a>.</p>\n<h3 id=\"2-1-引入-maven\"><a href=\"#2-1-引入-maven\" class=\"headerlink\" title=\"2.1 引入 maven\"></a>2.1 引入 maven</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.json-lib<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>json-lib<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">classifier</span>&gt;</span>jdk15<span class=\"tag\">&lt;/<span class=\"name\">classifier</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-json-对象转为-Java-对象\"><a href=\"#2-2-json-对象转为-Java-对象\" class=\"headerlink\" title=\"2.2 json 对象转为 Java 对象\"></a>2.2 json 对象转为 Java 对象</h3><h4 id=\"2-2-1-创建实体-Student\"><a href=\"#2-2-1-创建实体-Student\" class=\"headerlink\" title=\"2.2.1 创建实体 Student\"></a>2.2.1 创建实体 Student</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean isValid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">getIsValid</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setIsValid</span><span class=\"params\">(Boolean valid)</span> </span>&#123;</span><br><span class=\"line\">        isValid = valid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-转换对象\"><a href=\"#2-2-2-转换对象\" class=\"headerlink\" title=\"2.2.2 转换对象\"></a>2.2.2 转换对象</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json字符串转为JSONObject对象</span></span><br><span class=\"line\">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class=\"line\">    <span class=\"comment\">// 将JSONObject对象转为Student对象</span></span><br><span class=\"line\">    Student student = (Student) JSONObject.toBean(jsonObject, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-json-数组转为-Java-的-List-lt-T-gt\"><a href=\"#2-3-json-数组转为-Java-的-List-lt-T-gt\" class=\"headerlink\" title=\"2.3 json 数组转为 Java 的 List&lt;T&gt;\"></a>2.3 json 数组转为 Java 的 List&lt;T&gt;</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true&#125;]\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json数组转为JSONArray对象</span></span><br><span class=\"line\">    JSONArray jsonArray = JSONArray.fromObject(jsonStr);</span><br><span class=\"line\">    <span class=\"comment\">// 将JSONArray对象转为List</span></span><br><span class=\"line\">    List&lt;Student&gt; students = (List&lt;Student&gt;) JSONArray.toCollection(jsonArray, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(students);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// [Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-json-复杂数据转为-JavaBean-对象\"><a href=\"#2-4-json-复杂数据转为-JavaBean-对象\" class=\"headerlink\" title=\"2.4 json 复杂数据转为 JavaBean 对象\"></a>2.4 json 复杂数据转为 JavaBean 对象</h3><p>如果 json 对象中包含数组，这个数组中包含 json 对象，如下所示：</p>\n<p><img src=\"/pictures/image-20200514143731277-1595486755603.png\" alt=\"image-20200514143731277\"></p>\n<p>要将这个 json 字符串转为 JavaBean 对象，实体类需要有 List&lt;Student&gt; 属性。定义实体来 Teacher 如下：</p>\n<h4 id=\"2-4-1-创建-Teacher-对象\"><a href=\"#2-4-1-创建-Teacher-对象\" class=\"headerlink\" title=\"2.4.1 创建 Teacher 对象\"></a>2.4.1 创建 Teacher 对象</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    List&lt;Student&gt; students;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Student&gt; <span class=\"title\">getStudents</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStudents</span><span class=\"params\">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.students = students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-2-转换对象\"><a href=\"#2-4-2-转换对象\" class=\"headerlink\" title=\"2.4.2 转换对象\"></a>2.4.2 转换对象</h4><p>我们还是采用前面的方式进行转换，发现在获取 <code>student.getName()</code> 时报错<strong>net.sf.ezmorph.bean.MorphDynaBean cannot be cast to</strong> 如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true&#125;,\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false&#125;]&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json数组转为JSONArray对象</span></span><br><span class=\"line\">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class=\"line\">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(teacher);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class=\"line\">        System.out.println(student.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">Teacher&#123;name='teacher', age=30, students=[net.sf.ezmorph.bean.MorphDynaBean@3c6aa04a[</span></span><br><span class=\"line\"><span class=\"comment\">  &#123;isValid=true, name=julia, age=16&#125;</span></span><br><span class=\"line\"><span class=\"comment\">], net.sf.ezmorph.bean.MorphDynaBean@2257fadf[</span></span><br><span class=\"line\"><span class=\"comment\">  &#123;isValid=false, name=fan, age=17&#125;</span></span><br><span class=\"line\"><span class=\"comment\">]]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">java.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.juliajiang.blogtest.entity.Student</span></span><br><span class=\"line\"><span class=\"comment\">...</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为：在操作 json 数据时，如果没有指明数据类型，那么只能是基本类型（比如上述Integer、Boolean等）或者String类型，不能出现复杂数据类型。</p>\n<p>应该采用如下方式转换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true&#125;,\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false&#125;]&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将json数组转为JSONArray对象</span></span><br><span class=\"line\">    JSONObject jsonObject = JSONObject.fromObject(jsonStr);</span><br><span class=\"line\">    Map&lt;String, Class&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"string\">\"students\"</span>, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 添加map</span></span><br><span class=\"line\">    Teacher teacher = (Teacher) JSONObject.toBean(jsonObject, Teacher<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">map</span>)</span>;</span><br><span class=\"line\">    System.out.println(teacher);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class=\"line\">        System.out.println(student.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">julia</span></span><br><span class=\"line\"><span class=\"comment\">fan</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 map 对象是 Teacher 中各个属性的类型，map 的 key 是属性的名，value 是属性的类型。</p>\n<h2 id=\"3-使用-fastjson\"><a href=\"#3-使用-fastjson\" class=\"headerlink\" title=\"3. 使用 fastjson\"></a>3. 使用 fastjson</h2><p>fastjson 中文WiKi：<a href=\"https://github.com/alibaba/fastjson/wiki/Quick-Start-CN\" target=\"_blank\" rel=\"noopener\">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p>\n<h3 id=\"3-1-什么是-fastjson\"><a href=\"#3-1-什么是-fastjson\" class=\"headerlink\" title=\"3.1 什么是 fastjson?\"></a>3.1 什么是 fastjson?</h3><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>\n<h3 id=\"3-2-引入-maven\"><a href=\"#3-2-引入-maven\" class=\"headerlink\" title=\"3.2 引入 maven\"></a>3.2 引入 maven</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>fastjson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.28<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-json-字符串与-Java-对象互转\"><a href=\"#3-3-json-字符串与-Java-对象互转\" class=\"headerlink\" title=\"3.3 json 字符串与 Java 对象互转\"></a>3.3 json 字符串与 Java 对象互转</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"julia\"</span>, <span class=\"number\">16</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 将Java对象转为json字符串</span></span><br><span class=\"line\">    String jsonString = JSON.toJSONString(student);</span><br><span class=\"line\">    System.out.println(jsonString);</span><br><span class=\"line\">    <span class=\"comment\">// 将json字符串转为Java对象</span></span><br><span class=\"line\">    Student student1 = JSON.parseObject(jsonString, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(student1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 输出：</span></span><br><span class=\"line\"><span class=\"comment\">&#123;\"age\":16,\"isValid\":true,\"name\":\"julia\"&#125;</span></span><br><span class=\"line\"><span class=\"comment\">Student&#123;name='julia', age=16, isValid=true&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-json-数组转为-List-lt-T-gt\"><a href=\"#3-4-json-数组转为-List-lt-T-gt\" class=\"headerlink\" title=\"3.4 json 数组转为 List&lt;T&gt;\"></a>3.4 json 数组转为 List&lt;T&gt;</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\", \\\"age\\\":16, \\\"isValid\\\":true&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\", \\\"age\\\":17, \\\"isValid\\\":false&#125;, \"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"jiang\\\", \\\"age\\\":18, \\\"isValid\\\":true&#125;]\"</span>;</span><br><span class=\"line\">    List&lt;Student&gt; students = JSONArray.parseArray(jsonStr, Student<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(students);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\">[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;, Student&#123;name='jiang', age=18, isValid=true&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-json-复杂数据转为-Java-对象\"><a href=\"#3-5-json-复杂数据转为-Java-对象\" class=\"headerlink\" title=\"3.5 json 复杂数据转为 Java 对象\"></a>3.5 json 复杂数据转为 Java 对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jsonStr = <span class=\"string\">\"&#123;\\\"name\\\":\\\"teacher\\\", \\\"age\\\":30, \\\"students\\\":\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"[&#123;\\\"name\\\":\\\"julia\\\",\\\"age\\\":16,\\\"isValid\\\":true&#125;,\"</span> +</span><br><span class=\"line\">        <span class=\"string\">\"&#123;\\\"name\\\":\\\"fan\\\",\\\"age\\\":17,\\\"isValid\\\":false&#125;]&#125;\"</span>;</span><br><span class=\"line\">    Teacher teacher = JSON.parseObject(jsonStr, Teacher<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    System.out.println(teacher);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : teacher.getStudents()) &#123;</span><br><span class=\"line\">        System.out.println(student.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*输出：</span></span><br><span class=\"line\"><span class=\"comment\">Teacher&#123;name='teacher', age=30, students=[Student&#123;name='julia', age=16, isValid=true&#125;, Student&#123;name='fan', age=17, isValid=false&#125;]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">julia</span></span><br><span class=\"line\"><span class=\"comment\">fan</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-fastjson-和-json-lib-对比\"><a href=\"#4-fastjson-和-json-lib-对比\" class=\"headerlink\" title=\"4. fastjson 和 json-lib 对比\"></a>4. fastjson 和 json-lib 对比</h2><p>就以上三种使用途径来看，fastjson 确实更加方便。</p>\n<h2 id=\"5-json-数据的传输与接收\"><a href=\"#5-json-数据的传输与接收\" class=\"headerlink\" title=\"5. json 数据的传输与接收\"></a>5. json 数据的传输与接收</h2><p>JSON 通常用于与服务端交换数据，在向服务器发送数据时一般是字符串。我们可以使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为字符串。</p>\n<p>向服务器发送请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> param = <span class=\"built_in\">JSON</span>.stringify(searchList);</span><br><span class=\"line\">$.post(url, &#123;</span><br><span class=\"line\">            searchList:param</span><br><span class=\"line\">        &#125;,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>springboot 后台 controller 接收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/search\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">search</span><span class=\"params\">(String searchList)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将前台接收的 json 数组转化为实体SearchList的列表</span></span><br><span class=\"line\">    List&lt;SearchList&gt; lists = JSONArray.parseArray(searchList, SearchList<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-参考文献\"><a href=\"#6-参考文献\" class=\"headerlink\" title=\"6. 参考文献\"></a>6. 参考文献</h2><ol>\n<li><a href=\"https://www.runoob.com/json/json-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/json/json-tutorial.html</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8x8a1fo0001fwuq3y1u7j0i","category_id":"ck8x8a1g10005fwuq5udm0l9w","_id":"ck8x8a1ge000afwuqfu72ema1"},{"post_id":"ck8x8a1g50007fwuq9dp15rd2","category_id":"ck8x8a1g10005fwuq5udm0l9w","_id":"ck8x8a1gg000dfwuq9dtd7gs5"},{"post_id":"ckcrjzdl40000souq1s2u9msj","category_id":"ckcrjzdm30001souq13d095n1","_id":"ckcrjzdme0005souq9nkbcevy"},{"post_id":"ckcyg4y4v0001jkuq8x3p0f12","category_id":"ck8x8a1g10005fwuq5udm0l9w","_id":"ckcyg4y500003jkuq2bcl4yqj"}],"PostTag":[{"post_id":"ck8x8a1fo0001fwuq3y1u7j0i","tag_id":"ck8x8a1g30006fwuqedjjbct3","_id":"ck8x8a1gg000cfwuqfks8dfzi"},{"post_id":"ck8x8a1fo0001fwuq3y1u7j0i","tag_id":"ck8x8a1ga0009fwuqg9lha7yr","_id":"ck8x8a1gg000efwuq0pm87kfp"},{"post_id":"ck8x8a1g50007fwuq9dp15rd2","tag_id":"ck8x8a1ge000bfwuq76yk6n1y","_id":"ck8x8a1gi000gfwuq27c9exbz"},{"post_id":"ck8x8a1g50007fwuq9dp15rd2","tag_id":"ck8x8a1ga0009fwuqg9lha7yr","_id":"ck8x8a1gi000hfwuqezsgbf61"},{"post_id":"ckcrjzdl40000souq1s2u9msj","tag_id":"ck8x8a1ge000bfwuq76yk6n1y","_id":"ckcrjzdmd0003souq0suae4wz"},{"post_id":"ckcrjzdl40000souq1s2u9msj","tag_id":"ckcrjzdm70002souqb6777z0f","_id":"ckcrjzdmd0004souq6kx3525e"},{"post_id":"ckcyg4y4v0001jkuq8x3p0f12","tag_id":"ck8x8a1ga0009fwuqg9lha7yr","_id":"ckcyg4y500004jkuq4m3p3kf3"},{"post_id":"ckcyg4y4v0001jkuq8x3p0f12","tag_id":"ckcyg4y4w0002jkuqawcj4pvi","_id":"ckcyg4y500005jkuq6o07h7qj"}],"Tag":[{"name":"HashMap","_id":"ck8x8a1g30006fwuqedjjbct3"},{"name":"Java","_id":"ck8x8a1ga0009fwuqg9lha7yr"},{"name":"String","_id":"ck8x8a1ge000bfwuq76yk6n1y"},{"name":"Algorithm","_id":"ckcrjzdm70002souqb6777z0f"},{"name":"json","_id":"ckcyg4y4w0002jkuqawcj4pvi"}]}}